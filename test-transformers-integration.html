<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test TransformersProvider Integration - LocalRetrieve</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fafafa;
        }
        .test-section h3 {
            color: #34495e;
            margin-top: 0;
        }
        .input-group {
            margin: 15px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input, textarea, button {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        textarea {
            height: 100px;
            resize: vertical;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            margin: 5px 0;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background-color: #cce7ff;
            color: #004085;
            border: 1px solid #99d3ff;
        }
        .result {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        .metric-label {
            color: #7f8c8d;
            font-size: 14px;
        }
        .log {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin: 15px 0;
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ TransformersProvider Integration Test</h1>

        <!-- Environment Check -->
        <div class="test-section">
            <h3>üîç Environment Check</h3>
            <div id="environmentStatus" class="status info">–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è...</div>
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="webWorkersSupport">‚ùì</div>
                    <div class="metric-label">Web Workers</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="sharedArrayBufferSupport">‚ùì</div>
                    <div class="metric-label">SharedArrayBuffer</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="wasmSupport">‚ùì</div>
                    <div class="metric-label">WebAssembly</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="transformersSupport">‚ùì</div>
                    <div class="metric-label">Transformers.js</div>
                </div>
            </div>
        </div>

        <!-- Provider Initialization -->
        <div class="test-section">
            <h3>‚ö° Provider Initialization</h3>
            <button id="initializeProvider">Initialize TransformersProvider</button>
            <div id="initStatus" class="status info" style="display: none;"></div>
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="modelLoadTime">-</div>
                    <div class="metric-label">Load Time (ms)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="providerReady">‚ùå</div>
                    <div class="metric-label">Ready</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="memoryUsage">-</div>
                    <div class="metric-label">Memory (MB)</div>
                </div>
            </div>
        </div>

        <!-- Single Embedding Test -->
        <div class="test-section">
            <h3>üìù Single Embedding Generation</h3>
            <div class="input-group">
                <label for="singleText">Text to embed:</label>
                <textarea id="singleText" placeholder="Enter text to generate embedding...">This is a test sentence for generating embeddings using the all-MiniLM-L6-v2 model.</textarea>
            </div>
            <button id="generateSingle">Generate Single Embedding</button>
            <div id="singleStatus" class="status info" style="display: none;"></div>
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="singleTime">-</div>
                    <div class="metric-label">Generation Time (ms)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="singleDimensions">-</div>
                    <div class="metric-label">Dimensions</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="singleNorm">-</div>
                    <div class="metric-label">Vector Norm</div>
                </div>
            </div>
            <div id="singleResult" class="result" style="display: none;"></div>
        </div>

        <!-- Batch Embedding Test -->
        <div class="test-section">
            <h3>üìö Batch Embedding Generation</h3>
            <div class="input-group">
                <label for="batchTexts">Texts (one per line):</label>
                <textarea id="batchTexts" placeholder="Enter multiple texts, one per line...">Hello world
How are you today?
This is a test sentence
Machine learning is fascinating
Natural language processing rocks</textarea>
            </div>
            <button id="generateBatch">Generate Batch Embeddings</button>
            <div id="batchStatus" class="status info" style="display: none;"></div>
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="batchTime">-</div>
                    <div class="metric-label">Total Time (ms)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="batchCount">-</div>
                    <div class="metric-label">Embeddings Count</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="avgTimePerEmbedding">-</div>
                    <div class="metric-label">Avg Time/Embedding (ms)</div>
                </div>
            </div>
            <div id="batchResult" class="result" style="display: none;"></div>
        </div>

        <!-- Performance Tests -->
        <div class="test-section">
            <h3>üöÄ Performance Tests</h3>
            <div class="input-group">
                <label for="perfCount">Number of texts to generate:</label>
                <input type="number" id="perfCount" value="10" min="1" max="50">
            </div>
            <button id="runPerformanceTest">Run Performance Test</button>
            <div id="perfStatus" class="status info" style="display: none;"></div>
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="perfTotalTime">-</div>
                    <div class="metric-label">Total Time (ms)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="perfAvgTime">-</div>
                    <div class="metric-label">Avg per Text (ms)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="perfThroughput">-</div>
                    <div class="metric-label">Texts/Second</div>
                </div>
            </div>
        </div>

        <!-- Provider Health Check -->
        <div class="test-section">
            <h3>üíä Health Check</h3>
            <button id="healthCheck">Check Provider Health</button>
            <div id="healthStatus" class="status info" style="display: none;"></div>
            <div id="healthResult" class="result" style="display: none;"></div>
        </div>

        <!-- Debug Log -->
        <div class="test-section">
            <h3>üêõ Debug Log</h3>
            <button id="clearLog">Clear Log</button>
            <div id="debugLog" class="log"></div>
        </div>
    </div>

    <script type="module">
        // Import –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ (–∏–º–∏—Ç–∞—Ü–∏—è)
        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Å—Ä–µ–¥–µ —ç—Ç–æ –±—É–¥–µ—Ç import –∏–∑ —Å–æ–±—Ä–∞–Ω–Ω–æ–≥–æ –º–æ–¥—É–ª—è

        // –õ–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        let provider = null;
        let isInitialized = false;

        // –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('debugLog');
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;

            console.log(`[TransformersTest] ${message}`);
        }

        function updateStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `status ${type}`;
            element.style.display = 'block';
        }

        function updateMetric(elementId, value) {
            document.getElementById(elementId).textContent = value;
        }

        function showResult(elementId, data) {
            const element = document.getElementById(elementId);
            element.textContent = JSON.stringify(data, null, 2);
            element.style.display = 'block';
        }

        function setLoading(buttonId, isLoading) {
            const button = document.getElementById(buttonId);
            if (isLoading) {
                button.disabled = true;
                button.innerHTML = '<span class="loading"></span>Loading...';
            } else {
                button.disabled = false;
                button.innerHTML = button.dataset.originalText || 'Button';
            }
        }

        // Environment Check
        function checkEnvironment() {
            log('–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è –±—Ä–∞—É–∑–µ—Ä–∞...');

            // Web Workers
            const webWorkersSupported = typeof Worker !== 'undefined';
            updateMetric('webWorkersSupport', webWorkersSupported ? '‚úÖ' : '‚ùå');

            // SharedArrayBuffer
            const sharedArrayBufferSupported = typeof SharedArrayBuffer !== 'undefined';
            updateMetric('sharedArrayBufferSupport', sharedArrayBufferSupported ? '‚úÖ' : '‚ùå');

            // WebAssembly
            const wasmSupported = typeof WebAssembly !== 'undefined';
            updateMetric('wasmSupport', wasmSupported ? '‚úÖ' : '‚ùå');

            // Mock TransformersJS support check
            // –í —Ä–µ–∞–ª—å–Ω–æ–π —Å—Ä–µ–¥–µ —ç—Ç–æ –±—É–¥–µ—Ç: isTransformersSupported()
            const transformersSupported = webWorkersSupported && sharedArrayBufferSupported && wasmSupported;
            updateMetric('transformersSupport', transformersSupported ? '‚úÖ' : '‚ùå');

            if (transformersSupported) {
                updateStatus('environmentStatus', '–û–∫—Ä—É–∂–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è TransformersProvider', 'success');
                log('–í—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ API –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è');
            } else {
                updateStatus('environmentStatus', '–ù–µ–∫–æ—Ç–æ—Ä—ã–µ API –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è. –¢—Ä–µ–±—É–µ—Ç—Å—è —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –±—Ä–∞—É–∑–µ—Ä.', 'error');
                log('–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–æ–±–ª–µ–º—ã —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏', 'error');
            }

            return transformersSupported;
        }

        // Mock TransformersProvider –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
        class MockTransformersProvider {
            constructor() {
                this.isReady = false;
                this.dimensions = 384;
                this.loadTime = 0;
                this.metrics = {
                    totalEmbeddings: 0,
                    averageGenerationTime: 0,
                    errorCount: 0,
                    memoryUsage: 25 * 1024 * 1024 // 25MB mock
                };
            }

            async initialize() {
                log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MockTransformersProvider...');
                const startTime = Date.now();

                // –ò–º–∏—Ç–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏
                await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));

                this.loadTime = Date.now() - startTime;
                this.isReady = true;

                log(`–ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∑–∞ ${this.loadTime}ms`);
                return this;
            }

            async generateEmbedding(text) {
                if (!this.isReady) {
                    throw new Error('Provider not initialized');
                }

                const startTime = Date.now();

                // –ò–º–∏—Ç–∞—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —ç–º–±–µ–¥–¥–∏–Ω–≥–∞
                await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));

                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π 384-–º–µ—Ä–Ω—ã–π –≤–µ–∫—Ç–æ—Ä
                const embedding = new Float32Array(384);
                for (let i = 0; i < 384; i++) {
                    embedding[i] = (Math.random() - 0.5) * 2; // –æ—Ç -1 –¥–æ 1
                }

                // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤–µ–∫—Ç–æ—Ä
                let norm = 0;
                for (let i = 0; i < 384; i++) {
                    norm += embedding[i] * embedding[i];
                }
                norm = Math.sqrt(norm);
                for (let i = 0; i < 384; i++) {
                    embedding[i] /= norm;
                }

                const generationTime = Date.now() - startTime;
                this.updateMetrics(generationTime);

                return embedding;
            }

            async generateBatch(texts) {
                if (!this.isReady) {
                    throw new Error('Provider not initialized');
                }

                const results = [];
                for (const text of texts) {
                    results.push(await this.generateEmbedding(text));
                }
                return results;
            }

            async healthCheck() {
                return {
                    isHealthy: this.isReady,
                    status: this.isReady ? 'ready' : 'not_initialized',
                    details: this.isReady ? 'Provider is ready and operational' : 'Provider not initialized',
                    modelLoadTime: this.loadTime,
                    memoryUsage: this.metrics.memoryUsage,
                    totalInferences: this.metrics.totalEmbeddings
                };
            }

            updateMetrics(generationTime) {
                const totalTime = this.metrics.averageGenerationTime * this.metrics.totalEmbeddings;
                this.metrics.totalEmbeddings += 1;
                this.metrics.averageGenerationTime = (totalTime + generationTime) / this.metrics.totalEmbeddings;
            }

            getMetrics() {
                return { ...this.metrics };
            }

            async cleanup() {
                log('–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞...');
                this.isReady = false;
            }
        }

        // Event Listeners
        document.getElementById('initializeProvider').addEventListener('click', async function() {
            const button = this;
            button.dataset.originalText = button.textContent;
            setLoading('initializeProvider', true);

            try {
                updateStatus('initStatus', '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞...', 'info');
                log('–ù–∞—á–∏–Ω–∞–µ—Ç—Å—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TransformersProvider');

                provider = new MockTransformersProvider();
                await provider.initialize();

                updateStatus('initStatus', '–ü—Ä–æ–≤–∞–π–¥–µ—Ä —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω!', 'success');
                updateMetric('modelLoadTime', provider.loadTime);
                updateMetric('providerReady', '‚úÖ');
                updateMetric('memoryUsage', Math.round(provider.metrics.memoryUsage / (1024*1024)));

                isInitialized = true;
                log('TransformersProvider –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é');

            } catch (error) {
                updateStatus('initStatus', `–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ${error.message}`, 'error');
                log(`–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ${error.message}`, 'error');
            } finally {
                setLoading('initializeProvider', false);
            }
        });

        document.getElementById('generateSingle').addEventListener('click', async function() {
            if (!isInitialized) {
                updateStatus('singleStatus', '–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä', 'error');
                return;
            }

            const button = this;
            button.dataset.originalText = button.textContent;
            setLoading('generateSingle', true);

            try {
                const text = document.getElementById('singleText').value.trim();
                if (!text) {
                    throw new Error('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —ç–º–±–µ–¥–¥–∏–Ω–≥–∞');
                }

                updateStatus('singleStatus', '–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–∞...', 'info');
                log(`–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–∞ –¥–ª—è —Ç–µ–∫—Å—Ç–∞: "${text.substring(0, 50)}..."`);

                const startTime = Date.now();
                const embedding = await provider.generateEmbedding(text);
                const generationTime = Date.now() - startTime;

                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ—Ä–º—É –≤–µ–∫—Ç–æ—Ä–∞
                let norm = 0;
                for (let i = 0; i < embedding.length; i++) {
                    norm += embedding[i] * embedding[i];
                }
                norm = Math.sqrt(norm);

                updateStatus('singleStatus', '–≠–º–±–µ–¥–¥–∏–Ω–≥ —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω!', 'success');
                updateMetric('singleTime', generationTime);
                updateMetric('singleDimensions', embedding.length);
                updateMetric('singleNorm', norm.toFixed(4));

                showResult('singleResult', {
                    text: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
                    dimensions: embedding.length,
                    norm: norm,
                    generationTime: generationTime,
                    preview: Array.from(embedding.slice(0, 10)).map(x => x.toFixed(4))
                });

                log(`–≠–º–±–µ–¥–¥–∏–Ω–≥ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω: ${embedding.length}D, –Ω–æ—Ä–º–∞: ${norm.toFixed(4)}, –≤—Ä–µ–º—è: ${generationTime}ms`);

            } catch (error) {
                updateStatus('singleStatus', `–û—à–∏–±–∫–∞: ${error.message}`, 'error');
                log(`–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —ç–º–±–µ–¥–¥–∏–Ω–≥–∞: ${error.message}`, 'error');
            } finally {
                setLoading('generateSingle', false);
            }
        });

        document.getElementById('generateBatch').addEventListener('click', async function() {
            if (!isInitialized) {
                updateStatus('batchStatus', '–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä', 'error');
                return;
            }

            const button = this;
            button.dataset.originalText = button.textContent;
            setLoading('generateBatch', true);

            try {
                const textsInput = document.getElementById('batchTexts').value.trim();
                const texts = textsInput.split('\n').filter(t => t.trim()).map(t => t.trim());

                if (texts.length === 0) {
                    throw new Error('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç—ã –¥–ª—è –ø–∞–∫–µ—Ç–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏');
                }

                updateStatus('batchStatus', '–ü–∞–∫–µ—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤...', 'info');
                log(`–ù–∞—á–∏–Ω–∞–µ—Ç—Å—è –ø–∞–∫–µ—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–ª—è ${texts.length} —Ç–µ–∫—Å—Ç–æ–≤`);

                const startTime = Date.now();
                const embeddings = await provider.generateBatch(texts);
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / texts.length;

                updateStatus('batchStatus', '–ü–∞–∫–µ—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!', 'success');
                updateMetric('batchTime', totalTime);
                updateMetric('batchCount', embeddings.length);
                updateMetric('avgTimePerEmbedding', Math.round(avgTime));

                showResult('batchResult', {
                    textsCount: texts.length,
                    embeddingsCount: embeddings.length,
                    totalTime: totalTime,
                    averageTimePerEmbedding: avgTime,
                    examples: texts.slice(0, 3).map((text, i) => ({
                        text: text.substring(0, 50) + (text.length > 50 ? '...' : ''),
                        dimensions: embeddings[i].length,
                        preview: Array.from(embeddings[i].slice(0, 5)).map(x => x.toFixed(4))
                    }))
                });

                log(`–ü–∞–∫–µ—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞: ${embeddings.length} —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤ –∑–∞ ${totalTime}ms (${avgTime.toFixed(1)}ms/—ç–º–±–µ–¥–¥–∏–Ω–≥)`);

            } catch (error) {
                updateStatus('batchStatus', `–û—à–∏–±–∫–∞: ${error.message}`, 'error');
                log(`–û—à–∏–±–∫–∞ –ø–∞–∫–µ—Ç–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: ${error.message}`, 'error');
            } finally {
                setLoading('generateBatch', false);
            }
        });

        document.getElementById('runPerformanceTest').addEventListener('click', async function() {
            if (!isInitialized) {
                updateStatus('perfStatus', '–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä', 'error');
                return;
            }

            const button = this;
            button.dataset.originalText = button.textContent;
            setLoading('runPerformanceTest', true);

            try {
                const count = parseInt(document.getElementById('perfCount').value);
                if (count < 1 || count > 50) {
                    throw new Error('–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 50');
                }

                updateStatus('perfStatus', '–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏...', 'info');
                log(`–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –¥–ª—è ${count} —Ç–µ–∫—Å—Ç–æ–≤`);

                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã
                const texts = [];
                for (let i = 0; i < count; i++) {
                    texts.push(`Performance test sentence number ${i + 1}. This is a test to measure embedding generation speed.`);
                }

                const startTime = Date.now();
                const embeddings = await provider.generateBatch(texts);
                const totalTime = Date.now() - startTime;

                const avgTime = totalTime / count;
                const throughput = (count * 1000 / totalTime).toFixed(2);

                updateStatus('perfStatus', '–¢–µ—Å—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∑–∞–≤–µ—Ä—à–µ–Ω!', 'success');
                updateMetric('perfTotalTime', totalTime);
                updateMetric('perfAvgTime', Math.round(avgTime));
                updateMetric('perfThroughput', throughput);

                log(`–¢–µ—Å—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏: ${count} —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤ –∑–∞ ${totalTime}ms (${throughput} —Ç–µ–∫—Å—Ç–æ–≤/—Å–µ–∫)`);

            } catch (error) {
                updateStatus('perfStatus', `–û—à–∏–±–∫–∞: ${error.message}`, 'error');
                log(`–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏: ${error.message}`, 'error');
            } finally {
                setLoading('runPerformanceTest', false);
            }
        });

        document.getElementById('healthCheck').addEventListener('click', async function() {
            if (!provider) {
                updateStatus('healthStatus', '–ü—Ä–æ–≤–∞–π–¥–µ—Ä –Ω–µ —Å–æ–∑–¥–∞–Ω', 'error');
                return;
            }

            const button = this;
            button.dataset.originalText = button.textContent;
            setLoading('healthCheck', true);

            try {
                updateStatus('healthStatus', '–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞...', 'info');
                log('–ó–∞–ø—É—Å–∫ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞');

                const health = await provider.healthCheck();
                const metrics = provider.getMetrics();

                updateStatus('healthStatus', `–°—Ç–∞—Ç—É—Å: ${health.isHealthy ? '–ó–¥–æ—Ä–æ–≤' : '–ü—Ä–æ–±–ª–µ–º—ã'}`,
                    health.isHealthy ? 'success' : 'error');

                showResult('healthResult', {
                    health: health,
                    metrics: metrics,
                    timestamp: new Date().toISOString()
                });

                log(`–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞: ${health.isHealthy ? 'OK' : 'NOT OK'}`);

            } catch (error) {
                updateStatus('healthStatus', `–û—à–∏–±–∫–∞: ${error.message}`, 'error');
                log(`–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è: ${error.message}`, 'error');
            } finally {
                setLoading('healthCheck', false);
            }
        });

        document.getElementById('clearLog').addEventListener('click', function() {
            document.getElementById('debugLog').innerHTML = '';
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        document.addEventListener('DOMContentLoaded', function() {
            log('–°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞, –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è');
            checkEnvironment();

            // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–æ–∫
            document.querySelectorAll('button').forEach(button => {
                button.dataset.originalText = button.textContent;
            });
        });
    </script>
</body>
</html>