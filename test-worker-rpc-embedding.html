<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worker RPC Embedding Integration Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background-color: #fafafa;
        }
        .test-section h3 {
            margin-top: 0;
            color: #2c5282;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }

        .log {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .progress-text {
            text-align: center;
            margin: 5px 0;
            font-size: 14px;
            color: #555;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .metric-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c5282;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        input, select, textarea {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .config-form {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }
            .metrics {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ Worker RPC Embedding Integration Test</h1>
        <p><strong>Task 4.2:</strong> Worker RPC Integration - Testing collection-based embedding operations with progress reporting and non-blocking performance</p>

        <div class="test-section">
            <h3>üîß 1. Environment Setup</h3>
            <button onclick="setupEnvironment()">Setup Test Environment</button>
            <div id="setup-status"></div>
            <div id="setup-log" class="log" style="display: none;"></div>
        </div>

        <div class="test-section">
            <h3>üì¶ 2. Collection Configuration</h3>
            <div class="config-form">
                <label>Collection Name:</label>
                <input type="text" id="collection-name" value="test-embedding-collection" />

                <label>Provider Type:</label>
                <select id="provider-type" onchange="updateProviderConfig()">
                    <option value="transformers">Transformers.js (Local)</option>
                    <option value="openai">OpenAI API</option>
                </select>

                <div id="provider-config">
                    <!-- Dynamic provider configuration -->
                </div>

                <div class="form-row">
                    <div>
                        <label>Dimensions:</label>
                        <input type="number" id="dimensions" value="384" />
                    </div>
                    <div>
                        <label>Batch Size:</label>
                        <input type="number" id="batch-size" value="5" />
                    </div>
                </div>
            </div>
            <button onclick="createTestCollection()">Create Collection</button>
            <div id="collection-status"></div>
        </div>

        <div class="test-section">
            <h3>üìù 3. Single Embedding Generation</h3>
            <textarea id="test-text" rows="3" placeholder="Enter text to generate embedding for...">
This is a test document for embedding generation. It contains various types of content to test the embedding provider's capabilities.
            </textarea>
            <button onclick="generateSingleEmbedding()">Generate Single Embedding</button>
            <button onclick="testQueryEmbedding()">Test Query Embedding</button>
            <div id="single-status"></div>
            <div id="single-metrics" class="metrics"></div>
        </div>

        <div class="test-section">
            <h3>üìö 4. Batch Embedding Operations</h3>
            <button onclick="generateTestDocuments()">Generate Test Documents</button>
            <button onclick="batchGenerateEmbeddings()">Batch Generate Embeddings</button>
            <button onclick="regenerateCollectionEmbeddings()">Regenerate All Embeddings</button>

            <div class="progress-bar">
                <div id="batch-progress" class="progress-fill"></div>
            </div>
            <div id="batch-progress-text" class="progress-text"></div>

            <div id="batch-status"></div>
            <div id="batch-metrics" class="metrics"></div>
        </div>

        <div class="test-section">
            <h3>üîç 5. Semantic Search Testing</h3>
            <input type="text" id="search-query" placeholder="Enter search query..." value="test document content" />
            <button onclick="performSemanticSearch()">Perform Semantic Search</button>
            <div id="search-status"></div>
            <div id="search-results" class="log"></div>
        </div>

        <div class="test-section">
            <h3>üîÑ 6. Concurrent Operations Test</h3>
            <p>Tests non-blocking behavior by running SQL operations during embedding generation</p>
            <button onclick="testConcurrentOperations()">Test Concurrent Operations</button>
            <div id="concurrent-status"></div>
            <div id="concurrent-log" class="log"></div>
        </div>

        <div class="test-section">
            <h3>üìä 7. Performance Metrics</h3>
            <button onclick="getPerformanceMetrics()">Refresh Metrics</button>
            <div id="performance-metrics" class="metrics"></div>
        </div>
    </div>

    <script type="module">
        let database = null;
        let testDocuments = [];
        let embeddingProgress = {};

        // Status management
        function updateStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function logMessage(elementId, message) {
            const element = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            element.textContent += `[${timestamp}] ${message}\n`;
            element.scrollTop = element.scrollHeight;
            element.style.display = 'block';
        }

        function updateProgress(progress) {
            const progressBar = document.getElementById('batch-progress');
            const progressText = document.getElementById('batch-progress-text');

            const percentage = progress.totalCount > 0 ?
                Math.round((progress.processedCount / progress.totalCount) * 100) : 0;

            progressBar.style.width = `${percentage}%`;
            progressText.textContent = `${progress.phase}: ${progress.processedCount}/${progress.totalCount} (${percentage}%)`;

            if (progress.estimatedTimeRemaining) {
                progressText.textContent += ` - ETA: ${Math.round(progress.estimatedTimeRemaining / 1000)}s`;
            }

            if (progress.errorCount) {
                progressText.textContent += ` - Errors: ${progress.errorCount}`;
            }
        }

        function updateMetrics(elementId, metrics) {
            const element = document.getElementById(elementId);
            element.innerHTML = Object.entries(metrics).map(([key, value]) => `
                <div class="metric-card">
                    <div class="metric-value">${value}</div>
                    <div class="metric-label">${key.replace(/([A-Z])/g, ' $1').toLowerCase()}</div>
                </div>
            `).join('');
        }

        // Setup functions
        async function setupEnvironment() {
            updateStatus('setup-status', 'Setting up test environment...', 'info');
            logMessage('setup-log', 'Initializing LocalRetrieve database...');

            try {
                // Import LocalRetrieve
                const { Database } = await import('./dist/index.js');

                // Create database instance
                database = new Database();

                // Open with OPFS persistence
                await database.open('opfs:/localretrieve-embedding-test/worker-rpc-test.db');
                logMessage('setup-log', 'Database opened successfully');

                // Initialize vec extension
                await database.initVecExtension();
                logMessage('setup-log', 'Vector extension initialized');

                // Initialize schema
                await database.initializeSchema();
                logMessage('setup-log', 'Schema initialized');

                // Get version info
                const version = await database.getVersion();
                logMessage('setup-log', `Database versions: SQLite ${version.sqlite}, sqlite-vec ${version.vec}, SDK ${version.sdk}`);

                updateStatus('setup-status', 'Environment setup complete!', 'success');

                // Enable other test sections
                enableTestSections();

            } catch (error) {
                logMessage('setup-log', `Setup failed: ${error.message}`);
                updateStatus('setup-status', `Setup failed: ${error.message}`, 'error');
                console.error('Setup error:', error);
            }
        }

        function updateProviderConfig() {
            const providerType = document.getElementById('provider-type').value;
            const configDiv = document.getElementById('provider-config');
            const dimensionsInput = document.getElementById('dimensions');

            if (providerType === 'transformers') {
                configDiv.innerHTML = '<p class="info">Transformers.js runs locally in browser. No API key required.</p>';
                dimensionsInput.value = 384;
                dimensionsInput.disabled = true;
            } else if (providerType === 'openai') {
                configDiv.innerHTML = `
                    <label>OpenAI API Key:</label>
                    <input type="password" id="openai-api-key" placeholder="sk-..." />
                    <label>Model:</label>
                    <select id="openai-model">
                        <option value="text-embedding-3-small">text-embedding-3-small</option>
                        <option value="text-embedding-3-large">text-embedding-3-large</option>
                    </select>
                `;
                dimensionsInput.disabled = false;
                dimensionsInput.value = 1536;
            }
        }

        async function createTestCollection() {
            if (!database) {
                updateStatus('collection-status', 'Please setup environment first', 'error');
                return;
            }

            const collectionName = document.getElementById('collection-name').value;
            const providerType = document.getElementById('provider-type').value;
            const dimensions = parseInt(document.getElementById('dimensions').value);

            updateStatus('collection-status', 'Creating collection...', 'info');

            try {
                const embeddingConfig = {
                    provider: providerType,
                    dimensions: dimensions,
                    autoGenerate: true,
                    cacheEnabled: true
                };

                if (providerType === 'openai') {
                    const apiKey = document.getElementById('openai-api-key').value;
                    const model = document.getElementById('openai-model').value;

                    if (!apiKey) {
                        throw new Error('OpenAI API key is required');
                    }

                    embeddingConfig.apiKey = apiKey;
                    embeddingConfig.model = model;
                } else if (providerType === 'transformers') {
                    embeddingConfig.model = 'all-MiniLM-L6-v2';
                }

                await database.createCollection({
                    name: collectionName,
                    embeddingConfig: embeddingConfig,
                    description: `Test collection for Worker RPC embedding integration`
                });

                updateStatus('collection-status', `Collection '${collectionName}' created successfully!`, 'success');

            } catch (error) {
                updateStatus('collection-status', `Failed to create collection: ${error.message}`, 'error');
                console.error('Collection creation error:', error);
            }
        }

        // Embedding tests
        async function generateSingleEmbedding() {
            if (!database) {
                updateStatus('single-status', 'Please setup environment first', 'error');
                return;
            }

            const collectionName = document.getElementById('collection-name').value;
            const text = document.getElementById('test-text').value;

            updateStatus('single-status', 'Generating single embedding...', 'info');

            try {
                const startTime = Date.now();

                const result = await database.generateEmbedding({
                    collection: collectionName,
                    text: text
                });

                const endTime = Date.now();
                const duration = endTime - startTime;

                updateMetrics('single-metrics', {
                    'Generation Time': `${duration}ms`,
                    'Dimensions': result.dimensions,
                    'Provider': result.provider,
                    'Cached': result.cached ? 'Yes' : 'No'
                });

                updateStatus('single-status', `Single embedding generated successfully in ${duration}ms!`, 'success');

            } catch (error) {
                updateStatus('single-status', `Failed to generate embedding: ${error.message}`, 'error');
                console.error('Single embedding error:', error);
            }
        }

        async function testQueryEmbedding() {
            if (!database) {
                updateStatus('single-status', 'Please setup environment first', 'error');
                return;
            }

            const collectionName = document.getElementById('collection-name').value;
            const query = document.getElementById('search-query').value;

            updateStatus('single-status', 'Generating query embedding...', 'info');

            try {
                const startTime = Date.now();

                const result = await database.generateEmbedding({
                    collection: collectionName,
                    text: query
                });

                const endTime = Date.now();
                const duration = endTime - startTime;

                updateStatus('single-status', `Query embedding generated in ${duration}ms (${result.dimensions}D)`, 'success');

            } catch (error) {
                updateStatus('single-status', `Failed to generate query embedding: ${error.message}`, 'error');
                console.error('Query embedding error:', error);
            }
        }

        function generateTestDocuments() {
            const sampleTexts = [
                "Artificial intelligence is transforming the way we work and live.",
                "Machine learning algorithms can process vast amounts of data quickly.",
                "Natural language processing enables computers to understand human language.",
                "Deep learning neural networks mimic the structure of the human brain.",
                "Computer vision allows machines to interpret and understand visual information.",
                "Robotics combines AI with mechanical engineering to create intelligent machines.",
                "Data science involves extracting insights from large datasets.",
                "Cloud computing provides scalable and flexible IT infrastructure.",
                "Cybersecurity protects digital systems from threats and attacks.",
                "Blockchain technology ensures secure and transparent transactions."
            ];

            testDocuments = sampleTexts.map((text, index) => ({
                id: `test-doc-${index + 1}`,
                content: text,
                metadata: {
                    category: index < 5 ? 'AI/ML' : 'Technology',
                    length: text.length,
                    generated: true
                }
            }));

            updateStatus('batch-status', `Generated ${testDocuments.length} test documents`, 'success');
        }

        async function batchGenerateEmbeddings() {
            if (!database || testDocuments.length === 0) {
                updateStatus('batch-status', 'Please setup environment and generate test documents first', 'error');
                return;
            }

            const collectionName = document.getElementById('collection-name').value;
            const batchSize = parseInt(document.getElementById('batch-size').value);

            updateStatus('batch-status', 'Starting batch embedding generation...', 'info');

            try {
                const startTime = Date.now();

                // Listen for progress events
                const worker = database.worker;
                const originalOnMessage = worker.onmessage;

                worker.onmessage = (event) => {
                    if (event.data.type === 'embedding_progress') {
                        updateProgress(event.data.data);
                    }
                    originalOnMessage.call(worker, event);
                };

                const result = await database.batchGenerateEmbeddings({
                    collection: collectionName,
                    documents: testDocuments,
                    options: { batchSize: batchSize }
                });

                const endTime = Date.now();
                const duration = endTime - startTime;

                // Restore original message handler
                worker.onmessage = originalOnMessage;

                updateMetrics('batch-metrics', {
                    'Total Time': `${duration}ms`,
                    'Success Count': result.success,
                    'Failed Count': result.failed,
                    'Avg per Document': `${Math.round(duration / testDocuments.length)}ms`,
                    'Throughput': `${Math.round(testDocuments.length / (duration / 1000))} docs/sec`
                });

                if (result.errors.length > 0) {
                    updateStatus('batch-status', `Batch completed with ${result.errors.length} errors`, 'warning');
                } else {
                    updateStatus('batch-status', `Batch embedding completed successfully!`, 'success');
                }

            } catch (error) {
                updateStatus('batch-status', `Batch embedding failed: ${error.message}`, 'error');
                console.error('Batch embedding error:', error);
            }
        }

        async function regenerateCollectionEmbeddings() {
            if (!database) {
                updateStatus('batch-status', 'Please setup environment first', 'error');
                return;
            }

            const collectionName = document.getElementById('collection-name').value;
            const batchSize = parseInt(document.getElementById('batch-size').value);

            updateStatus('batch-status', 'Regenerating all collection embeddings...', 'info');

            try {
                const startTime = Date.now();

                const result = await database.regenerateCollectionEmbeddings(collectionName, {
                    batchSize: batchSize
                });

                const endTime = Date.now();
                const duration = endTime - startTime;

                updateMetrics('batch-metrics', {
                    'Regeneration Time': `${duration}ms`,
                    'Success Count': result.success,
                    'Failed Count': result.failed
                });

                updateStatus('batch-status', `Collection embeddings regenerated successfully!`, 'success');

            } catch (error) {
                updateStatus('batch-status', `Collection regeneration failed: ${error.message}`, 'error');
                console.error('Collection regeneration error:', error);
            }
        }

        // Search tests
        async function performSemanticSearch() {
            if (!database) {
                updateStatus('search-status', 'Please setup environment first', 'error');
                return;
            }

            const collectionName = document.getElementById('collection-name').value;
            const query = document.getElementById('search-query').value;

            updateStatus('search-status', 'Performing semantic search...', 'info');

            try {
                const startTime = Date.now();

                const result = await database.searchSemantic({
                    collection: collectionName,
                    query: query,
                    options: {
                        limit: 5,
                        generateQueryEmbedding: true,
                        includeEmbeddings: false
                    }
                });

                const endTime = Date.now();
                const duration = endTime - startTime;

                const resultsText = result.results.map(r =>
                    `Score: ${r.score.toFixed(3)} | ${r.content.substring(0, 100)}...`
                ).join('\n');

                document.getElementById('search-results').textContent =
                    `Search completed in ${duration}ms (${result.totalResults} results):\n\n${resultsText}`;

                updateStatus('search-status', `Semantic search completed in ${duration}ms`, 'success');

            } catch (error) {
                updateStatus('search-status', `Semantic search failed: ${error.message}`, 'error');
                console.error('Semantic search error:', error);
            }
        }

        // Concurrent operations test
        async function testConcurrentOperations() {
            if (!database) {
                updateStatus('concurrent-status', 'Please setup environment first', 'error');
                return;
            }

            updateStatus('concurrent-status', 'Testing concurrent operations...', 'info');
            logMessage('concurrent-log', 'Starting concurrent operations test...');

            try {
                const collectionName = document.getElementById('collection-name').value;

                // Start a long-running embedding operation
                const embeddingPromise = database.generateEmbedding({
                    collection: collectionName,
                    text: "This is a long text for embedding generation that should not block database operations. ".repeat(10)
                });

                logMessage('concurrent-log', 'Started embedding generation...');

                // Perform database operations while embedding is running
                const sqlPromises = [];
                for (let i = 0; i < 5; i++) {
                    sqlPromises.push(
                        database.select("SELECT 'concurrent_test_' || ? as test_value", [i]).then(result => {
                            logMessage('concurrent-log', `SQL operation ${i} completed: ${result.rows[0].test_value}`);
                            return result;
                        })
                    );
                }

                // Wait for both embedding and SQL operations
                const [embeddingResult, ...sqlResults] = await Promise.all([embeddingPromise, ...sqlPromises]);

                logMessage('concurrent-log', `Embedding completed: ${embeddingResult.dimensions}D vector`);
                logMessage('concurrent-log', `All ${sqlResults.length} SQL operations completed successfully`);

                updateStatus('concurrent-status', 'Concurrent operations test passed! SQL operations were not blocked by embedding generation.', 'success');

            } catch (error) {
                logMessage('concurrent-log', `Concurrent operations test failed: ${error.message}`);
                updateStatus('concurrent-status', `Concurrent operations test failed: ${error.message}`, 'error');
                console.error('Concurrent operations error:', error);
            }
        }

        // Performance metrics
        async function getPerformanceMetrics() {
            if (!database) {
                updateStatus('performance-metrics', 'Please setup environment first', 'error');
                return;
            }

            try {
                const rpcMetrics = database.getPerformanceMetrics();
                const dbStats = await database.getStats();

                updateMetrics('performance-metrics', {
                    'Total RPC Calls': rpcMetrics.totalCalls,
                    'Average Latency': `${Math.round(rpcMetrics.averageLatency)}ms`,
                    'Success Rate': `${Math.round(rpcMetrics.successRate * 100)}%`,
                    'Pending Operations': rpcMetrics.pendingOperations,
                    'Database Size': `${Math.round(dbStats.dbSize / 1024)}KB`,
                    'Operations Count': dbStats.operations
                });

            } catch (error) {
                console.error('Performance metrics error:', error);
            }
        }

        function enableTestSections() {
            const buttons = document.querySelectorAll('button:not([onclick="setupEnvironment()"])');
            buttons.forEach(button => button.disabled = false);
        }

        // Initialize provider config
        updateProviderConfig();

        // Disable test sections initially
        const buttons = document.querySelectorAll('button:not([onclick="setupEnvironment()"])');
        buttons.forEach(button => button.disabled = true);

        // Make functions global for onclick handlers
        window.setupEnvironment = setupEnvironment;
        window.updateProviderConfig = updateProviderConfig;
        window.createTestCollection = createTestCollection;
        window.generateSingleEmbedding = generateSingleEmbedding;
        window.testQueryEmbedding = testQueryEmbedding;
        window.generateTestDocuments = generateTestDocuments;
        window.batchGenerateEmbeddings = batchGenerateEmbeddings;
        window.regenerateCollectionEmbeddings = regenerateCollectionEmbeddings;
        window.performSemanticSearch = performSemanticSearch;
        window.testConcurrentOperations = testConcurrentOperations;
        window.getPerformanceMetrics = getPerformanceMetrics;

    </script>
</body>
</html>