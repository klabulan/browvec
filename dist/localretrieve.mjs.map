{"version":3,"file":"localretrieve.mjs","sources":["../src/types/sql.ts","../src/database/Statement.ts","../src/types/database.ts","../src/database/Database.ts","../src/embedding/TextProcessor.ts","../src/embedding/utils.ts","../src/embedding/cache/MemoryCache.ts","../src/embedding/index.ts","../src/pipeline/InternalPipeline.ts","../src/pipeline/ModelManager.ts","../src/cache/QueryCache.ts","../src/cache/ModelCache.ts","../src/cache/CacheManager.ts","../src/index.ts"],"sourcesContent":["/**\r\n * Complete sql.js Type Definitions for LocalRetrieve\r\n * \r\n * This file provides complete sql.js API compatibility types while working\r\n * with the LocalRetrieve Worker infrastructure. It includes both synchronous\r\n * and asynchronous API variants.\r\n */\r\n\r\nexport type SQLValue = number | string | Uint8Array | null;\r\nexport type SQLParams = SQLValue[] | { [key: string]: SQLValue };\r\n\r\n// sql.js QueryExecResult interface\r\nexport interface QueryExecResult {\r\n  columns: string[];\r\n  values: SQLValue[][];\r\n}\r\n\r\n// sql.js Statement execution result\r\nexport interface StatementExecResult {\r\n  columns: string[];\r\n  values: SQLValue[][];\r\n}\r\n\r\n// sql.js Database interface (complete compatibility)\r\nexport interface SQLDatabase {\r\n  // Core sql.js synchronous methods\r\n  exec(sql: string): QueryExecResult[];\r\n  run(sql: string, params?: SQLParams): SQLDatabase;\r\n  prepare(sql: string): SQLStatement;\r\n  export(): Uint8Array;\r\n  close(): void;\r\n  \r\n  // sql.js utility methods\r\n  getRowsModified(): number;\r\n  savepoint(name?: string): void;\r\n  savepoint_release(name?: string): void;\r\n  savepoint_rollback(name?: string): void;\r\n  \r\n  // sql.js function registration (stubs for compatibility)\r\n  create_function(name: string, func: (...args: any[]) => any): void;\r\n  create_aggregate(name: string, funcs: { step: Function; finalize: Function }): void;\r\n  \r\n  // LocalRetrieve async extensions (enhanced API)\r\n  execAsync?(sql: string): Promise<QueryExecResult[]>;\r\n  runAsync?(sql: string, params?: SQLParams): Promise<SQLDatabase>;\r\n  prepareAsync?(sql: string): Promise<SQLStatement>;\r\n  exportAsync?(): Promise<Uint8Array>;\r\n  closeAsync?(): Promise<void>;\r\n  \r\n  // LocalRetrieve specific extensions\r\n  search?(request: any): Promise<any>;\r\n  initializeSchema?(): Promise<void>;\r\n}\r\n\r\n// sql.js Statement interface (complete compatibility)\r\nexport interface SQLStatement {\r\n  // Core sql.js synchronous methods\r\n  bind(params?: SQLParams): boolean;\r\n  step(): boolean;\r\n  get(): SQLValue[];\r\n  getAsObject(): { [column: string]: SQLValue };\r\n  getColumnNames(): string[];\r\n  reset(): boolean;\r\n  free(): boolean;\r\n  \r\n  // sql.js statement properties\r\n  readonly sql: string;\r\n  readonly finalized: boolean;\r\n  \r\n  // LocalRetrieve async extensions\r\n  bindAsync?(params?: SQLParams): Promise<boolean>;\r\n  stepAsync?(): Promise<boolean>;\r\n  getAsync?(): Promise<SQLValue[]>;\r\n  getAsObjectAsync?(): Promise<{ [column: string]: SQLValue }>;\r\n  resetAsync?(): Promise<boolean>;\r\n  freeAsync?(): Promise<boolean>;\r\n}\r\n\r\n// sql.js Database creation options\r\nexport interface SQLDatabaseConfig {\r\n  filename?: string;\r\n  readOnly?: boolean;\r\n  locateFile?: (filename: string) => string;\r\n}\r\n\r\n// sql.js Module interface (for static methods)\r\nexport interface SQLModule {\r\n  Database: {\r\n    new(data?: Uint8Array, params?: SQLDatabaseConfig): SQLDatabase;\r\n    call(thisArg: any, data?: Uint8Array, params?: SQLDatabaseConfig): SQLDatabase;\r\n  };\r\n  Statement: {\r\n    new(database: SQLDatabase, sql: string): SQLStatement;\r\n  };\r\n}\r\n\r\n// Enhanced error types for sql.js compatibility\r\nexport class SQLError extends Error {\r\n  constructor(message: string, public code?: number) {\r\n    super(message);\r\n    this.name = 'SQLError';\r\n  }\r\n}\r\n\r\nexport class SQLStatementError extends Error {\r\n  constructor(message: string, public code?: number) {\r\n    super(message);\r\n    this.name = 'SQLStatementError';\r\n  }\r\n}\r\n\r\nexport class SQLDatabaseError extends Error {\r\n  constructor(message: string, public code?: number) {\r\n    super(message);\r\n    this.name = 'SQLDatabaseError';\r\n  }\r\n}\r\n\r\nexport class SQLSyntaxError extends SQLError {\r\n  constructor(message: string, public sqlText?: string, public position?: number) {\r\n    super(`SQL Syntax Error: ${message}`);\r\n    this.name = 'SQLSyntaxError';\r\n    this.code = 1; // SQLITE_ERROR\r\n  }\r\n}\r\n\r\nexport class SQLConstraintError extends SQLError {\r\n  constructor(message: string, public constraintType?: string) {\r\n    super(`Constraint Error: ${message}`);\r\n    this.name = 'SQLConstraintError';\r\n    this.code = 19; // SQLITE_CONSTRAINT\r\n  }\r\n}\r\n\r\nexport class SQLNotFoundError extends SQLError {\r\n  constructor(message: string, public objectName?: string) {\r\n    super(`Not Found: ${message}`);\r\n    this.name = 'SQLNotFoundError';\r\n    this.code = 0; // No specific SQLite code\r\n  }\r\n}\r\n\r\nexport class SQLBusyError extends SQLError {\r\n  constructor(message: string = 'Database is locked') {\r\n    super(message);\r\n    this.name = 'SQLBusyError';\r\n    this.code = 5; // SQLITE_BUSY\r\n  }\r\n}\r\n\r\nexport class SQLTimeoutError extends SQLError {\r\n  constructor(message: string = 'Operation timed out') {\r\n    super(message);\r\n    this.name = 'SQLTimeoutError';\r\n    this.code = -1; // Custom timeout code\r\n  }\r\n}\r\n\r\nexport class SQLCompatibilityError extends SQLError {\r\n  constructor(message: string, public compatibilityLevel?: string) {\r\n    super(`Compatibility Issue: ${message}`);\r\n    this.name = 'SQLCompatibilityError';\r\n    this.code = -2; // Custom compatibility code\r\n  }\r\n}\r\n\r\n// Error code mapping for sql.js compatibility\r\nexport const SQL_ERROR_CODES = {\r\n  SQLITE_OK: 0,\r\n  SQLITE_ERROR: 1,\r\n  SQLITE_INTERNAL: 2,\r\n  SQLITE_PERM: 3,\r\n  SQLITE_ABORT: 4,\r\n  SQLITE_BUSY: 5,\r\n  SQLITE_LOCKED: 6,\r\n  SQLITE_NOMEM: 7,\r\n  SQLITE_READONLY: 8,\r\n  SQLITE_INTERRUPT: 9,\r\n  SQLITE_IOERR: 10,\r\n  SQLITE_CORRUPT: 11,\r\n  SQLITE_NOTFOUND: 12,\r\n  SQLITE_FULL: 13,\r\n  SQLITE_CANTOPEN: 14,\r\n  SQLITE_PROTOCOL: 15,\r\n  SQLITE_EMPTY: 16,\r\n  SQLITE_SCHEMA: 17,\r\n  SQLITE_TOOBIG: 18,\r\n  SQLITE_CONSTRAINT: 19,\r\n  SQLITE_MISMATCH: 20,\r\n  SQLITE_MISUSE: 21,\r\n  SQLITE_NOLFS: 22,\r\n  SQLITE_AUTH: 23,\r\n  SQLITE_FORMAT: 24,\r\n  SQLITE_RANGE: 25,\r\n  SQLITE_NOTADB: 26,\r\n  SQLITE_NOTICE: 27,\r\n  SQLITE_WARNING: 28,\r\n  SQLITE_ROW: 100,\r\n  SQLITE_DONE: 101,\r\n} as const;\r\n\r\n// Error handling utilities\r\nexport function mapSQLiteError(code: number, message: string): SQLError {\r\n  switch (code) {\r\n    case SQL_ERROR_CODES.SQLITE_ERROR:\r\n      return new SQLSyntaxError(message);\r\n    case SQL_ERROR_CODES.SQLITE_CONSTRAINT:\r\n      return new SQLConstraintError(message);\r\n    case SQL_ERROR_CODES.SQLITE_BUSY:\r\n    case SQL_ERROR_CODES.SQLITE_LOCKED:\r\n      return new SQLBusyError(message);\r\n    case SQL_ERROR_CODES.SQLITE_NOTFOUND:\r\n      return new SQLNotFoundError(message);\r\n    default:\r\n      return new SQLError(message, code);\r\n  }\r\n}\r\n\r\nexport function createCompatibilityError(operation: string, reason: string): SQLCompatibilityError {\r\n  return new SQLCompatibilityError(\r\n    `Operation '${operation}' has limitations: ${reason}\\n` +\r\n    'Consider using async API for full functionality.'\r\n  );\r\n}\r\n\r\n// sql.js compatibility utility functions\r\nexport function isSQLValue(value: any): value is SQLValue {\r\n  return value === null || \r\n    typeof value === 'number' || \r\n    typeof value === 'string' || \r\n    value instanceof Uint8Array;\r\n}\r\n\r\nexport function isSQLParams(params: any): params is SQLParams {\r\n  if (!params) return true;\r\n  \r\n  if (Array.isArray(params)) {\r\n    return params.every(isSQLValue);\r\n  }\r\n  \r\n  if (typeof params === 'object' && params !== null) {\r\n    return Object.values(params).every(isSQLValue);\r\n  }\r\n  \r\n  return false;\r\n}\r\n\r\nexport function validateSQL(sql: any): sql is string {\r\n  return typeof sql === 'string' && sql.trim().length > 0;\r\n}\r\n\r\n// sql.js result transformation utilities\r\nexport function transformToSQLResult(rows: any[]): QueryExecResult {\r\n  if (!rows || rows.length === 0) {\r\n    return { columns: [], values: [] };\r\n  }\r\n  \r\n  const firstRow = rows[0];\r\n  const columns = Object.keys(firstRow);\r\n  const values = rows.map(row => columns.map(col => row[col] ?? null));\r\n  \r\n  return { columns, values };\r\n}\r\n\r\nexport function transformFromSQLParams(params?: SQLParams): { [key: string]: SQLValue } | SQLValue[] | undefined {\r\n  if (!params) return undefined;\r\n  if (Array.isArray(params)) return params;\r\n  return params;\r\n}\r\n\r\n// Compatibility constants\r\nexport const SQL_OPEN_READONLY = 0x00000001;\r\nexport const SQL_OPEN_READWRITE = 0x00000002;\r\nexport const SQL_OPEN_CREATE = 0x00000004;\r\nexport const SQL_OPEN_DELETEONCLOSE = 0x00000008;\r\nexport const SQL_OPEN_EXCLUSIVE = 0x00000010;\r\nexport const SQL_OPEN_AUTOPROXY = 0x00000020;\r\nexport const SQL_OPEN_URI = 0x00000040;\r\nexport const SQL_OPEN_MEMORY = 0x00000080;\r\n\r\n// sql.js Database factory interface for compatibility\r\nexport interface SQLDatabaseConstructor {\r\n  new(data?: Uint8Array, params?: SQLDatabaseConfig): SQLDatabase;\r\n  (data?: Uint8Array, params?: SQLDatabaseConfig): SQLDatabase;\r\n}\r\n\r\n// Re-export for module compatibility\r\nexport { SQLDatabase as Database, SQLStatement as Statement };\r\n\r\n// Version information\r\nexport const SQL_VERSION = '1.8.0'; // sql.js compatibility version\r\nexport const LOCALRETRIEVE_VERSION = '1.0.0';\r\nexport const SQLITE_VERSION = '3.47.0';\r\n\r\n// Feature flags for compatibility checking\r\nexport const FEATURES = {\r\n  FTS5: true,\r\n  JSON1: true,\r\n  RTREE: true,\r\n  VECTOR: true, // LocalRetrieve extension\r\n  OPFS: true,   // LocalRetrieve extension\r\n  ASYNC_API: true, // LocalRetrieve extension\r\n} as const;\r\n\r\nexport type FeatureFlag = keyof typeof FEATURES;\r\n\r\n// Compatibility mode enumeration\r\nexport enum CompatibilityMode {\r\n  STRICT_SYNC = 'strict_sync',     // Strict sql.js synchronous compatibility (limited)\r\n  ASYNC_PREFERRED = 'async_preferred', // Prefer async APIs, fallback to sync\r\n  ASYNC_ONLY = 'async_only'        // Only async APIs available\r\n}\r\n\r\n// Configuration for sql.js compatibility layer\r\nexport interface SQLCompatConfig {\r\n  mode: CompatibilityMode;\r\n  enableWarnings: boolean;\r\n  throwOnSyncLimitations: boolean;\r\n  workerTimeout: number;\r\n}\r\n\r\nexport const DEFAULT_SQL_COMPAT_CONFIG: SQLCompatConfig = {\r\n  mode: CompatibilityMode.ASYNC_PREFERRED,\r\n  enableWarnings: true,\r\n  throwOnSyncLimitations: false,\r\n  workerTimeout: 30000\r\n};","/**\r\n * Statement Class - Complete sql.js Compatible Statement Wrapper\r\n * \r\n * Provides a complete sql.js compatible Statement interface that works with\r\n * the LocalRetrieve Worker infrastructure for prepared statements.\r\n */\r\n\r\nimport type { \r\n  StatementAPI, \r\n  StatementState, \r\n  DatabaseAPI, \r\n  SQLValue, \r\n  SQLParams \r\n} from '../types/database.js';\r\nimport { StatementError, validateSQLParams } from '../types/database.js';\r\nimport {\r\n  SQLStatement,\r\n  SQLStatementError,\r\n  isSQLParams,\r\n  validateSQL as validateSQLQuery\r\n} from '../types/sql.js';\r\n\r\nexport class Statement implements SQLStatement {\r\n  private state: StatementState;\r\n  private _boundParams?: SQLParams;\r\n  private _finalized = false;\r\n  private _results: Record<string, SQLValue>[] = [];\r\n  private _currentIndex = -1;\r\n  private _executed = false;\r\n  private _sql: string;\r\n\r\n  constructor(database: DatabaseAPI, sql: string) {\r\n    this._sql = sql.trim();\r\n    \r\n    this.state = {\r\n      sql: this._sql,\r\n      bound: false,\r\n      stepped: false,\r\n      finished: false,\r\n      currentRow: null,\r\n      columns: [],\r\n      database\r\n    };\r\n\r\n    if (!this.state.sql) {\r\n      throw new SQLStatementError('SQL statement cannot be empty');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the SQL statement (sql.js compatible)\r\n   */\r\n  get sql(): string {\r\n    return this._sql;\r\n  }\r\n\r\n  /**\r\n   * Check if statement is finalized (sql.js compatible)\r\n   */\r\n  get finalized(): boolean {\r\n    return this._finalized;\r\n  }\r\n\r\n  /**\r\n   * Bind parameters to the prepared statement (sql.js compatible)\r\n   */\r\n  bind(params?: SQLParams): boolean {\r\n    if (this._finalized) {\r\n      throw new SQLStatementError('Cannot bind to finalized statement');\r\n    }\r\n\r\n    if (params !== undefined && !isSQLParams(params)) {\r\n      throw new SQLStatementError('Invalid parameter types');\r\n    }\r\n\r\n    this.state.bound = true;\r\n    this.reset(); // Reset any previous execution state\r\n    \r\n    // Store bound parameters for execution\r\n    this._boundParams = params;\r\n\r\n    return true; // sql.js returns boolean\r\n  }\r\n\r\n  /**\r\n   * Execute one step of the statement (sql.js compatible)\r\n   */\r\n  step(): boolean {\r\n    if (this._finalized) {\r\n      throw new SQLStatementError('Cannot step finalized statement');\r\n    }\r\n\r\n    if (this.state.finished) {\r\n      return false;\r\n    }\r\n\r\n    if (!this._executed) {\r\n      // First step - execute the query using worker\r\n      this._executeQuery();\r\n      this._executed = true;\r\n      this.state.stepped = true;\r\n    }\r\n\r\n    // Move to next row\r\n    this._currentIndex++;\r\n    \r\n    if (this._currentIndex < this._results.length) {\r\n      this.state.currentRow = this._results[this._currentIndex];\r\n      \r\n      // Extract columns from first row if not set\r\n      if (this.state.columns.length === 0 && this.state.currentRow) {\r\n        this.state.columns = Object.keys(this.state.currentRow);\r\n      }\r\n      \r\n      return true;\r\n    }\r\n\r\n    this.state.finished = true;\r\n    this.state.currentRow = null;\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get current row as array of values (sql.js compatible)\r\n   */\r\n  get(): SQLValue[] {\r\n    if (!this.state.currentRow) {\r\n      return [];\r\n    }\r\n\r\n    return this.state.columns.map(col => this.state.currentRow![col] ?? null);\r\n  }\r\n\r\n  /**\r\n   * Get current row as object (sql.js compatible)\r\n   */\r\n  getAsObject(): { [column: string]: SQLValue } {\r\n    if (!this.state.currentRow) {\r\n      return {};\r\n    }\r\n\r\n    return { ...this.state.currentRow };\r\n  }\r\n\r\n  /**\r\n   * Get column names (sql.js compatible)\r\n   */\r\n  getColumnNames(): string[] {\r\n    return [...this.state.columns];\r\n  }\r\n\r\n  /**\r\n   * Reset statement for re-execution (sql.js compatible)\r\n   */\r\n  reset(): boolean {\r\n    if (this._finalized) {\r\n      throw new SQLStatementError('Cannot reset finalized statement');\r\n    }\r\n\r\n    this.state.stepped = false;\r\n    this.state.finished = false;\r\n    this.state.currentRow = null;\r\n    this._currentIndex = -1;\r\n    this._executed = false;\r\n    this._results = [];\r\n\r\n    return true; // sql.js returns boolean\r\n  }\r\n\r\n  /**\r\n   * Free/finalize the statement (sql.js compatible)\r\n   */\r\n  free(): boolean {\r\n    if (this._finalized) {\r\n      return true; // Already finalized\r\n    }\r\n\r\n    this._finalized = true;\r\n    this.state.finished = true;\r\n    this.state.currentRow = null;\r\n    this._results = [];\r\n    this._boundParams = undefined;\r\n\r\n    // Remove from database's active statements if possible\r\n    try {\r\n      const database = this.state.database as any;\r\n      if (database.activeStatements && database.activeStatements.has(this)) {\r\n        database.activeStatements.delete(this);\r\n      }\r\n    } catch (error) {\r\n      // Ignore errors during cleanup\r\n    }\r\n\r\n    return true; // sql.js returns boolean\r\n  }\r\n\r\n  /**\r\n   * Async versions for enhanced API compatibility\r\n   */\r\n  async bindAsync(params?: SQLParams): Promise<boolean> {\r\n    return this.bind(params);\r\n  }\r\n\r\n  async stepAsync(): Promise<boolean> {\r\n    if (this._finalized) {\r\n      throw new SQLStatementError('Cannot step finalized statement');\r\n    }\r\n\r\n    if (this.state.finished) {\r\n      return false;\r\n    }\r\n\r\n    if (!this._executed) {\r\n      // First step - execute the query using worker async\r\n      await this._executeQueryAsync();\r\n      this._executed = true;\r\n      this.state.stepped = true;\r\n    }\r\n\r\n    // Move to next row\r\n    this._currentIndex++;\r\n    \r\n    if (this._currentIndex < this._results.length) {\r\n      this.state.currentRow = this._results[this._currentIndex];\r\n      \r\n      // Extract columns from first row if not set\r\n      if (this.state.columns.length === 0 && this.state.currentRow) {\r\n        this.state.columns = Object.keys(this.state.currentRow);\r\n      }\r\n      \r\n      return true;\r\n    }\r\n\r\n    this.state.finished = true;\r\n    this.state.currentRow = null;\r\n    return false;\r\n  }\r\n\r\n  async getAsync(): Promise<SQLValue[]> {\r\n    return this.get();\r\n  }\r\n\r\n  async getAsObjectAsync(): Promise<{ [column: string]: SQLValue }> {\r\n    return this.getAsObject();\r\n  }\r\n\r\n  async resetAsync(): Promise<boolean> {\r\n    return this.reset();\r\n  }\r\n\r\n  async freeAsync(): Promise<boolean> {\r\n    return this.free();\r\n  }\r\n\r\n  /**\r\n   * Get the SQL statement (for compatibility)\r\n   */\r\n  getSQL(): string {\r\n    return this._sql;\r\n  }\r\n\r\n  /**\r\n   * Get bound parameters (for debugging)\r\n   */\r\n  getBoundParams(): SQLParams | undefined {\r\n    return this._boundParams;\r\n  }\r\n\r\n  /**\r\n   * Execute the SQL query using the database's worker interface (synchronous)\r\n   */\r\n  private _executeQuery(): void {\r\n    try {\r\n      // Get access to the database's worker RPC\r\n      const database = this.state.database as any;\r\n      const workerRPC = database._getWorkerRPC?.();\r\n      \r\n      if (!workerRPC) {\r\n        throw new SQLStatementError('Database worker not available');\r\n      }\r\n\r\n      // Execute query synchronously using a blocking async call\r\n      // This is a compromise to maintain sql.js sync API\r\n      this._executeWithWorkerSync(workerRPC);\r\n      \r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLStatementError(`Query execution failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute the SQL query using the database's worker interface (asynchronous)\r\n   */\r\n  private async _executeQueryAsync(): Promise<void> {\r\n    try {\r\n      // Get access to the database's worker RPC\r\n      const database = this.state.database as any;\r\n      const workerRPC = database._getWorkerRPC?.();\r\n      \r\n      if (!workerRPC) {\r\n        throw new SQLStatementError('Database worker not available');\r\n      }\r\n\r\n      // Execute query asynchronously\r\n      const result = await workerRPC.select({\r\n        sql: this.state.sql,\r\n        params: this._boundParams\r\n      });\r\n\r\n      // Store results\r\n      this._results = result?.rows || [];\r\n      \r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLStatementError(`Query execution failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute query with worker RPC (synchronous compatibility)\r\n   * Uses synchronous blocking for sql.js compatibility\r\n   */\r\n  private _executeWithWorkerSync(workerRPC: any): void {\r\n    // Create a promise for the worker call\r\n    const executePromise = workerRPC.select({\r\n      sql: this.state.sql,\r\n      params: this._boundParams\r\n    });\r\n\r\n    // Block synchronously (this is not ideal but needed for sql.js compatibility)\r\n    let isResolved = false;\r\n    let result: any = null;\r\n    let error: any = null;\r\n\r\n    executePromise\r\n      .then((res: any) => {\r\n        result = res;\r\n        isResolved = true;\r\n      })\r\n      .catch((err: any) => {\r\n        error = err;\r\n        isResolved = true;\r\n      });\r\n\r\n    // Busy wait for result (not ideal, but necessary for sync API)\r\n    const startTime = Date.now();\r\n    const timeout = 30000; // 30 second timeout\r\n\r\n    while (!isResolved && (Date.now() - startTime) < timeout) {\r\n      // Allow event loop to process with minimal busy wait\r\n    }\r\n\r\n    if (!isResolved) {\r\n      throw new SQLStatementError(\r\n        'SYNC/ASYNC COMPATIBILITY ISSUE:\\n' +\r\n        'Query execution timeout in sync compatibility mode.\\n' +\r\n        'SOLUTIONS:\\n' +\r\n        '1. Use async API: await statement.stepAsync() instead of statement.step()\\n' +\r\n        '2. Increase timeout in database configuration\\n' +\r\n        '3. Consider using sql.js directly on main thread for true sync operations\\n' +\r\n        '\\nThis is a known limitation of browser worker architecture.'\r\n      );\r\n    }\r\n\r\n    if (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLStatementError(`Query execution failed: ${message}`);\r\n    }\r\n\r\n    // Store results\r\n    this._results = result?.rows || [];\r\n  }\r\n\r\n  /**\r\n   * Get execution statistics (debugging helper)\r\n   */\r\n  getStats(): {\r\n    sql: string;\r\n    bound: boolean;\r\n    executed: boolean;\r\n    resultCount: number;\r\n    currentIndex: number;\r\n    finalized: boolean;\r\n  } {\r\n    return {\r\n      sql: this._sql,\r\n      bound: this.state.bound,\r\n      executed: this._executed,\r\n      resultCount: this._results.length,\r\n      currentIndex: this._currentIndex,\r\n      finalized: this._finalized\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if statement has results\r\n   */\r\n  hasResults(): boolean {\r\n    return this._results.length > 0;\r\n  }\r\n\r\n  /**\r\n   * Get all results at once (helper method)\r\n   */\r\n  getAllResults(): { [column: string]: SQLValue }[] {\r\n    if (!this._executed) {\r\n      throw new SQLStatementError('Statement not executed yet');\r\n    }\r\n    return [...this._results];\r\n  }\r\n\r\n  /**\r\n   * Get all results as arrays (helper method)\r\n   */\r\n  getAllResultArrays(): SQLValue[][] {\r\n    if (!this._executed) {\r\n      throw new SQLStatementError('Statement not executed yet');\r\n    }\r\n    return this._results.map(row => \r\n      this.state.columns.map(col => row[col] ?? null)\r\n    );\r\n  }\r\n}","/**\r\n * Database Types for sql.js Compatibility\r\n * \r\n * This file defines types and interfaces that provide sql.js API compatibility\r\n * while working with the LocalRetrieve Worker infrastructure.\r\n */\r\n\r\nimport type { SQLValue, SQLParams, SearchRequest, SearchResponse } from './worker.js';\r\n\r\n// sql.js compatible types\r\nexport type { SQLValue, SQLParams };\r\n\r\n// Statement execution results\r\nexport interface StatementResult {\r\n  columns: string[];\r\n  values: SQLValue[][];\r\n}\r\n\r\n// Database execution options\r\nexport interface ExecOptions {\r\n  sql: string;\r\n  bind?: SQLParams;\r\n}\r\n\r\n// Statement binding options  \r\nexport interface BindOptions {\r\n  [key: string]: SQLValue;\r\n}\r\n\r\n// Database configuration\r\nexport interface DatabaseConfig {\r\n  filename?: string;\r\n  vfs?: 'opfs' | 'opfs-sahpool';\r\n  pragmas?: Record<string, string>;\r\n  workerUrl?: string;\r\n  workerConfig?: {\r\n    maxConcurrentOperations?: number;\r\n    operationTimeout?: number;\r\n    enablePerformanceMonitoring?: boolean;\r\n    logLevel?: 'debug' | 'info' | 'warn' | 'error';\r\n  };\r\n}\r\n\r\n// sql.js compatible Database interface\r\nexport interface DatabaseAPI {\r\n  // Core sql.js methods\r\n  exec(sql: string | ExecOptions): StatementResult[];\r\n  run(sql: string, params?: SQLParams): DatabaseAPI;\r\n  prepare(sql: string): StatementAPI;\r\n  export(): Uint8Array;\r\n  close(): void;\r\n\r\n  // Additional LocalRetrieve methods\r\n  search?(request: SearchRequest): Promise<SearchResponse>;\r\n  initializeSchema?(): Promise<void>;\r\n  \r\n  // Static creation method\r\n  // static create(buffer?: Uint8Array, filename?: string): Promise<DatabaseAPI>;\r\n}\r\n\r\n// sql.js compatible Statement interface\r\nexport interface StatementAPI {\r\n  // Core statement methods\r\n  bind(params?: SQLParams): StatementAPI;\r\n  step(): boolean;\r\n  get(): SQLValue[];\r\n  getAsObject(): Record<string, SQLValue>;\r\n  getColumnNames(): string[];\r\n  reset(): StatementAPI;\r\n  free(): void;\r\n\r\n  // Statement state\r\n  readonly finalized: boolean;\r\n}\r\n\r\n// Internal types for implementation\r\nexport interface DatabaseState {\r\n  isOpen: boolean;\r\n  filename: string;\r\n  worker: Worker | null;\r\n  workerRPC: any; // WorkerRPC instance\r\n}\r\n\r\nexport interface StatementState {\r\n  sql: string;\r\n  bound: boolean;\r\n  stepped: boolean;\r\n  finished: boolean;\r\n  currentRow: Record<string, SQLValue> | null;\r\n  columns: string[];\r\n  database: DatabaseAPI;\r\n}\r\n\r\n// Error types\r\nexport class DatabaseError extends Error {\r\n  constructor(message: string, public code?: string) {\r\n    super(message);\r\n    this.name = 'DatabaseError';\r\n  }\r\n}\r\n\r\nexport class StatementError extends Error {\r\n  constructor(message: string, public code?: string) {\r\n    super(message);\r\n    this.name = 'StatementError';\r\n  }\r\n}\r\n\r\n// Utility types for type checking\r\nexport function isStatementResult(obj: any): obj is StatementResult {\r\n  return obj && \r\n    typeof obj === 'object' && \r\n    Array.isArray(obj.columns) && \r\n    Array.isArray(obj.values);\r\n}\r\n\r\nexport function isSQLValue(value: any): value is SQLValue {\r\n  return value === null || \r\n    typeof value === 'number' || \r\n    typeof value === 'string' || \r\n    value instanceof Uint8Array;\r\n}\r\n\r\n// Configuration defaults\r\nexport const DEFAULT_DATABASE_CONFIG: Required<Omit<DatabaseConfig, 'filename' | 'workerUrl'>> = {\r\n  vfs: 'opfs',\r\n  pragmas: {\r\n    synchronous: 'NORMAL',\r\n    cache_size: '-64000', // 64MB cache\r\n    temp_store: 'MEMORY'\r\n  },\r\n  workerConfig: {\r\n    maxConcurrentOperations: 10,\r\n    operationTimeout: 30000,\r\n    enablePerformanceMonitoring: true,\r\n    logLevel: 'info'\r\n  }\r\n};\r\n\r\n// Worker URL resolution\r\nexport function resolveWorkerUrl(workerUrl?: string): string {\r\n  if (workerUrl) {\r\n    return workerUrl;\r\n  }\r\n  \r\n  // Default worker URL - relative to the current module\r\n  return new URL(/* @vite-ignore */ '../database/worker.js', import.meta.url).toString();\r\n}\r\n\r\n// Validation utilities\r\nexport function validateSQLParams(params: any): params is SQLParams {\r\n  if (!params) return true;\r\n  \r\n  if (Array.isArray(params)) {\r\n    return params.every(isSQLValue);\r\n  }\r\n  \r\n  if (typeof params === 'object') {\r\n    return Object.values(params).every(isSQLValue);\r\n  }\r\n  \r\n  return false;\r\n}\r\n\r\nexport function validateSQL(sql: any): sql is string {\r\n  return typeof sql === 'string' && sql.trim().length > 0;\r\n}","/**\r\n * Database Class - Complete sql.js Compatible Database Wrapper\r\n * \r\n * Provides a complete sql.js compatible Database interface that uses the\r\n * LocalRetrieve Worker infrastructure for all database operations.\r\n * \r\n * Supports both synchronous sql.js API (with limitations) and enhanced async API.\r\n */\r\n\r\nimport { WorkerRPC, createWorkerRPC } from '../utils/rpc.js';\r\nimport { Statement } from './Statement.js';\r\nimport type {\r\n  DatabaseAPI,\r\n  StatementAPI,\r\n  DatabaseConfig,\r\n  DatabaseState,\r\n  StatementResult,\r\n  ExecOptions,\r\n  SQLParams,\r\n  SQLValue\r\n} from '../types/database.js';\r\nimport type {\r\n  SearchRequest,\r\n  SearchResponse,\r\n  TextSearchParams,\r\n  AdvancedSearchParams,\r\n  GlobalSearchParams,\r\n  EnhancedSearchResponse,\r\n  GlobalSearchResponse,\r\n  // Task 6.2: Internal Embedding Pipeline types\r\n  GenerateQueryEmbeddingParams,\r\n  BatchGenerateQueryEmbeddingsParams,\r\n  WarmEmbeddingCacheParams,\r\n  ClearEmbeddingCacheParams,\r\n  PreloadModelsParams,\r\n  OptimizeModelMemoryParams,\r\n  QueryEmbeddingResult,\r\n  BatchQueryEmbeddingResult,\r\n  PipelinePerformanceStats,\r\n  ModelStatusResult\r\n} from '../types/worker.js';\r\nimport type {\r\n  TextSearchOptions\r\n} from '../types/search.js';\r\nimport { \r\n  DatabaseError, \r\n  DEFAULT_DATABASE_CONFIG, \r\n  resolveWorkerUrl,\r\n  validateSQL,\r\n  validateSQLParams \r\n} from '../types/database.js';\r\nimport {\r\n  SQLDatabase,\r\n  SQLStatement,\r\n  QueryExecResult,\r\n  SQLDatabaseConfig,\r\n  CompatibilityMode,\r\n  SQLCompatConfig,\r\n  DEFAULT_SQL_COMPAT_CONFIG,\r\n  transformToSQLResult,\r\n  SQLError,\r\n  SQLDatabaseError,\r\n  isSQLParams,\r\n  validateSQL as validateSQLQuery\r\n} from '../types/sql.js';\r\n\r\nexport class Database implements SQLDatabase {\r\n  private state: DatabaseState;\r\n  private workerRPC: WorkerRPC | null = null;\r\n  private isInitialized = false;\r\n  private compatConfig: SQLCompatConfig;\r\n  private rowsModified = 0;\r\n  private activeStatements = new Set<Statement>();\r\n\r\n  constructor(config: DatabaseConfig = {}) {\r\n    const finalConfig = { ...DEFAULT_DATABASE_CONFIG, ...config };\r\n    \r\n    this.state = {\r\n      isOpen: false,\r\n      filename: config.filename || ':memory:',\r\n      worker: null,\r\n      workerRPC: null\r\n    };\r\n\r\n    this.compatConfig = { ...DEFAULT_SQL_COMPAT_CONFIG };\r\n\r\n    // Initialize worker if not in static creation mode\r\n    if (config.filename !== undefined) {\r\n      this._initializeWorker(finalConfig);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Static factory method for sql.js compatibility\r\n   */\r\n  static async create(buffer?: Uint8Array, filename?: string): Promise<Database> {\r\n    const config: DatabaseConfig = {\r\n      filename: filename || ':memory:'\r\n    };\r\n\r\n    const db = new Database(config);\r\n    await db._initialize();\r\n\r\n    // If buffer provided, import it\r\n    if (buffer) {\r\n      await db._importBuffer(buffer);\r\n    }\r\n\r\n    return db;\r\n  }\r\n\r\n  /**\r\n   * Execute SQL statement(s) and return results (sql.js compatible)\r\n   */\r\n  exec(sql: string): QueryExecResult[] {\r\n    if (!this.state.isOpen) {\r\n      throw new SQLDatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!validateSQLQuery(sql)) {\r\n      throw new SQLDatabaseError('Invalid SQL statement');\r\n    }\r\n\r\n    try {\r\n      // For sql.js compatibility, use synchronous execution with limitations\r\n      return this._execSyncCompat(sql);\r\n    } catch (error) {\r\n      if (error instanceof SQLError) {\r\n        throw error;\r\n      }\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`SQL execution failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute SQL statement(s) asynchronously (enhanced API)\r\n   */\r\n  async execAsync(sql: string): Promise<QueryExecResult[]> {\r\n    if (!this.state.isOpen) {\r\n      throw new SQLDatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!validateSQLQuery(sql)) {\r\n      throw new SQLDatabaseError('Invalid SQL statement');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new SQLDatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      const result = await this.workerRPC.select({ sql });\r\n      return [transformToSQLResult(result.rows || [])];\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`SQL execution failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run SQL statement with parameters (sql.js compatible)\r\n   */\r\n  run(sql: string, params?: SQLParams): Database {\r\n    if (!this.state.isOpen) {\r\n      throw new SQLDatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!validateSQLQuery(sql)) {\r\n      throw new SQLDatabaseError('Invalid SQL statement');\r\n    }\r\n\r\n    if (params !== undefined && !isSQLParams(params)) {\r\n      throw new SQLDatabaseError('Invalid SQL parameters');\r\n    }\r\n\r\n    try {\r\n      this._runSyncCompat(sql, params);\r\n      return this;\r\n    } catch (error) {\r\n      if (error instanceof SQLError) {\r\n        throw error;\r\n      }\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`SQL execution failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run SQL statement with parameters asynchronously (enhanced API)\r\n   */\r\n  async runAsync(sql: string, params?: SQLParams): Promise<Database> {\r\n    if (!this.state.isOpen) {\r\n      throw new SQLDatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!validateSQLQuery(sql)) {\r\n      throw new SQLDatabaseError('Invalid SQL statement');\r\n    }\r\n\r\n    if (params !== undefined && !isSQLParams(params)) {\r\n      throw new SQLDatabaseError('Invalid SQL parameters');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new SQLDatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      await this.workerRPC.exec({ sql, params });\r\n      this.rowsModified++; // Track modifications\r\n      return this;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`SQL execution failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prepare SQL statement (sql.js compatible)\r\n   */\r\n  prepare(sql: string): Statement {\r\n    if (!this.state.isOpen) {\r\n      throw new SQLDatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!validateSQLQuery(sql)) {\r\n      throw new SQLDatabaseError('Invalid SQL statement');\r\n    }\r\n\r\n    const statement = new Statement(this as any, sql);\r\n    this.activeStatements.add(statement);\r\n    return statement;\r\n  }\r\n\r\n  /**\r\n   * Prepare SQL statement asynchronously (enhanced API)\r\n   */\r\n  async prepareAsync(sql: string): Promise<Statement> {\r\n    return this.prepare(sql); // Preparation is synchronous, execution is async\r\n  }\r\n\r\n  /**\r\n   * Export database as binary data (sql.js compatible)\r\n   */\r\n  export(): Uint8Array {\r\n    if (!this.state.isOpen) {\r\n      throw new SQLDatabaseError('Database is not open');\r\n    }\r\n\r\n    try {\r\n      return this._exportSyncCompat();\r\n    } catch (error) {\r\n      if (error instanceof SQLError) {\r\n        throw error;\r\n      }\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`Database export failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Export database as binary data asynchronously (enhanced API)\r\n   */\r\n  async exportAsync(): Promise<Uint8Array> {\r\n    if (!this.state.isOpen) {\r\n      throw new SQLDatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new SQLDatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.export();\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`Database export failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Close database connection (sql.js compatible)\r\n   */\r\n  close(): void {\r\n    // Finalize all active statements\r\n    for (const statement of this.activeStatements) {\r\n      try {\r\n        statement.free();\r\n      } catch (error) {\r\n        console.warn('Error finalizing statement:', error);\r\n      }\r\n    }\r\n    this.activeStatements.clear();\r\n\r\n    if (this.workerRPC) {\r\n      try {\r\n        this._closeSyncCompat();\r\n      } catch (error) {\r\n        // Log error but don't throw on close\r\n        console.warn('Error during database close:', error);\r\n      }\r\n    }\r\n\r\n    this.state.isOpen = false;\r\n    this.isInitialized = false;\r\n    \r\n    if (this.state.worker) {\r\n      this.state.worker.terminate();\r\n      this.state.worker = null;\r\n    }\r\n    \r\n    this.workerRPC = null;\r\n    this.state.workerRPC = null;\r\n  }\r\n\r\n  /**\r\n   * Close database connection asynchronously (enhanced API)\r\n   */\r\n  async closeAsync(): Promise<void> {\r\n    // Finalize all active statements\r\n    for (const statement of this.activeStatements) {\r\n      try {\r\n        statement.free();\r\n      } catch (error) {\r\n        console.warn('Error finalizing statement:', error);\r\n      }\r\n    }\r\n    this.activeStatements.clear();\r\n\r\n    if (this.workerRPC) {\r\n      try {\r\n        await this.workerRPC.close();\r\n      } catch (error) {\r\n        console.warn('Error during database close:', error);\r\n      }\r\n    }\r\n\r\n    this.state.isOpen = false;\r\n    this.isInitialized = false;\r\n    \r\n    if (this.state.worker) {\r\n      this.state.worker.terminate();\r\n      this.state.worker = null;\r\n    }\r\n    \r\n    this.workerRPC = null;\r\n    this.state.workerRPC = null;\r\n  }\r\n\r\n  /**\r\n   * Get number of rows modified by the last statement (sql.js compatible)\r\n   */\r\n  getRowsModified(): number {\r\n    return this.rowsModified;\r\n  }\r\n\r\n  /**\r\n   * Create a savepoint (sql.js compatible)\r\n   */\r\n  savepoint(name?: string): void {\r\n    const savepointName = name || `sp_${Date.now()}`;\r\n    try {\r\n      this._runSyncCompat(`SAVEPOINT ${savepointName}`);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`Savepoint creation failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Release a savepoint (sql.js compatible)\r\n   */\r\n  savepoint_release(name?: string): void {\r\n    const savepointName = name || 'sp';\r\n    try {\r\n      this._runSyncCompat(`RELEASE SAVEPOINT ${savepointName}`);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`Savepoint release failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rollback to a savepoint (sql.js compatible)\r\n   */\r\n  savepoint_rollback(name?: string): void {\r\n    const savepointName = name || 'sp';\r\n    try {\r\n      this._runSyncCompat(`ROLLBACK TO SAVEPOINT ${savepointName}`);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`Savepoint rollback failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create function (sql.js compatible stub)\r\n   */\r\n  create_function(name: string, func: (...args: any[]) => any): void {\r\n    if (this.compatConfig.enableWarnings) {\r\n      console.warn('create_function is not supported in LocalRetrieve. Use SQL functions instead.');\r\n    }\r\n    if (this.compatConfig.throwOnSyncLimitations) {\r\n      throw new SQLDatabaseError('create_function is not supported in Worker-based SQLite');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create aggregate function (sql.js compatible stub)\r\n   */\r\n  create_aggregate(name: string, funcs: { step: Function; finalize: Function }): void {\r\n    if (this.compatConfig.enableWarnings) {\r\n      console.warn('create_aggregate is not supported in LocalRetrieve. Use SQL aggregate functions instead.');\r\n    }\r\n    if (this.compatConfig.throwOnSyncLimitations) {\r\n      throw new SQLDatabaseError('create_aggregate is not supported in Worker-based SQLite');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform hybrid search (LocalRetrieve extension)\r\n   */\r\n  async search(request: SearchRequest): Promise<SearchResponse> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.search(request);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Search failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Text-only hybrid search with automatic strategy selection (Task 6.1)\r\n   * @param query - Search query string\r\n   * @param options - Search configuration options\r\n   * @returns Promise<EnhancedSearchResponse>\r\n   */\r\n  async searchText(query: string, options?: TextSearchOptions): Promise<EnhancedSearchResponse> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.searchText({ query, options });\r\n    } catch (error) {\r\n      // Enhanced error handling with graceful degradation\r\n      return this._handleSearchError(error, query, options);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Advanced search with explicit strategy control (Task 6.1)\r\n   * @param params - Advanced search parameters\r\n   * @returns Promise<EnhancedSearchResponse>\r\n   */\r\n  async searchAdvanced(params: AdvancedSearchParams): Promise<EnhancedSearchResponse> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.searchAdvanced(params);\r\n    } catch (error) {\r\n      return this._handleAdvancedSearchError(error, params);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Global search across all collections (Task 6.1)\r\n   * @param query - Search query string\r\n   * @param options - Global search options\r\n   * @returns Promise<GlobalSearchResponse>\r\n   */\r\n  async searchGlobal(query: string, options?: any): Promise<GlobalSearchResponse> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.searchGlobal({ query, options });\r\n    } catch (error) {\r\n      return this._handleGlobalSearchError(error, query, options);\r\n    }\r\n  }\r\n\r\n  // ============================================================================================\r\n  // LLM Integration API (SCRUM-17)\r\n  // ============================================================================================\r\n\r\n  /**\r\n   * Enhance search query using LLM (SCRUM-17)\r\n   *\r\n   * @param query - The search query to enhance\r\n   * @param options - LLM provider configuration\r\n   * @returns Promise<EnhancedQueryResult> - Enhanced query with suggestions\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const enhanced = await db.enhanceQuery('search docs', {\r\n   *   provider: 'openai',\r\n   *   model: 'gpt-4',\r\n   *   apiKey: 'sk-...'\r\n   * });\r\n   * console.log(enhanced.enhancedQuery); // \"document search files\"\r\n   * console.log(enhanced.suggestions);    // [\"find documents\", ...]\r\n   * ```\r\n   */\r\n  async enhanceQuery(\r\n    query: string,\r\n    options?: {\r\n      provider?: 'openai' | 'anthropic' | 'openrouter' | 'custom';\r\n      model?: string;\r\n      apiKey?: string;\r\n      endpoint?: string;\r\n      maxSuggestions?: number;\r\n      includeIntent?: boolean;\r\n      temperature?: number;\r\n      timeout?: number;\r\n    }\r\n  ): Promise<import('./types/worker.js').EnhancedQueryResult> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.enhanceQuery({ query, options });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Query enhancement failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Summarize search results using LLM (SCRUM-17)\r\n   *\r\n   * @param results - Array of search results to summarize\r\n   * @param options - LLM provider configuration\r\n   * @returns Promise<ResultSummaryResult> - Summary with key points\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const results = await db.search({ query: { text: 'documents' } });\r\n   * const summary = await db.summarizeResults(results.results, {\r\n   *   provider: 'anthropic',\r\n   *   model: 'claude-3-sonnet',\r\n   *   apiKey: 'sk-ant-...'\r\n   * });\r\n   * console.log(summary.summary);     // \"The search results...\"\r\n   * console.log(summary.keyPoints);   // [\"Document management\", ...]\r\n   * ```\r\n   */\r\n  async summarizeResults(\r\n    results: any[],\r\n    options?: {\r\n      provider?: 'openai' | 'anthropic' | 'openrouter' | 'custom';\r\n      model?: string;\r\n      apiKey?: string;\r\n      endpoint?: string;\r\n      maxLength?: number;\r\n      includeKeyPoints?: boolean;\r\n      temperature?: number;\r\n      timeout?: number;\r\n    }\r\n  ): Promise<import('./types/worker.js').ResultSummaryResult> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.summarizeResults({ results, options });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Result summarization failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Combined search with LLM enhancements (SCRUM-17)\r\n   *\r\n   * Performs search with optional query enhancement and result summarization.\r\n   *\r\n   * @param query - The search query\r\n   * @param options - Search and LLM configuration\r\n   * @returns Promise<LLMSearchResponseResult> - Results with LLM enhancements\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const smartSearch = await db.searchWithLLM('AI docs', {\r\n   *   enhanceQuery: true,\r\n   *   summarizeResults: true,\r\n   *   searchOptions: { limit: 20 },\r\n   *   llmOptions: {\r\n   *     provider: 'openai',\r\n   *     model: 'gpt-4',\r\n   *     apiKey: 'sk-...'\r\n   *   }\r\n   * });\r\n   * console.log(smartSearch.enhancedQuery);  // Enhanced query\r\n   * console.log(smartSearch.results);        // Search results\r\n   * console.log(smartSearch.summary);        // AI-generated summary\r\n   * ```\r\n   */\r\n  async searchWithLLM(\r\n    query: string,\r\n    options?: {\r\n      enhanceQuery?: boolean;\r\n      summarizeResults?: boolean;\r\n      searchOptions?: import('./types/search.js').TextSearchOptions;\r\n      llmOptions?: {\r\n        provider?: string;\r\n        model?: string;\r\n        apiKey?: string;\r\n        endpoint?: string;\r\n        temperature?: number;\r\n      };\r\n    }\r\n  ): Promise<import('./types/worker.js').LLMSearchResponseResult> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.searchWithLLM({ query, options });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`LLM search failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generic LLM call with arbitrary prompt (SCRUM-17)\r\n   *\r\n   * Provides direct access to LLM providers for custom use cases beyond\r\n   * query enhancement or result summarization. This method accepts any\r\n   * prompt and returns the raw LLM response.\r\n   *\r\n   * @param prompt - The prompt to send to the LLM\r\n   * @param options - LLM provider configuration\r\n   * @returns Promise<CallLLMResult> - Raw LLM response with text and metadata\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const result = await db.callLLM('Explain quantum computing in simple terms', {\r\n   *   provider: 'openai',\r\n   *   model: 'gpt-4',\r\n   *   apiKey: 'sk-...',\r\n   *   temperature: 0.7,\r\n   *   maxTokens: 500\r\n   * });\r\n   * console.log(result.text);           // LLM's response\r\n   * console.log(result.usage);          // Token usage stats\r\n   * console.log(result.processingTime); // Processing time in ms\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Custom use case: Generate product descriptions\r\n   * const product = { name: 'Widget Pro', features: ['Fast', 'Reliable'] };\r\n   * const prompt = `Generate a marketing description for: ${JSON.stringify(product)}`;\r\n   * const result = await db.callLLM(prompt, {\r\n   *   provider: 'anthropic',\r\n   *   model: 'claude-3-sonnet',\r\n   *   apiKey: process.env.ANTHROPIC_API_KEY\r\n   * });\r\n   * console.log(result.text); // Marketing description\r\n   * ```\r\n   */\r\n  async callLLM(\r\n    prompt: string,\r\n    options?: {\r\n      provider?: 'openai' | 'anthropic' | 'openrouter' | 'custom';\r\n      model?: string;\r\n      apiKey?: string;\r\n      endpoint?: string;\r\n      temperature?: number;\r\n      maxTokens?: number;\r\n      timeout?: number;\r\n      systemPrompt?: string;\r\n    }\r\n  ): Promise<import('./types/worker.js').CallLLMResult> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.callLLM({ prompt, options });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`LLM call failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  // Task 6.2: Internal Embedding Pipeline API\r\n  // ============================================================================================\r\n\r\n  /**\r\n   * Generate embedding for a query with intelligent caching (Task 6.2)\r\n   * @param query - Text query to generate embedding for\r\n   * @param collection - Collection context for embedding generation\r\n   * @param options - Additional generation options\r\n   * @returns Promise<QueryEmbeddingResult>\r\n   */\r\n  async generateQueryEmbedding(\r\n    query: string,\r\n    collection: string,\r\n    options?: {\r\n      forceRefresh?: boolean;\r\n      timeout?: number;\r\n      priority?: number;\r\n      context?: {\r\n        userId?: string;\r\n        sessionId?: string;\r\n        source?: string;\r\n      };\r\n    }\r\n  ): Promise<QueryEmbeddingResult> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.generateQueryEmbedding({\r\n        query,\r\n        collection,\r\n        options\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Query embedding generation failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate embeddings for multiple queries in batch (Task 6.2)\r\n   * @param requests - Array of embedding requests\r\n   * @param batchOptions - Batch processing options\r\n   * @returns Promise<BatchQueryEmbeddingResult[]>\r\n   */\r\n  async batchGenerateQueryEmbeddings(\r\n    requests: Array<{\r\n      id: string;\r\n      query: string;\r\n      collection: string;\r\n      options?: Parameters<Database['generateQueryEmbedding']>[2];\r\n    }>,\r\n    batchOptions?: {\r\n      batchSize?: number;\r\n      concurrency?: number;\r\n      timeout?: number;\r\n      onProgress?: (completed: number, total: number, current?: string) => void;\r\n    }\r\n  ): Promise<BatchQueryEmbeddingResult[]> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.batchGenerateQueryEmbeddings({\r\n        requests,\r\n        batchOptions\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Batch query embedding generation failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Warm embedding cache with common queries (Task 6.2)\r\n   * @param collection - Collection to warm cache for\r\n   * @param commonQueries - Array of frequently used queries\r\n   * @returns Promise<void>\r\n   */\r\n  async warmEmbeddingCache(collection: string, commonQueries: string[]): Promise<void> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      await this.workerRPC.warmEmbeddingCache({\r\n        collection,\r\n        commonQueries\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Embedding cache warming failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear embedding cache (Task 6.2)\r\n   * @param collection - Optional specific collection to clear\r\n   * @param pattern - Optional pattern for selective clearing\r\n   * @returns Promise<void>\r\n   */\r\n  async clearEmbeddingCache(collection?: string, pattern?: string): Promise<void> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      await this.workerRPC.clearEmbeddingCache({\r\n        collection,\r\n        pattern\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Embedding cache clearing failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get embedding pipeline performance statistics (Task 6.2)\r\n   * @returns Promise<PipelinePerformanceStats>\r\n   */\r\n  async getPipelineStats(): Promise<PipelinePerformanceStats> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.getPipelineStats();\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Pipeline stats retrieval failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get model status information (Task 6.2)\r\n   * @returns Promise<ModelStatusResult>\r\n   */\r\n  async getModelStatus(): Promise<ModelStatusResult> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.getModelStatus();\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Model status retrieval failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  // ====================================\r\n  // Phase 4: Collection Integration\r\n  // ====================================\r\n\r\n  /**\r\n   * Create a new collection with optional embedding configuration\r\n   */\r\n  async createCollection(params: {\r\n    name: string;\r\n    embeddingConfig?: import('../embedding/types.js').CollectionEmbeddingConfig;\r\n    description?: string;\r\n    metadata?: Record<string, any>;\r\n  }): Promise<void> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      await this.workerRPC.createCollection(params);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Collection creation failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get embedding status for a collection\r\n   */\r\n  async getCollectionEmbeddingStatus(collection: string): Promise<import('../types/worker.js').CollectionEmbeddingStatusResult> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.getCollectionEmbeddingStatus(collection);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Failed to get collection embedding status: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Insert a document with automatic embedding generation\r\n   */\r\n  async insertDocumentWithEmbedding(params: {\r\n    collection: string;\r\n    document: {\r\n      id?: string;\r\n      title?: string;\r\n      content: string;\r\n      metadata?: Record<string, any>;\r\n    };\r\n    options?: {\r\n      generateEmbedding?: boolean;\r\n      embeddingOptions?: import('../embedding/types.js').EmbeddingRequestOptions;\r\n    };\r\n  }): Promise<{ id: string; embeddingGenerated: boolean }> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.insertDocumentWithEmbedding(params);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Document insertion with embedding failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform semantic search on a collection\r\n   */\r\n  async searchSemantic(params: {\r\n    collection: string;\r\n    query: string;\r\n    options?: {\r\n      limit?: number;\r\n      similarityThreshold?: number;\r\n      includeEmbeddings?: boolean;\r\n      filters?: Record<string, any>;\r\n      generateQueryEmbedding?: boolean;\r\n    };\r\n  }): Promise<SearchResponse> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.searchSemantic(params);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Semantic search failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  // ====================================\r\n  // Phase 5: Embedding Queue Management\r\n  // ====================================\r\n\r\n  /**\r\n   * Add documents to the embedding generation queue (Phase 5)\r\n   * @param params - Queue parameters including collection, documents, and priority\r\n   * @returns Promise<number> - Number of documents added to queue\r\n   */\r\n  async enqueueEmbedding(params: Parameters<import('../utils/rpc').WorkerRPC['enqueueEmbedding']>[0]): Promise<number> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.enqueueEmbedding(params);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Embedding queue enqueue failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process pending embedding queue items (Phase 5)\r\n   * @param params - Optional processing parameters including collection filter and batch size\r\n   * @returns Promise<QueueProcessResult> - Processing results\r\n   */\r\n  async processEmbeddingQueue(params?: Parameters<import('../utils/rpc').WorkerRPC['processEmbeddingQueue']>[0]) {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.processEmbeddingQueue(params);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Embedding queue processing failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get embedding queue status and statistics (Phase 5)\r\n   * @param collection - Optional collection name to filter results\r\n   * @returns Promise<QueueStatusResult> - Current queue status\r\n   */\r\n  async getQueueStatus(collection?: string) {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.getQueueStatus(collection);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Queue status retrieval failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear embedding queue items (Phase 5)\r\n   * @param params - Optional parameters to filter which items to clear\r\n   * @returns Promise<number> - Number of items cleared\r\n   */\r\n  async clearEmbeddingQueue(params?: Parameters<import('../utils/rpc').WorkerRPC['clearEmbeddingQueue']>[0]): Promise<number> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      return await this.workerRPC.clearEmbeddingQueue(params);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Queue clearing failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Preload embedding models (Task 6.2)\r\n   * @param providers - Array of provider names to preload\r\n   * @param strategy - Loading strategy (eager, lazy, predictive)\r\n   * @returns Promise<void>\r\n   */\r\n  async preloadModels(providers: string[], strategy: 'eager' | 'lazy' | 'predictive' = 'lazy'): Promise<void> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      await this.workerRPC.preloadModels({\r\n        providers,\r\n        strategy\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Model preloading failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Optimize model memory usage (Task 6.2)\r\n   * @param options - Memory optimization options\r\n   * @returns Promise<void>\r\n   */\r\n  async optimizeModelMemory(options?: {\r\n    maxMemoryUsage?: number;\r\n    maxModels?: number;\r\n    idleTimeout?: number;\r\n    aggressive?: boolean;\r\n  }): Promise<void> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      await this.workerRPC.optimizeModelMemory(options);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Model memory optimization failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize schema (LocalRetrieve extension)\r\n   */\r\n  async initializeSchema(): Promise<void> {\r\n    if (!this.state.isOpen) {\r\n      throw new DatabaseError('Database is not open');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      await this.workerRPC.initializeSchema();\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Schema initialization failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Worker RPC instance (for Statement class)\r\n   */\r\n  _getWorkerRPC(): WorkerRPC | null {\r\n    return this.workerRPC;\r\n  }\r\n\r\n  /**\r\n   * Initialize worker and open database connection\r\n   */\r\n  async _initialize(): Promise<void> {\r\n    if (this.isInitialized) {\r\n      return;\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not initialized');\r\n    }\r\n\r\n    try {\r\n      // Open database (vec extension is initialized automatically in handleOpen)\r\n      await this.workerRPC.open({\r\n        filename: this.state.filename,\r\n        vfs: 'opfs'\r\n      });\r\n\r\n      this.state.isOpen = true;\r\n      this.isInitialized = true;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Database initialization failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize worker RPC\r\n   */\r\n  private _initializeWorker(config: DatabaseConfig): void {\r\n    try {\r\n      // Try multiple worker URL strategies\r\n      let workerUrl: string;\r\n      \r\n      if (config.workerUrl) {\r\n        workerUrl = config.workerUrl;\r\n      } else {\r\n        // Use module URL for compiled package structure\r\n        // This will work both in development (Vite) and production (npm package)\r\n        workerUrl = new URL('../database/worker.js', import.meta.url).toString();\r\n      }\r\n      \r\n      console.log('[Database._initializeWorker] Attempting to load worker from:', workerUrl);\r\n      \r\n      this.workerRPC = createWorkerRPC(workerUrl, config.workerConfig);\r\n      this.state.worker = (this.workerRPC as any).worker;\r\n      this.state.workerRPC = this.workerRPC;\r\n      \r\n      console.log('[Database._initializeWorker] Worker RPC created successfully');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      console.error('[Database._initializeWorker] Worker initialization failed:', error);\r\n      \r\n      // Provide helpful error message with potential solutions\r\n      throw new DatabaseError(\r\n        `Worker initialization failed: ${message}\\n\\n` +\r\n        'Possible solutions:\\n' +\r\n        '1. Ensure the database worker file exists at the correct path\\n' +\r\n        '2. Check that your build process includes worker files\\n' +\r\n        '3. Verify COOP/COEP headers are set for SharedArrayBuffer support\\n' +\r\n        '4. Try providing an explicit workerUrl in the config'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Import buffer data\r\n   */\r\n  private async _importBuffer(buffer: Uint8Array): Promise<void> {\r\n    if (!this.workerRPC) {\r\n      throw new DatabaseError('Worker not available');\r\n    }\r\n\r\n    try {\r\n      await this.workerRPC.import({\r\n        data: buffer,\r\n        format: 'sqlite',\r\n        overwrite: true\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new DatabaseError(`Buffer import failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Synchronous execution compatibility layer\r\n   * Uses blocking async call with warnings about limitations\r\n   */\r\n  private _execSyncCompat(sql: string): QueryExecResult[] {\r\n    if (this.compatConfig.enableWarnings) {\r\n      console.warn('SYNC/ASYNC COMPATIBILITY WARNING: Using synchronous API with async Worker. Consider using execAsync() for better performance.');\r\n    }\r\n    \r\n    if (this.compatConfig.throwOnSyncLimitations) {\r\n      throw new SQLDatabaseError(\r\n        'SYNC/ASYNC COMPATIBILITY ISSUE:\\n' +\r\n        'Worker communication is inherently async. SQL executed successfully but cannot return synchronously.\\n' +\r\n        'SOLUTIONS:\\n' +\r\n        '1. Use async API: await database.execAsync(sql) instead of database.exec(sql)\\n' +\r\n        '2. Use database.prepare() for prepared statements\\n' +\r\n        '3. Consider using sql.js directly on main thread for true sync operations\\n' +\r\n        '\\nThis is a known limitation of browser worker architecture.'\r\n      );\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new SQLDatabaseError('Worker not available');\r\n    }\r\n\r\n    // Attempt synchronous execution with timeout\r\n    let isResolved = false;\r\n    let result: any = null;\r\n    let error: any = null;\r\n\r\n    const executePromise = this.workerRPC.select({ sql });\r\n\r\n    executePromise\r\n      .then((res: any) => {\r\n        result = res;\r\n        isResolved = true;\r\n      })\r\n      .catch((err: any) => {\r\n        error = err;\r\n        isResolved = true;\r\n      });\r\n\r\n    // Busy wait for result (limited time)\r\n    const startTime = Date.now();\r\n    const timeout = this.compatConfig.workerTimeout;\r\n\r\n    while (!isResolved && (Date.now() - startTime) < timeout) {\r\n      // Minimal busy wait to allow event loop processing\r\n    }\r\n\r\n    if (!isResolved) {\r\n      throw new SQLDatabaseError('Query execution timeout in sync compatibility mode');\r\n    }\r\n\r\n    if (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`Query execution failed: ${message}`);\r\n    }\r\n\r\n    return [transformToSQLResult(result?.rows || [])];\r\n  }\r\n\r\n  /**\r\n   * Synchronous run compatibility layer\r\n   */\r\n  private _runSyncCompat(sql: string, params?: SQLParams): void {\r\n    if (this.compatConfig.enableWarnings) {\r\n      console.warn('SYNC/ASYNC COMPATIBILITY WARNING: Using synchronous API with async Worker. Consider using runAsync() for better performance.');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new SQLDatabaseError('Worker not available');\r\n    }\r\n\r\n    let isResolved = false;\r\n    let error: any = null;\r\n\r\n    const executePromise = this.workerRPC.exec({ sql, params });\r\n\r\n    executePromise\r\n      .then(() => {\r\n        this.rowsModified++;\r\n        isResolved = true;\r\n      })\r\n      .catch((err: any) => {\r\n        error = err;\r\n        isResolved = true;\r\n      });\r\n\r\n    // Busy wait for result\r\n    const startTime = Date.now();\r\n    const timeout = this.compatConfig.workerTimeout;\r\n\r\n    while (!isResolved && (Date.now() - startTime) < timeout) {\r\n      // Minimal busy wait\r\n    }\r\n\r\n    if (!isResolved) {\r\n      throw new SQLDatabaseError('Query execution timeout in sync compatibility mode');\r\n    }\r\n\r\n    if (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`Query execution failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Synchronous export compatibility layer\r\n   */\r\n  private _exportSyncCompat(): Uint8Array {\r\n    if (this.compatConfig.enableWarnings) {\r\n      console.warn('SYNC/ASYNC COMPATIBILITY WARNING: Using synchronous export with async Worker. Consider using exportAsync() for better performance.');\r\n    }\r\n\r\n    if (!this.workerRPC) {\r\n      throw new SQLDatabaseError('Worker not available');\r\n    }\r\n\r\n    let isResolved = false;\r\n    let result: Uint8Array | null = null;\r\n    let error: any = null;\r\n\r\n    const exportPromise = this.workerRPC.export();\r\n\r\n    exportPromise\r\n      .then((res: Uint8Array) => {\r\n        result = res;\r\n        isResolved = true;\r\n      })\r\n      .catch((err: any) => {\r\n        error = err;\r\n        isResolved = true;\r\n      });\r\n\r\n    // Busy wait for result\r\n    const startTime = Date.now();\r\n    const timeout = this.compatConfig.workerTimeout;\r\n\r\n    while (!isResolved && (Date.now() - startTime) < timeout) {\r\n      // Minimal busy wait\r\n    }\r\n\r\n    if (!isResolved) {\r\n      throw new SQLDatabaseError('Export timeout in sync compatibility mode');\r\n    }\r\n\r\n    if (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`Export failed: ${message}`);\r\n    }\r\n\r\n    return result || new Uint8Array(0);\r\n  }\r\n\r\n  /**\r\n   * Synchronous close compatibility layer\r\n   */\r\n  private _closeSyncCompat(): void {\r\n    if (!this.workerRPC) {\r\n      return;\r\n    }\r\n\r\n    let isResolved = false;\r\n    let error: any = null;\r\n\r\n    const closePromise = this.workerRPC.close();\r\n\r\n    closePromise\r\n      .then(() => {\r\n        isResolved = true;\r\n      })\r\n      .catch((err: any) => {\r\n        error = err;\r\n        isResolved = true;\r\n      });\r\n\r\n    // Busy wait for result (shorter timeout for close)\r\n    const startTime = Date.now();\r\n    const timeout = 5000; // 5 second timeout for close\r\n\r\n    while (!isResolved && (Date.now() - startTime) < timeout) {\r\n      // Minimal busy wait\r\n    }\r\n\r\n    if (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      throw new SQLDatabaseError(`Close failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  // Enhanced error handling with graceful degradation (Task 6.1)\r\n  private async _handleSearchError(\r\n    error: any,\r\n    query: string,\r\n    options?: TextSearchOptions\r\n  ): Promise<EnhancedSearchResponse> {\r\n    // Attempt fallback to existing search method\r\n    if (!options?.mode || options.mode !== 'VECTOR_ONLY' as any) {\r\n      try {\r\n        const fallbackResult = await this.search({\r\n          query: { text: query },\r\n          collection: options?.collection,\r\n          limit: options?.limit || 10\r\n        });\r\n\r\n        // Convert SearchResponse to EnhancedSearchResponse\r\n        return {\r\n          results: fallbackResult.results,\r\n          totalResults: fallbackResult.totalResults,\r\n          searchTime: fallbackResult.searchTime,\r\n          strategy: 'keyword' as any,\r\n          suggestions: [],\r\n          debugInfo: {\r\n            queryAnalysis: {\r\n              originalQuery: query,\r\n              normalizedQuery: query,\r\n              queryType: 'unknown' as any,\r\n              confidence: 0.5,\r\n              features: {\r\n                wordCount: query.split(' ').length,\r\n                hasQuestionWords: false,\r\n                hasBooleanOperators: false,\r\n                hasWildcards: false,\r\n                hasQuotes: false,\r\n                hasNumbers: false,\r\n                hasSpecialCharacters: false,\r\n                averageWordLength: 5,\r\n                containsCommonStopWords: false,\r\n                estimatedIntent: 'search'\r\n              },\r\n              suggestedStrategy: 'keyword' as any,\r\n              alternativeStrategies: [],\r\n              estimatedComplexity: 'low'\r\n            },\r\n            executionPlan: {\r\n              primaryStrategy: 'keyword' as any,\r\n              fallbackStrategies: [],\r\n              searchModes: [],\r\n              fusion: {\r\n                method: 'rrf' as any,\r\n                weights: {\r\n                  fts: 1,\r\n                  vector: 0,\r\n                  exactMatch: 1,\r\n                  phraseMatch: 1,\r\n                  proximity: 0.5,\r\n                  freshness: 0.1,\r\n                  popularity: 0.1\r\n                },\r\n                normalization: 'none' as any\r\n              },\r\n              filters: {},\r\n              pagination: { limit: options?.limit || 20, offset: 0 },\r\n              performance: {}\r\n            },\r\n            timings: {\r\n              analysis: 0,\r\n              planning: 0,\r\n              execution: fallbackResult.searchTime,\r\n              fusion: 0,\r\n              total: fallbackResult.searchTime\r\n            },\r\n            indexUsage: {\r\n              ftsIndex: true,\r\n              vectorIndex: false\r\n            },\r\n            warnings: ['Fell back to basic search due to enhanced search error'],\r\n            recommendations: ['Consider using basic search() method for simple queries']\r\n          }\r\n        };\r\n      } catch (fallbackError) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        const fallbackMessage = fallbackError instanceof Error ? fallbackError.message : String(fallbackError);\r\n        throw new DatabaseError(`Search failed: ${message}, Fallback failed: ${fallbackMessage}`);\r\n      }\r\n    }\r\n    const message = error instanceof Error ? error.message : String(error);\r\n    throw new DatabaseError(`Text search failed: ${message}`);\r\n  }\r\n\r\n  private async _handleAdvancedSearchError(error: any, params: AdvancedSearchParams): Promise<EnhancedSearchResponse> {\r\n    const message = error instanceof Error ? error.message : String(error);\r\n    throw new DatabaseError(`Advanced search failed: ${message}`);\r\n  }\r\n\r\n  private async _handleGlobalSearchError(error: any, query: string, options?: any): Promise<GlobalSearchResponse> {\r\n    const message = error instanceof Error ? error.message : String(error);\r\n    throw new DatabaseError(`Global search failed: ${message}`);\r\n  }\r\n}","/**\r\n * Класс для предобработки текста перед генерацией эмбеддингов\r\n *\r\n * Данный модуль предоставляет комплексную предобработку текста, включая:\r\n * - Удаление HTML тегов и сущностей\r\n * - Очистка markdown разметки\r\n * - Нормализация пробелов и специальных символов\r\n * - Обрезка текста до лимитов модели\r\n * - Поддержка различных форматов документов\r\n */\r\n\r\nimport type { TextPreprocessingConfig } from './types.js';\r\nimport { ValidationError, EmbeddingError } from './errors.js';\r\n\r\n/**\r\n * Результат предобработки текста\r\n */\r\nexport interface TextProcessingResult {\r\n  /** Обработанный текст */\r\n  processedText: string;\r\n\r\n  /** Исходная длина текста */\r\n  originalLength: number;\r\n\r\n  /** Длина после обработки */\r\n  processedLength: number;\r\n\r\n  /** Приблизительное количество токенов */\r\n  estimatedTokens: number;\r\n\r\n  /** Был ли текст обрезан */\r\n  wasTruncated: boolean;\r\n\r\n  /** Примененные операции предобработки */\r\n  appliedOperations: string[];\r\n\r\n  /** Метаданные обработки */\r\n  metadata: {\r\n    removedHtmlTags?: number;\r\n    removedMarkdownElements?: number;\r\n    normalizedWhitespace?: boolean;\r\n    convertedToLowerCase?: boolean;\r\n    removedSpecialChars?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Опции обрезки текста\r\n */\r\nexport interface TruncationOptions {\r\n  /** Максимальная длина в символах */\r\n  maxCharacters?: number;\r\n\r\n  /** Максимальное количество токенов (приблизительно) */\r\n  maxTokens?: number;\r\n\r\n  /** Стратегия обрезки */\r\n  strategy?: 'head' | 'tail' | 'middle';\r\n\r\n  /** Сохранять ли границы слов */\r\n  preserveWordBoundaries?: boolean;\r\n\r\n  /** Добавлять ли индикатор обрезки */\r\n  addTruncationIndicator?: boolean;\r\n\r\n  /** Текст индикатора обрезки */\r\n  truncationIndicator?: string;\r\n}\r\n\r\n/**\r\n * Статистика предобработки\r\n */\r\nexport interface ProcessingStatistics {\r\n  /** Общее количество обработанных текстов */\r\n  totalProcessed: number;\r\n\r\n  /** Среднее время обработки в миллисекундах */\r\n  averageProcessingTime: number;\r\n\r\n  /** Количество текстов, которые были обрезаны */\r\n  truncatedCount: number;\r\n\r\n  /** Средняя длина исходного текста */\r\n  averageOriginalLength: number;\r\n\r\n  /** Средняя длина обработанного текста */\r\n  averageProcessedLength: number;\r\n\r\n  /** Время сброса статистики */\r\n  resetTime: Date;\r\n}\r\n\r\n/**\r\n * Основной класс для предобработки текста\r\n */\r\nexport class TextProcessor {\r\n  private config: Required<Omit<TextPreprocessingConfig, 'customPreprocessor'>> & { customPreprocessor?: string };\r\n  private statistics: ProcessingStatistics;\r\n\r\n  /** Регулярное выражение для HTML тегов */\r\n  private static readonly HTML_TAG_REGEX = /<[^>]*>/g;\r\n\r\n  /** Регулярное выражение для HTML сущностей */\r\n  private static readonly HTML_ENTITY_REGEX = /&[a-zA-Z0-9#]+;/g;\r\n\r\n  /** Регулярное выражение для множественных пробелов */\r\n  private static readonly MULTIPLE_WHITESPACE_REGEX = /\\s+/g;\r\n\r\n  /** Регулярное выражение для специальных символов */\r\n  private static readonly SPECIAL_CHARS_REGEX = /[^\\w\\s\\u0400-\\u04FF.,!?;:'\"()\\-]/g;\r\n\r\n  /** Приблизительное соотношение символов к токенам */\r\n  private static readonly CHARS_PER_TOKEN = 4;\r\n\r\n  /** Markdown элементы для удаления */\r\n  private static readonly MARKDOWN_PATTERNS = [\r\n    // Заголовки\r\n    { pattern: /^#{1,6}\\s+/gm, description: 'headers' },\r\n    // Жирный и курсивный текст\r\n    { pattern: /\\*\\*([^*]+)\\*\\*/g, replacement: '$1', description: 'bold' },\r\n    { pattern: /__([^_]+)__/g, replacement: '$1', description: 'bold_alt' },\r\n    { pattern: /\\*([^*]+)\\*/g, replacement: '$1', description: 'italic' },\r\n    { pattern: /_([^_]+)_/g, replacement: '$1', description: 'italic_alt' },\r\n    // Зачеркнутый текст\r\n    { pattern: /~~([^~]+)~~/g, replacement: '$1', description: 'strikethrough' },\r\n    // Код\r\n    { pattern: /`([^`]+)`/g, replacement: '$1', description: 'inline_code' },\r\n    { pattern: /```[\\s\\S]*?```/g, replacement: '', description: 'code_blocks' },\r\n    // Ссылки\r\n    { pattern: /\\[([^\\]]+)\\]\\([^)]+\\)/g, replacement: '$1', description: 'links' },\r\n    { pattern: /!\\[([^\\]]*)\\]\\([^)]+\\)/g, replacement: '$1', description: 'images' },\r\n    // Списки\r\n    { pattern: /^[\\s]*[-*+]\\s+/gm, replacement: '', description: 'unordered_lists' },\r\n    { pattern: /^[\\s]*\\d+\\.\\s+/gm, replacement: '', description: 'ordered_lists' },\r\n    // Цитаты\r\n    { pattern: /^>\\s*/gm, replacement: '', description: 'blockquotes' },\r\n    // Горизонтальные линии\r\n    { pattern: /^[-*_]{3,}$/gm, replacement: '', description: 'horizontal_rules' },\r\n    // Таблицы\r\n    { pattern: /\\|.*\\|/g, replacement: '', description: 'tables' }\r\n  ];\r\n\r\n  constructor(config: Partial<TextPreprocessingConfig> = {}) {\r\n    // Устанавливаем значения по умолчанию\r\n    this.config = {\r\n      maxLength: config.maxLength ?? 8192,\r\n      stripHtml: config.stripHtml ?? true,\r\n      stripMarkdown: config.stripMarkdown ?? true,\r\n      normalizeWhitespace: config.normalizeWhitespace ?? true,\r\n      toLowerCase: config.toLowerCase ?? false,\r\n      removeSpecialChars: config.removeSpecialChars ?? false,\r\n      customPreprocessor: config.customPreprocessor\r\n    };\r\n\r\n    this.statistics = {\r\n      totalProcessed: 0,\r\n      averageProcessingTime: 0,\r\n      truncatedCount: 0,\r\n      averageOriginalLength: 0,\r\n      averageProcessedLength: 0,\r\n      resetTime: new Date()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Основной метод предобработки текста\r\n   *\r\n   * @param text - Исходный текст для обработки\r\n   * @param options - Дополнительные опции обработки\r\n   * @returns Результат предобработки\r\n   */\r\n  public processText(\r\n    text: string,\r\n    options: Partial<TextPreprocessingConfig & TruncationOptions> = {}\r\n  ): TextProcessingResult {\r\n    const startTime = performance.now();\r\n\r\n    // Валидация входных данных\r\n    this.validateInput(text);\r\n\r\n    const originalLength = text.length;\r\n    const appliedOperations: string[] = [];\r\n    const metadata: TextProcessingResult['metadata'] = {};\r\n\r\n    let processedText = text;\r\n\r\n    // Объединяем конфигурацию с опциями\r\n    const effectiveConfig = { ...this.config, ...options };\r\n\r\n    // Удаление HTML\r\n    if (effectiveConfig.stripHtml) {\r\n      const htmlResult = this.removeHtml(processedText);\r\n      processedText = htmlResult.text;\r\n      metadata.removedHtmlTags = htmlResult.removedCount;\r\n      if (htmlResult.removedCount > 0) {\r\n        appliedOperations.push('html_removal');\r\n      }\r\n    }\r\n\r\n    // Удаление Markdown\r\n    if (effectiveConfig.stripMarkdown) {\r\n      const markdownResult = this.removeMarkdown(processedText);\r\n      processedText = markdownResult.text;\r\n      metadata.removedMarkdownElements = markdownResult.removedCount;\r\n      if (markdownResult.removedCount > 0) {\r\n        appliedOperations.push('markdown_removal');\r\n      }\r\n    }\r\n\r\n    // Нормализация пробелов\r\n    if (effectiveConfig.normalizeWhitespace) {\r\n      const beforeLength = processedText.length;\r\n      processedText = this.normalizeWhitespace(processedText);\r\n      metadata.normalizedWhitespace = processedText.length !== beforeLength;\r\n      if (metadata.normalizedWhitespace) {\r\n        appliedOperations.push('whitespace_normalization');\r\n      }\r\n    }\r\n\r\n    // Приведение к нижнему регистру\r\n    if (effectiveConfig.toLowerCase) {\r\n      processedText = processedText.toLowerCase();\r\n      metadata.convertedToLowerCase = true;\r\n      appliedOperations.push('lowercase_conversion');\r\n    }\r\n\r\n    // Удаление специальных символов\r\n    if (effectiveConfig.removeSpecialChars) {\r\n      const beforeLength = processedText.length;\r\n      processedText = this.removeSpecialCharacters(processedText);\r\n      metadata.removedSpecialChars = beforeLength - processedText.length;\r\n      if (metadata.removedSpecialChars > 0) {\r\n        appliedOperations.push('special_chars_removal');\r\n      }\r\n    }\r\n\r\n    // Применение пользовательской функции предобработки\r\n    if (effectiveConfig.customPreprocessor) {\r\n      try {\r\n        const customFunction = new Function('text', effectiveConfig.customPreprocessor);\r\n        processedText = customFunction(processedText) || processedText;\r\n        appliedOperations.push('custom_preprocessing');\r\n      } catch (error) {\r\n        // Игнорируем ошибки в пользовательской функции, но логируем\r\n        console.warn('Custom preprocessor failed:', error);\r\n      }\r\n    }\r\n\r\n    // Обрезка текста\r\n    const truncationResult = this.truncateText(processedText, {\r\n      maxCharacters: effectiveConfig.maxLength,\r\n      maxTokens: options.maxTokens,\r\n      strategy: options.strategy,\r\n      preserveWordBoundaries: options.preserveWordBoundaries,\r\n      addTruncationIndicator: options.addTruncationIndicator,\r\n      truncationIndicator: options.truncationIndicator\r\n    });\r\n\r\n    processedText = truncationResult.text;\r\n    const wasTruncated = truncationResult.wasTruncated;\r\n\r\n    if (wasTruncated) {\r\n      appliedOperations.push('text_truncation');\r\n    }\r\n\r\n    const processedLength = processedText.length;\r\n    const estimatedTokens = Math.ceil(processedLength / TextProcessor.CHARS_PER_TOKEN);\r\n\r\n    // Обновление статистики\r\n    const processingTime = performance.now() - startTime;\r\n    this.updateStatistics(originalLength, processedLength, processingTime, wasTruncated);\r\n\r\n    return {\r\n      processedText,\r\n      originalLength,\r\n      processedLength,\r\n      estimatedTokens,\r\n      wasTruncated,\r\n      appliedOperations,\r\n      metadata\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Удаление HTML тегов и сущностей\r\n   *\r\n   * @param text - Текст с HTML разметкой\r\n   * @returns Очищенный текст и количество удаленных элементов\r\n   */\r\n  private removeHtml(text: string): { text: string; removedCount: number } {\r\n    let removedCount = 0;\r\n\r\n    // Удаляем HTML теги\r\n    const withoutTags = text.replace(TextProcessor.HTML_TAG_REGEX, (match) => {\r\n      removedCount++;\r\n      return ' '; // Заменяем пробелом для сохранения разделения слов\r\n    });\r\n\r\n    // Удаляем HTML сущности и декодируем их\r\n    const withoutEntities = withoutTags.replace(TextProcessor.HTML_ENTITY_REGEX, (match) => {\r\n      removedCount++;\r\n      // Декодируем наиболее распространенные сущности\r\n      const entityMap: Record<string, string> = {\r\n        '&amp;': '&',\r\n        '&lt;': '<',\r\n        '&gt;': '>',\r\n        '&quot;': '\"',\r\n        '&#39;': \"'\",\r\n        '&apos;': \"'\",\r\n        '&nbsp;': ' ',\r\n        '&copy;': '©',\r\n        '&reg;': '®',\r\n        '&trade;': '™'\r\n      };\r\n\r\n      return entityMap[match] || ' ';\r\n    });\r\n\r\n    return {\r\n      text: withoutEntities,\r\n      removedCount\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Удаление Markdown разметки\r\n   *\r\n   * @param text - Текст с Markdown разметкой\r\n   * @returns Очищенный текст и количество удаленных элементов\r\n   */\r\n  private removeMarkdown(text: string): { text: string; removedCount: number } {\r\n    let processedText = text;\r\n    let removedCount = 0;\r\n\r\n    for (const { pattern, replacement, description } of TextProcessor.MARKDOWN_PATTERNS) {\r\n      const beforeLength = processedText.length;\r\n\r\n      if (replacement !== undefined) {\r\n        // Замена с сохранением содержимого\r\n        processedText = processedText.replace(pattern, replacement);\r\n      } else {\r\n        // Полное удаление\r\n        processedText = processedText.replace(pattern, ' ');\r\n      }\r\n\r\n      // Подсчитываем количество изменений по количеству совпадений\r\n      const matches = text.match(pattern);\r\n      if (matches) {\r\n        removedCount += matches.length;\r\n      }\r\n    }\r\n\r\n    return {\r\n      text: processedText,\r\n      removedCount\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Нормализация пробельных символов\r\n   *\r\n   * @param text - Исходный текст\r\n   * @returns Нормализованный текст\r\n   */\r\n  private normalizeWhitespace(text: string): string {\r\n    return text\r\n      // Заменяем множественные пробелы на одинарные\r\n      .replace(TextProcessor.MULTIPLE_WHITESPACE_REGEX, ' ')\r\n      // Удаляем пробелы в начале и конце\r\n      .trim();\r\n  }\r\n\r\n  /**\r\n   * Удаление специальных символов\r\n   *\r\n   * @param text - Исходный текст\r\n   * @returns Очищенный текст\r\n   */\r\n  private removeSpecialCharacters(text: string): string {\r\n    return text.replace(TextProcessor.SPECIAL_CHARS_REGEX, ' ');\r\n  }\r\n\r\n  /**\r\n   * Обрезка текста до заданных лимитов\r\n   *\r\n   * @param text - Исходный текст\r\n   * @param options - Опции обрезки\r\n   * @returns Результат обрезки\r\n   */\r\n  private truncateText(\r\n    text: string,\r\n    options: TruncationOptions = {}\r\n  ): { text: string; wasTruncated: boolean } {\r\n    const {\r\n      maxCharacters,\r\n      maxTokens,\r\n      strategy = 'tail',\r\n      preserveWordBoundaries = true,\r\n      addTruncationIndicator = false,\r\n      truncationIndicator = '...'\r\n    } = options;\r\n\r\n    // Определяем максимальную длину\r\n    let maxLength = text.length;\r\n\r\n    if (maxCharacters !== undefined) {\r\n      maxLength = Math.min(maxLength, maxCharacters);\r\n    }\r\n\r\n    if (maxTokens !== undefined) {\r\n      const maxCharsFromTokens = maxTokens * TextProcessor.CHARS_PER_TOKEN;\r\n      maxLength = Math.min(maxLength, maxCharsFromTokens);\r\n    }\r\n\r\n    // Если текст не нужно обрезать\r\n    if (text.length <= maxLength) {\r\n      return { text, wasTruncated: false };\r\n    }\r\n\r\n    // Резервируем место для индикатора обрезки\r\n    const indicatorLength = addTruncationIndicator ? truncationIndicator.length : 0;\r\n    const targetLength = maxLength - indicatorLength;\r\n\r\n    if (targetLength <= 0) {\r\n      return { text: truncationIndicator, wasTruncated: true };\r\n    }\r\n\r\n    let truncatedText: string;\r\n\r\n    switch (strategy) {\r\n      case 'head':\r\n        truncatedText = text.substring(0, targetLength);\r\n        break;\r\n\r\n      case 'middle':\r\n        const halfLength = Math.floor(targetLength / 2);\r\n        const startPart = text.substring(0, halfLength);\r\n        const endPart = text.substring(text.length - halfLength);\r\n        truncatedText = startPart + endPart;\r\n        break;\r\n\r\n      case 'tail':\r\n      default:\r\n        truncatedText = text.substring(0, targetLength);\r\n        break;\r\n    }\r\n\r\n    // Сохранение границ слов\r\n    if (preserveWordBoundaries && truncatedText.length > 0) {\r\n      // Ищем последний пробел\r\n      const lastSpaceIndex = truncatedText.lastIndexOf(' ');\r\n      if (lastSpaceIndex > targetLength * 0.8) { // Не обрезаем слишком много\r\n        truncatedText = truncatedText.substring(0, lastSpaceIndex);\r\n      }\r\n    }\r\n\r\n    // Добавление индикатора обрезки\r\n    if (addTruncationIndicator) {\r\n      if (strategy === 'middle') {\r\n        const halfLength = Math.floor(truncatedText.length / 2);\r\n        truncatedText = truncatedText.substring(0, halfLength) +\r\n                       truncationIndicator +\r\n                       truncatedText.substring(halfLength);\r\n      } else {\r\n        truncatedText += truncationIndicator;\r\n      }\r\n    }\r\n\r\n    return { text: truncatedText, wasTruncated: true };\r\n  }\r\n\r\n  /**\r\n   * Валидация входного текста\r\n   *\r\n   * @param text - Текст для валидации\r\n   * @throws {ValidationError} При невалидном тексте\r\n   */\r\n  private validateInput(text: string): void {\r\n    if (typeof text !== 'string') {\r\n      throw new ValidationError(\r\n        'Input must be a string',\r\n        'text',\r\n        'typeof text === \"string\"'\r\n      );\r\n    }\r\n\r\n    if (text.length === 0) {\r\n      throw new ValidationError(\r\n        'Input text cannot be empty',\r\n        'text',\r\n        'text.length > 0'\r\n      );\r\n    }\r\n\r\n    if (text.length > 1000000) { // 1MB символов\r\n      throw new ValidationError(\r\n        'Input text is too large (max 1M characters)',\r\n        'text',\r\n        'text.length <= 1000000'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обновление статистики обработки\r\n   *\r\n   * @param originalLength - Исходная длина текста\r\n   * @param processedLength - Длина после обработки\r\n   * @param processingTime - Время обработки в миллисекундах\r\n   * @param wasTruncated - Был ли текст обрезан\r\n   */\r\n  private updateStatistics(\r\n    originalLength: number,\r\n    processedLength: number,\r\n    processingTime: number,\r\n    wasTruncated: boolean\r\n  ): void {\r\n    const totalTime = this.statistics.averageProcessingTime * this.statistics.totalProcessed;\r\n    const totalOriginalLength = this.statistics.averageOriginalLength * this.statistics.totalProcessed;\r\n    const totalProcessedLength = this.statistics.averageProcessedLength * this.statistics.totalProcessed;\r\n\r\n    this.statistics.totalProcessed += 1;\r\n    this.statistics.averageProcessingTime = (totalTime + processingTime) / this.statistics.totalProcessed;\r\n    this.statistics.averageOriginalLength = (totalOriginalLength + originalLength) / this.statistics.totalProcessed;\r\n    this.statistics.averageProcessedLength = (totalProcessedLength + processedLength) / this.statistics.totalProcessed;\r\n\r\n    if (wasTruncated) {\r\n      this.statistics.truncatedCount += 1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение статистики обработки\r\n   *\r\n   * @returns Текущая статистика\r\n   */\r\n  public getStatistics(): ProcessingStatistics {\r\n    return { ...this.statistics };\r\n  }\r\n\r\n  /**\r\n   * Сброс статистики обработки\r\n   */\r\n  public resetStatistics(): void {\r\n    this.statistics = {\r\n      totalProcessed: 0,\r\n      averageProcessingTime: 0,\r\n      truncatedCount: 0,\r\n      averageOriginalLength: 0,\r\n      averageProcessedLength: 0,\r\n      resetTime: new Date()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Обновление конфигурации обработки\r\n   *\r\n   * @param newConfig - Новая конфигурация\r\n   */\r\n  public updateConfig(newConfig: Partial<TextPreprocessingConfig>): void {\r\n    this.config = { ...this.config, ...newConfig };\r\n  }\r\n\r\n  /**\r\n   * Получение текущей конфигурации\r\n   *\r\n   * @returns Текущая конфигурация\r\n   */\r\n  public getConfig(): TextPreprocessingConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Оценка количества токенов в тексте\r\n   *\r\n   * @param text - Текст для оценки\r\n   * @returns Приблизительное количество токенов\r\n   */\r\n  public static estimateTokens(text: string): number {\r\n    return Math.ceil(text.length / TextProcessor.CHARS_PER_TOKEN);\r\n  }\r\n\r\n  /**\r\n   * Проверка, нужна ли предобработка для данного текста\r\n   *\r\n   * @param text - Текст для проверки\r\n   * @param config - Конфигурация предобработки\r\n   * @returns true, если предобработка может изменить текст\r\n   */\r\n  public static needsPreprocessing(text: string, config: TextPreprocessingConfig): boolean {\r\n    if (config.stripHtml && (TextProcessor.HTML_TAG_REGEX.test(text) || TextProcessor.HTML_ENTITY_REGEX.test(text))) {\r\n      return true;\r\n    }\r\n\r\n    if (config.stripMarkdown) {\r\n      for (const { pattern } of TextProcessor.MARKDOWN_PATTERNS) {\r\n        if (pattern.test(text)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (config.normalizeWhitespace && TextProcessor.MULTIPLE_WHITESPACE_REGEX.test(text)) {\r\n      return true;\r\n    }\r\n\r\n    if (config.toLowerCase && text !== text.toLowerCase()) {\r\n      return true;\r\n    }\r\n\r\n    if (config.removeSpecialChars && TextProcessor.SPECIAL_CHARS_REGEX.test(text)) {\r\n      return true;\r\n    }\r\n\r\n    if (config.maxLength && text.length > config.maxLength) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Быстрая очистка текста с минимальными операциями\r\n   *\r\n   * @param text - Исходный текст\r\n   * @returns Быстро очищенный текст\r\n   */\r\n  public static quickClean(text: string): string {\r\n    return text\r\n      .replace(TextProcessor.HTML_TAG_REGEX, ' ')\r\n      .replace(TextProcessor.HTML_ENTITY_REGEX, ' ')\r\n      .replace(TextProcessor.MULTIPLE_WHITESPACE_REGEX, ' ')\r\n      .trim();\r\n  }\r\n}","/**\r\n * Утилиты для системы эмбеддингов LocalRetrieve\r\n *\r\n * Данный модуль предоставляет вспомогательные функции для работы с эмбеддингами,\r\n * включая хеширование, валидацию, конвертацию данных и другие служебные операции.\r\n */\r\n\r\nimport type { CollectionEmbeddingConfig, EmbeddingConfig, Collection } from './types.js';\r\nimport { ValidationError, EmbeddingError } from './errors.js';\r\n\r\n/**\r\n * Результат хеширования\r\n */\r\nexport interface HashResult {\r\n  /** Хеш в виде hex строки */\r\n  hash: string;\r\n\r\n  /** Алгоритм хеширования */\r\n  algorithm: string;\r\n\r\n  /** Время создания хеша */\r\n  timestamp: Date;\r\n\r\n  /** Входные данные для хеширования (для отладки) */\r\n  input?: any;\r\n}\r\n\r\n/**\r\n * Опции для генерации хеша\r\n */\r\nexport interface HashOptions {\r\n  /** Алгоритм хеширования */\r\n  algorithm?: 'SHA-256' | 'SHA-1' | 'MD5';\r\n\r\n  /** Включать ли timestamp в хеш */\r\n  includeTimestamp?: boolean;\r\n\r\n  /** Дополнительный salt для хеширования */\r\n  salt?: string;\r\n\r\n  /** Включать ли отладочную информацию */\r\n  includeDebugInfo?: boolean;\r\n}\r\n\r\n/**\r\n * Конфигурация для хеша кеша\r\n */\r\nexport interface CacheKeyConfig {\r\n  /** Текст для хеширования */\r\n  text: string;\r\n\r\n  /** Конфигурация коллекции */\r\n  collectionConfig?: CollectionEmbeddingConfig;\r\n\r\n  /** Глобальная конфигурация */\r\n  globalConfig?: EmbeddingConfig;\r\n\r\n  /** Дополнительные параметры */\r\n  additionalParams?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Результат валидации размерностей\r\n */\r\nexport interface DimensionValidationResult {\r\n  /** Валидны ли размерности */\r\n  isValid: boolean;\r\n\r\n  /** Ожидаемая размерность */\r\n  expectedDimensions: number;\r\n\r\n  /** Фактическая размерность */\r\n  actualDimensions: number;\r\n\r\n  /** Сообщение об ошибке */\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Метаданные производительности\r\n */\r\nexport interface PerformanceMetrics {\r\n  /** Время начала операции */\r\n  startTime: number;\r\n\r\n  /** Время окончания операции */\r\n  endTime?: number;\r\n\r\n  /** Длительность в миллисекундах */\r\n  duration?: number;\r\n\r\n  /** Название операции */\r\n  operation: string;\r\n\r\n  /** Дополнительные данные */\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Основной класс утилит для эмбеддингов\r\n */\r\nexport class EmbeddingUtils {\r\n  /** Кеш для часто используемых хешей */\r\n  private static hashCache = new Map<string, HashResult>();\r\n\r\n  /** Максимальный размер кеша хешей */\r\n  private static readonly MAX_HASH_CACHE_SIZE = 1000;\r\n\r\n  /**\r\n   * Генерация стабильного хеша для ключа кеша\r\n   *\r\n   * @param config - Конфигурация для генерации ключа\r\n   * @param options - Опции хеширования\r\n   * @returns Результат хеширования\r\n   */\r\n  public static async generateCacheKey(\r\n    config: CacheKeyConfig,\r\n    options: HashOptions = {}\r\n  ): Promise<HashResult> {\r\n    const {\r\n      algorithm = 'SHA-256',\r\n      includeTimestamp = false,\r\n      salt = '',\r\n      includeDebugInfo = false\r\n    } = options;\r\n\r\n    // Создаем стабильный объект для хеширования\r\n    const hashInput: {\r\n      text: string;\r\n      provider?: string;\r\n      model?: string;\r\n      dimensions?: number;\r\n      textPreprocessing?: any;\r\n      additionalParams?: Record<string, any>;\r\n      salt: string;\r\n      timestamp?: number;\r\n    } = {\r\n      text: config.text,\r\n      provider: config.collectionConfig?.provider || config.globalConfig?.defaultProvider,\r\n      model: config.collectionConfig?.model || config.globalConfig?.defaultModel,\r\n      dimensions: config.collectionConfig?.dimensions || config.globalConfig?.defaultDimensions,\r\n      textPreprocessing: config.collectionConfig?.textPreprocessing,\r\n      additionalParams: config.additionalParams,\r\n      salt\r\n    };\r\n\r\n    if (includeTimestamp) {\r\n      hashInput.timestamp = Date.now();\r\n    }\r\n\r\n    // Сортируем ключи для стабильности\r\n    const sortedInput = EmbeddingUtils.sortObjectKeys(hashInput);\r\n    const inputString = JSON.stringify(sortedInput);\r\n\r\n    // Проверяем кеш\r\n    const cacheKey = `${algorithm}:${inputString}`;\r\n    if (EmbeddingUtils.hashCache.has(cacheKey)) {\r\n      return EmbeddingUtils.hashCache.get(cacheKey)!;\r\n    }\r\n\r\n    // Генерируем хеш\r\n    const hash = await EmbeddingUtils.hashString(inputString, algorithm);\r\n\r\n    const result: HashResult = {\r\n      hash,\r\n      algorithm,\r\n      timestamp: new Date(),\r\n      input: includeDebugInfo ? sortedInput : undefined\r\n    };\r\n\r\n    // Сохраняем в кеш\r\n    EmbeddingUtils.addToHashCache(cacheKey, result);\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Генерация хеша текста с учетом предобработки\r\n   *\r\n   * @param text - Исходный текст\r\n   * @param processingConfig - Конфигурация предобработки\r\n   * @param options - Опции хеширования\r\n   * @returns Результат хеширования\r\n   */\r\n  public static async generateTextHash(\r\n    text: string,\r\n    processingConfig?: any, // Избегаем циклической зависимости\r\n    options: HashOptions = {}\r\n  ): Promise<HashResult> {\r\n    const config: CacheKeyConfig = {\r\n      text,\r\n      additionalParams: {\r\n        textPreprocessing: processingConfig\r\n      }\r\n    };\r\n\r\n    return EmbeddingUtils.generateCacheKey(config, options);\r\n  }\r\n\r\n  /**\r\n   * Хеширование строки с использованием Web Crypto API\r\n   *\r\n   * @param input - Строка для хеширования\r\n   * @param algorithm - Алгоритм хеширования\r\n   * @returns Хеш в виде hex строки\r\n   */\r\n  public static async hashString(input: string, algorithm: string = 'SHA-256'): Promise<string> {\r\n    // Проверяем поддержку Web Crypto API\r\n    if (typeof crypto === 'undefined' || !crypto.subtle) {\r\n      // Fallback для старых браузеров\r\n      return EmbeddingUtils.simpleHash(input);\r\n    }\r\n\r\n    try {\r\n      const encoder = new TextEncoder();\r\n      const data = encoder.encode(input);\r\n      const hashBuffer = await crypto.subtle.digest(algorithm, data);\r\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\r\n    } catch (error) {\r\n      // Fallback в случае ошибки\r\n      console.warn('Web Crypto API failed, using simple hash:', error);\r\n      return EmbeddingUtils.simpleHash(input);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Простой хеш для fallback (djb2 algorithm)\r\n   *\r\n   * @param input - Строка для хеширования\r\n   * @returns Хеш в виде hex строки\r\n   */\r\n  private static simpleHash(input: string): string {\r\n    let hash = 5381;\r\n    for (let i = 0; i < input.length; i++) {\r\n      hash = ((hash << 5) + hash) + input.charCodeAt(i);\r\n    }\r\n    return Math.abs(hash).toString(16);\r\n  }\r\n\r\n  /**\r\n   * Синхронная генерация хеша для текста\r\n   *\r\n   * @param text - Текст для хеширования\r\n   * @param options - Опции хеширования\r\n   * @returns Результат хеширования\r\n   */\r\n  public static hashText(text: string, options: { algorithm?: string } = {}): HashResult {\r\n    const algorithm = options.algorithm === 'simple' ? 'simple' : 'djb2';\r\n    const hash = EmbeddingUtils.simpleHash(text);\r\n\r\n    return {\r\n      hash,\r\n      algorithm,\r\n      timestamp: new Date()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Сортировка ключей объекта для стабильного хеширования\r\n   *\r\n   * @param obj - Объект для сортировки\r\n   * @returns Объект с отсортированными ключами\r\n   */\r\n  private static sortObjectKeys(obj: any): any {\r\n    if (obj === null || typeof obj !== 'object') {\r\n      return obj;\r\n    }\r\n\r\n    if (Array.isArray(obj)) {\r\n      return obj.map(item => EmbeddingUtils.sortObjectKeys(item));\r\n    }\r\n\r\n    const sortedKeys = Object.keys(obj).sort();\r\n    const sortedObj: any = {};\r\n\r\n    for (const key of sortedKeys) {\r\n      sortedObj[key] = EmbeddingUtils.sortObjectKeys(obj[key]);\r\n    }\r\n\r\n    return sortedObj;\r\n  }\r\n\r\n  /**\r\n   * Добавление результата в кеш хешей\r\n   *\r\n   * @param key - Ключ кеша\r\n   * @param result - Результат хеширования\r\n   */\r\n  private static addToHashCache(key: string, result: HashResult): void {\r\n    // Очищаем кеш если он переполнен\r\n    if (EmbeddingUtils.hashCache.size >= EmbeddingUtils.MAX_HASH_CACHE_SIZE) {\r\n      const firstKey = EmbeddingUtils.hashCache.keys().next().value;\r\n      if (firstKey !== undefined) {\r\n        EmbeddingUtils.hashCache.delete(firstKey);\r\n      }\r\n    }\r\n\r\n    EmbeddingUtils.hashCache.set(key, result);\r\n  }\r\n\r\n  /**\r\n   * Очистка кеша хешей\r\n   */\r\n  public static clearHashCache(): void {\r\n    EmbeddingUtils.hashCache.clear();\r\n  }\r\n\r\n  /**\r\n   * Валидация размерностей эмбеддинга\r\n   *\r\n   * @param embedding - Вектор эмбеддинга\r\n   * @param expectedDimensions - Ожидаемая размерность\r\n   * @returns Результат валидации\r\n   */\r\n  public static validateEmbeddingDimensions(\r\n    embedding: Float32Array | number[],\r\n    expectedDimensions: number\r\n  ): DimensionValidationResult {\r\n    const actualDimensions = embedding.length;\r\n    const isValid = actualDimensions === expectedDimensions;\r\n\r\n    return {\r\n      isValid,\r\n      expectedDimensions,\r\n      actualDimensions,\r\n      error: isValid ? undefined : `Expected ${expectedDimensions} dimensions, got ${actualDimensions}`\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации коллекции\r\n   *\r\n   * @param config - Конфигурация коллекции\r\n   * @throws {ValidationError} При невалидной конфигурации\r\n   */\r\n  public static validateCollectionConfig(config: CollectionEmbeddingConfig): void {\r\n    if (!config.provider) {\r\n      throw new ValidationError(\r\n        'Provider is required in collection config',\r\n        'provider',\r\n        'must be specified'\r\n      );\r\n    }\r\n\r\n    if (!config.dimensions || config.dimensions <= 0) {\r\n      throw new ValidationError(\r\n        'Dimensions must be a positive number',\r\n        'dimensions',\r\n        'dimensions > 0'\r\n      );\r\n    }\r\n\r\n    // Проверяем поддерживаемые размерности\r\n    const supportedDimensions = [384, 512, 768, 1024, 1536, 3072];\r\n    if (!supportedDimensions.includes(config.dimensions)) {\r\n      throw new ValidationError(\r\n        `Unsupported dimensions: ${config.dimensions}. Supported: ${supportedDimensions.join(', ')}`,\r\n        'dimensions',\r\n        `one of: ${supportedDimensions.join(', ')}`\r\n      );\r\n    }\r\n\r\n    if (config.batchSize && (config.batchSize <= 0 || config.batchSize > 1000)) {\r\n      throw new ValidationError(\r\n        'Batch size must be between 1 and 1000',\r\n        'batchSize',\r\n        '1 <= batchSize <= 1000'\r\n      );\r\n    }\r\n\r\n    if (config.timeout && config.timeout < 1000) {\r\n      throw new ValidationError(\r\n        'Timeout must be at least 1000ms',\r\n        'timeout',\r\n        'timeout >= 1000'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Конвертация массива чисел в Float32Array\r\n   *\r\n   * @param array - Массив чисел\r\n   * @returns Float32Array\r\n   */\r\n  public static toFloat32Array(array: number[] | Float32Array): Float32Array {\r\n    if (array instanceof Float32Array) {\r\n      return array;\r\n    }\r\n\r\n    if (Array.isArray(array)) {\r\n      return new Float32Array(array);\r\n    }\r\n\r\n    throw new ValidationError(\r\n      'Input must be an array of numbers or Float32Array',\r\n      'array',\r\n      'Array<number> | Float32Array'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Создание глубокой копии объекта\r\n   *\r\n   * @param obj - Объект для копирования\r\n   * @returns Глубокая копия объекта\r\n   */\r\n  public static deepClone<T>(obj: T): T {\r\n    if (obj === null || typeof obj !== 'object') {\r\n      return obj;\r\n    }\r\n\r\n    if (obj instanceof Date) {\r\n      return new Date(obj.getTime()) as unknown as T;\r\n    }\r\n\r\n    if (obj instanceof Array) {\r\n      return obj.map(item => EmbeddingUtils.deepClone(item)) as unknown as T;\r\n    }\r\n\r\n    if (obj instanceof Float32Array) {\r\n      return new Float32Array(obj) as unknown as T;\r\n    }\r\n\r\n    if (typeof obj === 'object') {\r\n      const copy = {} as { [K in keyof T]: T[K] };\r\n      for (const key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n          copy[key] = EmbeddingUtils.deepClone(obj[key]);\r\n        }\r\n      }\r\n      return copy;\r\n    }\r\n\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * Слияние конфигураций с приоритетом\r\n   *\r\n   * @param base - Базовая конфигурация\r\n   * @param override - Переопределяющая конфигурация\r\n   * @returns Объединенная конфигурация\r\n   */\r\n  public static mergeConfigs<T extends Record<string, any>>(\r\n    base: Partial<T>,\r\n    override: Partial<T>\r\n  ): T {\r\n    const result = EmbeddingUtils.deepClone(base) as T;\r\n\r\n    for (const key in override) {\r\n      if (override.hasOwnProperty(key)) {\r\n        const overrideValue = override[key];\r\n        if (overrideValue !== undefined) {\r\n          if (typeof overrideValue === 'object' && !Array.isArray(overrideValue) && overrideValue !== null) {\r\n            // Рекурсивное слияние для объектов\r\n            (result as any)[key] = EmbeddingUtils.mergeConfigs(\r\n              ((result as any)[key] as Record<string, any>) || {},\r\n              overrideValue as Record<string, any>\r\n            );\r\n          } else {\r\n            // Прямое переопределение для примитивов и массивов\r\n            (result as any)[key] = overrideValue;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Форматирование размера в человеко-читаемый формат\r\n   *\r\n   * @param bytes - Размер в байтах\r\n   * @returns Отформатированная строка\r\n   */\r\n  public static formatBytes(bytes: number): string {\r\n    if (bytes === 0) return '0 Bytes';\r\n\r\n    const k = 1024;\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n\r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\r\n  }\r\n\r\n  /**\r\n   * Форматирование времени в человеко-читаемый формат\r\n   *\r\n   * @param milliseconds - Время в миллисекундах\r\n   * @returns Отформатированная строка\r\n   */\r\n  public static formatDuration(milliseconds: number): string {\r\n    if (milliseconds < 1000) {\r\n      return `${Math.round(milliseconds)}ms`;\r\n    }\r\n\r\n    const seconds = milliseconds / 1000;\r\n    if (seconds < 60) {\r\n      return `${seconds.toFixed(2)}s`;\r\n    }\r\n\r\n    const minutes = seconds / 60;\r\n    if (minutes < 60) {\r\n      return `${minutes.toFixed(2)}m`;\r\n    }\r\n\r\n    const hours = minutes / 60;\r\n    return `${hours.toFixed(2)}h`;\r\n  }\r\n\r\n  /**\r\n   * Создание таймера производительности\r\n   *\r\n   * @param operation - Название операции\r\n   * @returns Объект для измерения производительности\r\n   */\r\n  public static createPerformanceTimer(operation: string): PerformanceMetrics {\r\n    return {\r\n      startTime: performance.now(),\r\n      operation,\r\n      metadata: {}\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Завершение измерения производительности\r\n   *\r\n   * @param timer - Объект таймера\r\n   * @returns Завершенные метрики\r\n   */\r\n  public static finishPerformanceTimer(timer: PerformanceMetrics): PerformanceMetrics {\r\n    const endTime = performance.now();\r\n    return {\r\n      ...timer,\r\n      endTime,\r\n      duration: endTime - timer.startTime\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки Web Workers\r\n   *\r\n   * @returns true, если Web Workers поддерживаются\r\n   */\r\n  public static supportsWebWorkers(): boolean {\r\n    return typeof Worker !== 'undefined';\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки SharedArrayBuffer\r\n   *\r\n   * @returns true, если SharedArrayBuffer поддерживается\r\n   */\r\n  public static supportsSharedArrayBuffer(): boolean {\r\n    return typeof SharedArrayBuffer !== 'undefined';\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки OPFS (Origin Private File System)\r\n   *\r\n   * @returns Promise<boolean> - true, если OPFS поддерживается\r\n   */\r\n  public static async supportsOPFS(): Promise<boolean> {\r\n    try {\r\n      if ('storage' in navigator && 'getDirectory' in navigator.storage) {\r\n        await navigator.storage.getDirectory();\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение информации о браузере\r\n   *\r\n   * @returns Информация о возможностях браузера\r\n   */\r\n  public static async getBrowserCapabilities(): Promise<{\r\n    webWorkers: boolean;\r\n    sharedArrayBuffer: boolean;\r\n    opfs: boolean;\r\n    webCrypto: boolean;\r\n    userAgent: string;\r\n  }> {\r\n    return {\r\n      webWorkers: EmbeddingUtils.supportsWebWorkers(),\r\n      sharedArrayBuffer: EmbeddingUtils.supportsSharedArrayBuffer(),\r\n      opfs: await EmbeddingUtils.supportsOPFS(),\r\n      webCrypto: typeof crypto !== 'undefined' && !!crypto.subtle,\r\n      userAgent: navigator.userAgent\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Генерация уникального ID\r\n   *\r\n   * @param prefix - Префикс для ID\r\n   * @returns Уникальный идентификатор\r\n   */\r\n  public static generateId(prefix: string = 'emb'): string {\r\n    const timestamp = Date.now().toString(36);\r\n    const random = Math.random().toString(36).substring(2);\r\n    return `${prefix}_${timestamp}_${random}`;\r\n  }\r\n\r\n  /**\r\n   * Безопасное парсинг JSON с обработкой ошибок\r\n   *\r\n   * @param jsonString - JSON строка\r\n   * @param defaultValue - Значение по умолчанию при ошибке\r\n   * @returns Распарсенный объект или значение по умолчанию\r\n   */\r\n  public static safeJsonParse<T>(jsonString: string, defaultValue: T): T {\r\n    try {\r\n      return JSON.parse(jsonString) as T;\r\n    } catch {\r\n      return defaultValue;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Безопасная сериализация в JSON\r\n   *\r\n   * @param value - Значение для сериализации\r\n   * @param defaultValue - Значение по умолчанию при ошибке\r\n   * @returns JSON строка или значение по умолчанию\r\n   */\r\n  public static safeJsonStringify(value: any, defaultValue: string = '{}'): string {\r\n    try {\r\n      return JSON.stringify(value);\r\n    } catch {\r\n      return defaultValue;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Задержка выполнения\r\n   *\r\n   * @param milliseconds - Время задержки в миллисекундах\r\n   * @returns Promise, который разрешается через указанное время\r\n   */\r\n  public static delay(milliseconds: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, milliseconds));\r\n  }\r\n\r\n  /**\r\n   * Дебаунс функции\r\n   *\r\n   * @param func - Функция для дебаунса\r\n   * @param delay - Задержка в миллисекундах\r\n   * @returns Дебаунсированная функция\r\n   */\r\n  public static debounce<T extends (...args: any[]) => any>(\r\n    func: T,\r\n    delay: number\r\n  ): (...args: Parameters<T>) => void {\r\n    let timeoutId: NodeJS.Timeout | number;\r\n\r\n    return (...args: Parameters<T>) => {\r\n      clearTimeout(timeoutId);\r\n      timeoutId = setTimeout(() => func(...args), delay);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Троттлинг функции\r\n   *\r\n   * @param func - Функция для троттлинга\r\n   * @param limit - Минимальный интервал между вызовами в миллисекундах\r\n   * @returns Троттлированная функция\r\n   */\r\n  public static throttle<T extends (...args: any[]) => any>(\r\n    func: T,\r\n    limit: number\r\n  ): (...args: Parameters<T>) => void {\r\n    let inThrottle = false;\r\n\r\n    return (...args: Parameters<T>) => {\r\n      if (!inThrottle) {\r\n        func(...args);\r\n        inThrottle = true;\r\n        setTimeout(() => inThrottle = false, limit);\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Константы для системы эмбеддингов\r\n */\r\nexport const EmbeddingConstants = {\r\n  /** Поддерживаемые размерности векторов */\r\n  SUPPORTED_DIMENSIONS: [384, 512, 768, 1024, 1536, 3072] as const,\r\n\r\n  /** Размеры батчей по умолчанию для разных провайдеров */\r\n  DEFAULT_BATCH_SIZES: {\r\n    transformers: 16,\r\n    openai: 100,\r\n    cohere: 100,\r\n    huggingface: 32,\r\n    custom: 32\r\n  } as const,\r\n\r\n  /** Таймауты по умолчанию (в миллисекундах) */\r\n  DEFAULT_TIMEOUTS: {\r\n    local: 30000,    // 30 секунд для локальных моделей\r\n    api: 60000,      // 60 секунд для API\r\n    initialization: 120000 // 2 минуты для инициализации\r\n  } as const,\r\n\r\n  /** Максимальные размеры текста для разных провайдеров */\r\n  MAX_TEXT_LENGTHS: {\r\n    transformers: 512,\r\n    openai: 8192,\r\n    cohere: 2048,\r\n    huggingface: 512,\r\n    custom: 512\r\n  } as const,\r\n\r\n  /** Соотношение символов к токенам для разных языков */\r\n  CHARS_PER_TOKEN: {\r\n    english: 4,\r\n    russian: 3,\r\n    chinese: 1.5,\r\n    default: 4\r\n  } as const,\r\n\r\n  /** Алгоритмы хеширования */\r\n  HASH_ALGORITHMS: ['SHA-256', 'SHA-1', 'MD5'] as const,\r\n\r\n  /** Версия схемы конфигурации */\r\n  CONFIG_SCHEMA_VERSION: '1.0.0'\r\n} as const;\r\n\r\n/**\r\n * Типы для константы\r\n */\r\nexport type SupportedDimensions = typeof EmbeddingConstants.SUPPORTED_DIMENSIONS[number];\r\nexport type ProviderType = keyof typeof EmbeddingConstants.DEFAULT_BATCH_SIZES;\r\nexport type HashAlgorithm = typeof EmbeddingConstants.HASH_ALGORITHMS[number];\r\n\r\n/**\r\n * Вспомогательные функции для работы с коллекциями\r\n */\r\nexport class CollectionUtils {\r\n  /**\r\n   * Генерация имени таблицы векторов для коллекции\r\n   *\r\n   * @param collectionId - ID коллекции\r\n   * @param dimensions - Размерность векторов\r\n   * @returns Имя таблицы векторов\r\n   */\r\n  public static generateVectorTableName(collectionId: string, dimensions: number): string {\r\n    return `vec_${collectionId}_${dimensions}d`;\r\n  }\r\n\r\n  /**\r\n   * Валидация ID коллекции\r\n   *\r\n   * @param collectionId - ID коллекции для валидации\r\n   * @throws {ValidationError} При невалидном ID\r\n   */\r\n  public static validateCollectionId(collectionId: string): void {\r\n    if (!collectionId || typeof collectionId !== 'string') {\r\n      throw new ValidationError(\r\n        'Collection ID must be a non-empty string',\r\n        'collectionId',\r\n        'non-empty string'\r\n      );\r\n    }\r\n\r\n    // Проверяем формат ID (только буквы, цифры, подчеркивания и дефисы)\r\n    const validIdPattern = /^[a-zA-Z0-9_-]+$/;\r\n    if (!validIdPattern.test(collectionId)) {\r\n      throw new ValidationError(\r\n        'Collection ID can only contain letters, numbers, underscores and hyphens',\r\n        'collectionId',\r\n        'matching pattern: /^[a-zA-Z0-9_-]+$/'\r\n      );\r\n    }\r\n\r\n    if (collectionId.length > 50) {\r\n      throw new ValidationError(\r\n        'Collection ID cannot be longer than 50 characters',\r\n        'collectionId',\r\n        'length <= 50'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Создание конфигурации коллекции по умолчанию\r\n   *\r\n   * @param provider - Тип провайдера\r\n   * @param dimensions - Размерность векторов\r\n   * @returns Конфигурация коллекции по умолчанию\r\n   */\r\n  public static createDefaultCollectionConfig(\r\n    provider: ProviderType,\r\n    dimensions: SupportedDimensions\r\n  ): CollectionEmbeddingConfig {\r\n    return {\r\n      provider,\r\n      dimensions,\r\n      batchSize: EmbeddingConstants.DEFAULT_BATCH_SIZES[provider],\r\n      cacheEnabled: true,\r\n      timeout: provider === 'transformers'\r\n        ? EmbeddingConstants.DEFAULT_TIMEOUTS.local\r\n        : EmbeddingConstants.DEFAULT_TIMEOUTS.api,\r\n      autoGenerate: false,\r\n      textPreprocessing: {\r\n        maxLength: EmbeddingConstants.MAX_TEXT_LENGTHS[provider],\r\n        stripHtml: true,\r\n        stripMarkdown: true,\r\n        normalizeWhitespace: true,\r\n        toLowerCase: false,\r\n        removeSpecialChars: false\r\n      }\r\n    };\r\n  }\r\n}","/**\r\n * Простая система кэширования эмбеддингов в памяти для LocalRetrieve\r\n *\r\n * Данный модуль реализует LRU (Least Recently Used) кэш для хранения\r\n * сгенерированных эмбеддингов в памяти. Кэш помогает избежать повторной\r\n * генерации одинаковых эмбеддингов для текста с одинаковой конфигурацией.\r\n */\r\n\r\nimport type { CollectionEmbeddingConfig, EmbeddingConfig } from '../types.js';\r\nimport { EmbeddingUtils, type CacheKeyConfig, type HashResult } from '../utils.js';\r\nimport { EmbeddingError } from '../errors.js';\r\n\r\n/**\r\n * Элемент кэша эмбеддингов\r\n */\r\nexport interface CacheEntry {\r\n  /** Вектор эмбеддинга */\r\n  embedding: Float32Array;\r\n\r\n  /** Хеш ключа кэша */\r\n  keyHash: string;\r\n\r\n  /** Исходный текст (для отладки) */\r\n  text: string;\r\n\r\n  /** Размерность вектора */\r\n  dimensions: number;\r\n\r\n  /** Время создания записи */\r\n  createdAt: Date;\r\n\r\n  /** Время последнего доступа */\r\n  lastAccessedAt: Date;\r\n\r\n  /** Количество обращений к записи */\r\n  accessCount: number;\r\n\r\n  /** Размер в байтах (приблизительный) */\r\n  sizeBytes: number;\r\n\r\n  /** Метаданные провайдера */\r\n  providerMetadata?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Метрики производительности кэша\r\n */\r\nexport interface CacheMetrics {\r\n  /** Общее количество попыток доступа */\r\n  totalAccesses: number;\r\n\r\n  /** Количество попаданий в кэш */\r\n  hits: number;\r\n\r\n  /** Количество промахов кэша */\r\n  misses: number;\r\n\r\n  /** Количество вытесненных записей */\r\n  evictions: number;\r\n\r\n  /** Текущий размер кэша (количество записей) */\r\n  currentSize: number;\r\n\r\n  /** Максимальный размер кэша */\r\n  maxSize: number;\r\n\r\n  /** Общий размер в байтах */\r\n  totalSizeBytes: number;\r\n\r\n  /** Максимальный размер в байтах */\r\n  maxSizeBytes: number;\r\n\r\n  /** Коэффициент попаданий (0-1) */\r\n  hitRate: number;\r\n\r\n  /** Коэффициент промахов (0-1) */\r\n  missRate: number;\r\n\r\n  /** Время последнего сброса метрик */\r\n  lastResetAt: Date;\r\n\r\n  /** Время создания кэша */\r\n  createdAt: Date;\r\n}\r\n\r\n/**\r\n * Конфигурация кэша эмбеддингов\r\n */\r\nexport interface MemoryCacheConfig {\r\n  /** Максимальное количество записей в кэше */\r\n  maxEntries?: number;\r\n\r\n  /** Максимальный размер кэша в байтах */\r\n  maxSizeBytes?: number;\r\n\r\n  /** Включить ли детальное логирование */\r\n  enableLogging?: boolean;\r\n\r\n  /** Интервал автоматической очистки в миллисекундах */\r\n  cleanupIntervalMs?: number;\r\n\r\n  /** Максимальное время жизни записи в миллисекундах */\r\n  maxEntryAge?: number;\r\n\r\n  /** Включить ли сбор расширенных метрик */\r\n  enableDetailedMetrics?: boolean;\r\n}\r\n\r\n/**\r\n * Узел двусвязного списка для LRU алгоритма\r\n */\r\nclass LRUNode {\r\n  constructor(\r\n    public key: string,\r\n    public entry: CacheEntry,\r\n    public prev: LRUNode | null = null,\r\n    public next: LRUNode | null = null\r\n  ) {}\r\n}\r\n\r\n/**\r\n * Простая реализация LRU кэша для эмбеддингов в памяти\r\n *\r\n * Данный класс реализует кэш с алгоритмом вытеснения LRU (Least Recently Used).\r\n * Кэш автоматически удаляет наименее используемые записи при превышении\r\n * лимитов по количеству записей или размеру в байтах.\r\n */\r\nexport class MemoryCache {\r\n  /** Конфигурация кэша */\r\n  private readonly config: Required<MemoryCacheConfig>;\r\n\r\n  /** Основное хранилище записей кэша */\r\n  private readonly cache = new Map<string, LRUNode>();\r\n\r\n  /** Голова двусвязного списка (наиболее часто используемые) */\r\n  private head: LRUNode | null = null;\r\n\r\n  /** Хвост двусвязного списка (наименее часто используемые) */\r\n  private tail: LRUNode | null = null;\r\n\r\n  /** Метрики производительности кэша */\r\n  private metrics: CacheMetrics;\r\n\r\n  /** Таймер для автоматической очистки */\r\n  private cleanupTimer: NodeJS.Timeout | number | null = null;\r\n\r\n  /** Флаг состояния кэша */\r\n  private disposed = false;\r\n\r\n  /**\r\n   * Создание нового экземпляра кэша эмбеддингов\r\n   *\r\n   * @param config - Конфигурация кэша\r\n   */\r\n  constructor(config: MemoryCacheConfig = {}) {\r\n    // Заполняем конфигурацию значениями по умолчанию\r\n    this.config = {\r\n      maxEntries: config.maxEntries ?? 1000,\r\n      maxSizeBytes: config.maxSizeBytes ?? 50 * 1024 * 1024, // 50MB\r\n      enableLogging: config.enableLogging ?? false,\r\n      cleanupIntervalMs: config.cleanupIntervalMs ?? 5 * 60 * 1000, // 5 минут\r\n      maxEntryAge: config.maxEntryAge ?? 60 * 60 * 1000, // 1 час\r\n      enableDetailedMetrics: config.enableDetailedMetrics ?? true\r\n    };\r\n\r\n    // Инициализируем метрики\r\n    this.metrics = this.createInitialMetrics();\r\n\r\n    // Запускаем автоматическую очистку если настроена\r\n    if (this.config.cleanupIntervalMs > 0) {\r\n      this.startCleanupTimer();\r\n    }\r\n\r\n    if (this.config.enableLogging) {\r\n      console.log('[MemoryCache] Инициализирован с конфигурацией:', this.config);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение эмбеддинга из кэша\r\n   *\r\n   * @param text - Текст для поиска в кэше\r\n   * @param collectionConfig - Конфигурация коллекции\r\n   * @param globalConfig - Глобальная конфигурация\r\n   * @returns Эмбеддинг из кэша или null если не найден\r\n   */\r\n  public async get(\r\n    text: string,\r\n    collectionConfig?: CollectionEmbeddingConfig,\r\n    globalConfig?: EmbeddingConfig\r\n  ): Promise<Float32Array | null> {\r\n    this.ensureNotDisposed();\r\n\r\n    try {\r\n      // Генерируем ключ кэша\r\n      const cacheKeyConfig: CacheKeyConfig = {\r\n        text,\r\n        collectionConfig,\r\n        globalConfig\r\n      };\r\n\r\n      const hashResult = await EmbeddingUtils.generateCacheKey(cacheKeyConfig);\r\n      const cacheKey = hashResult.hash;\r\n\r\n      this.metrics.totalAccesses++;\r\n\r\n      // Ищем запись в кэше\r\n      const node = this.cache.get(cacheKey);\r\n      if (!node) {\r\n        this.metrics.misses++;\r\n        this.updateHitRate();\r\n\r\n        if (this.config.enableLogging) {\r\n          console.log(`[MemoryCache] Промах кэша для ключа: ${cacheKey.substring(0, 16)}...`);\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      // Обновляем статистику доступа\r\n      node.entry.lastAccessedAt = new Date();\r\n      node.entry.accessCount++;\r\n      this.metrics.hits++;\r\n      this.updateHitRate();\r\n\r\n      // Перемещаем узел в начало списка (делаем наиболее используемым)\r\n      this.moveToHead(node);\r\n\r\n      if (this.config.enableLogging) {\r\n        console.log(`[MemoryCache] Попадание в кэш для ключа: ${cacheKey.substring(0, 16)}...`);\r\n      }\r\n\r\n      return node.entry.embedding;\r\n    } catch (error) {\r\n      if (this.config.enableLogging) {\r\n        console.error('[MemoryCache] Ошибка при получении из кэша:', error);\r\n      }\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Сохранение эмбеддинга в кэш\r\n   *\r\n   * @param text - Исходный текст\r\n   * @param embedding - Вектор эмбеддинга\r\n   * @param collectionConfig - Конфигурация коллекции\r\n   * @param globalConfig - Глобальная конфигурация\r\n   * @param providerMetadata - Метаданные провайдера\r\n   */\r\n  public async set(\r\n    text: string,\r\n    embedding: Float32Array,\r\n    collectionConfig?: CollectionEmbeddingConfig,\r\n    globalConfig?: EmbeddingConfig,\r\n    providerMetadata?: Record<string, any>\r\n  ): Promise<void> {\r\n    this.ensureNotDisposed();\r\n\r\n    try {\r\n      // Генерируем ключ кэша\r\n      const cacheKeyConfig: CacheKeyConfig = {\r\n        text,\r\n        collectionConfig,\r\n        globalConfig\r\n      };\r\n\r\n      const hashResult = await EmbeddingUtils.generateCacheKey(cacheKeyConfig);\r\n      const cacheKey = hashResult.hash;\r\n\r\n      // Вычисляем размер записи в байтах\r\n      const sizeBytes = this.calculateEntrySize(text, embedding, providerMetadata);\r\n\r\n      // Проверяем, не превышает ли одна запись максимальный размер\r\n      if (sizeBytes > this.config.maxSizeBytes) {\r\n        if (this.config.enableLogging) {\r\n          console.warn('[MemoryCache] Запись слишком большая для кэширования:', sizeBytes);\r\n        }\r\n        return;\r\n      }\r\n\r\n      // Создаем новую запись\r\n      const entry: CacheEntry = {\r\n        embedding: new Float32Array(embedding), // Создаем копию\r\n        keyHash: cacheKey,\r\n        text,\r\n        dimensions: embedding.length,\r\n        createdAt: new Date(),\r\n        lastAccessedAt: new Date(),\r\n        accessCount: 1,\r\n        sizeBytes,\r\n        providerMetadata: providerMetadata ? { ...providerMetadata } : undefined\r\n      };\r\n\r\n      // Проверяем, существует ли уже запись с таким ключом\r\n      const existingNode = this.cache.get(cacheKey);\r\n      if (existingNode) {\r\n        // Обновляем существующую запись\r\n        this.metrics.totalSizeBytes -= existingNode.entry.sizeBytes;\r\n        existingNode.entry = entry;\r\n        this.metrics.totalSizeBytes += sizeBytes;\r\n        this.moveToHead(existingNode);\r\n\r\n        if (this.config.enableLogging) {\r\n          console.log(`[MemoryCache] Обновлена запись для ключа: ${cacheKey.substring(0, 16)}...`);\r\n        }\r\n        return;\r\n      }\r\n\r\n      // Освобождаем место в кэше если необходимо\r\n      this.evictIfNeeded(sizeBytes);\r\n\r\n      // Создаем новый узел и добавляем в кэш\r\n      const newNode = new LRUNode(cacheKey, entry);\r\n      this.cache.set(cacheKey, newNode);\r\n      this.addToHead(newNode);\r\n\r\n      // Обновляем метрики\r\n      this.metrics.currentSize = this.cache.size;\r\n      this.metrics.totalSizeBytes += sizeBytes;\r\n\r\n      if (this.config.enableLogging) {\r\n        console.log(`[MemoryCache] Добавлена новая запись для ключа: ${cacheKey.substring(0, 16)}...`);\r\n      }\r\n    } catch (error) {\r\n      if (this.config.enableLogging) {\r\n        console.error('[MemoryCache] Ошибка при сохранении в кэш:', error);\r\n      }\r\n      throw new EmbeddingError(\r\n        'Failed to save embedding to cache',\r\n        'CACHE_SAVE_ERROR',\r\n        'cache',\r\n        { originalError: error }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка наличия записи в кэше\r\n   *\r\n   * @param text - Текст для проверки\r\n   * @param collectionConfig - Конфигурация коллекции\r\n   * @param globalConfig - Глобальная конфигурация\r\n   * @returns true если запись найдена в кэше\r\n   */\r\n  public async has(\r\n    text: string,\r\n    collectionConfig?: CollectionEmbeddingConfig,\r\n    globalConfig?: EmbeddingConfig\r\n  ): Promise<boolean> {\r\n    this.ensureNotDisposed();\r\n\r\n    try {\r\n      const cacheKeyConfig: CacheKeyConfig = {\r\n        text,\r\n        collectionConfig,\r\n        globalConfig\r\n      };\r\n\r\n      const hashResult = await EmbeddingUtils.generateCacheKey(cacheKeyConfig);\r\n      return this.cache.has(hashResult.hash);\r\n    } catch (error) {\r\n      if (this.config.enableLogging) {\r\n        console.error('[MemoryCache] Ошибка при проверке наличия в кэше:', error);\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение метрик производительности кэша\r\n   *\r\n   * @returns Текущие метрики кэша\r\n   */\r\n  public getMetrics(): CacheMetrics {\r\n    this.ensureNotDisposed();\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  /**\r\n   * Сброс метрик производительности\r\n   */\r\n  public resetMetrics(): void {\r\n    this.ensureNotDisposed();\r\n\r\n    const currentSize = this.cache.size;\r\n    const currentSizeBytes = this.metrics.totalSizeBytes;\r\n\r\n    this.metrics = {\r\n      ...this.createInitialMetrics(),\r\n      currentSize,\r\n      totalSizeBytes: currentSizeBytes\r\n    };\r\n\r\n    if (this.config.enableLogging) {\r\n      console.log('[MemoryCache] Метрики сброшены');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Очистка всех записей из кэша\r\n   */\r\n  public clear(): void {\r\n    this.ensureNotDisposed();\r\n\r\n    this.cache.clear();\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.metrics.currentSize = 0;\r\n    this.metrics.totalSizeBytes = 0;\r\n\r\n    if (this.config.enableLogging) {\r\n      console.log('[MemoryCache] Кэш очищен');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ручная очистка устаревших записей\r\n   *\r\n   * @returns Количество удаленных записей\r\n   */\r\n  public cleanup(): number {\r\n    this.ensureNotDisposed();\r\n\r\n    const now = Date.now();\r\n    const maxAge = this.config.maxEntryAge;\r\n    let removedCount = 0;\r\n\r\n    // Проходим по всем записям и удаляем устаревшие\r\n    for (const [key, node] of this.cache.entries()) {\r\n      const age = now - node.entry.createdAt.getTime();\r\n      if (age > maxAge) {\r\n        this.removeNode(node);\r\n        this.cache.delete(key);\r\n        removedCount++;\r\n      }\r\n    }\r\n\r\n    // Обновляем метрики\r\n    this.metrics.currentSize = this.cache.size;\r\n    this.metrics.evictions += removedCount;\r\n\r\n    if (this.config.enableLogging && removedCount > 0) {\r\n      console.log(`[MemoryCache] Удалено ${removedCount} устаревших записей`);\r\n    }\r\n\r\n    return removedCount;\r\n  }\r\n\r\n  /**\r\n   * Получение информации о размере кэша\r\n   *\r\n   * @returns Информация о размере\r\n   */\r\n  public getSizeInfo(): {\r\n    entries: number;\r\n    maxEntries: number;\r\n    sizeBytes: number;\r\n    maxSizeBytes: number;\r\n    utilizationPercent: number;\r\n  } {\r\n    this.ensureNotDisposed();\r\n\r\n    const utilization = Math.max(\r\n      this.metrics.currentSize / this.config.maxEntries,\r\n      this.metrics.totalSizeBytes / this.config.maxSizeBytes\r\n    ) * 100;\r\n\r\n    return {\r\n      entries: this.metrics.currentSize,\r\n      maxEntries: this.config.maxEntries,\r\n      sizeBytes: this.metrics.totalSizeBytes,\r\n      maxSizeBytes: this.config.maxSizeBytes,\r\n      utilizationPercent: Math.round(utilization * 100) / 100\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Освобождение ресурсов кэша\r\n   */\r\n  public dispose(): void {\r\n    if (this.disposed) {\r\n      return;\r\n    }\r\n\r\n    // Останавливаем таймер очистки\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = null;\r\n    }\r\n\r\n    // Очищаем кэш\r\n    this.clear();\r\n\r\n    // Помечаем как освобожденный\r\n    this.disposed = true;\r\n\r\n    if (this.config.enableLogging) {\r\n      console.log('[MemoryCache] Ресурсы освобождены');\r\n    }\r\n  }\r\n\r\n  // === Приватные методы ===\r\n\r\n  /**\r\n   * Создание начальных метрик\r\n   */\r\n  private createInitialMetrics(): CacheMetrics {\r\n    const now = new Date();\r\n    return {\r\n      totalAccesses: 0,\r\n      hits: 0,\r\n      misses: 0,\r\n      evictions: 0,\r\n      currentSize: 0,\r\n      maxSize: this.config.maxEntries,\r\n      totalSizeBytes: 0,\r\n      maxSizeBytes: this.config.maxSizeBytes,\r\n      hitRate: 0,\r\n      missRate: 0,\r\n      lastResetAt: now,\r\n      createdAt: now\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Обновление коэффициентов попаданий и промахов\r\n   */\r\n  private updateHitRate(): void {\r\n    if (this.metrics.totalAccesses > 0) {\r\n      this.metrics.hitRate = this.metrics.hits / this.metrics.totalAccesses;\r\n      this.metrics.missRate = this.metrics.misses / this.metrics.totalAccesses;\r\n    } else {\r\n      this.metrics.hitRate = 0;\r\n      this.metrics.missRate = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Вычисление размера записи в байтах\r\n   */\r\n  private calculateEntrySize(\r\n    text: string,\r\n    embedding: Float32Array,\r\n    metadata?: Record<string, any>\r\n  ): number {\r\n    // Размер текста (UTF-16, 2 байта на символ)\r\n    const textSize = text.length * 2;\r\n\r\n    // Размер эмбеддинга (Float32 = 4 байта на элемент)\r\n    const embeddingSize = embedding.length * 4;\r\n\r\n    // Размер метаданных (приблизительная оценка)\r\n    const metadataSize = metadata ? JSON.stringify(metadata).length * 2 : 0;\r\n\r\n    // Служебные данные (даты, счетчики, etc.)\r\n    const overheadSize = 200;\r\n\r\n    return textSize + embeddingSize + metadataSize + overheadSize;\r\n  }\r\n\r\n  /**\r\n   * Вытеснение записей при необходимости\r\n   */\r\n  private evictIfNeeded(newEntrySize: number): void {\r\n    // Проверяем превышение по количеству записей\r\n    while (this.cache.size >= this.config.maxEntries && this.tail) {\r\n      this.evictLRU();\r\n    }\r\n\r\n    // Проверяем превышение по размеру в байтах\r\n    while (\r\n      this.metrics.totalSizeBytes + newEntrySize > this.config.maxSizeBytes &&\r\n      this.tail\r\n    ) {\r\n      this.evictLRU();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Вытеснение наименее используемой записи\r\n   */\r\n  private evictLRU(): void {\r\n    if (!this.tail) {\r\n      return;\r\n    }\r\n\r\n    const evictedNode = this.tail;\r\n    this.removeNode(evictedNode);\r\n    this.cache.delete(evictedNode.key);\r\n\r\n    // Обновляем метрики\r\n    this.metrics.evictions++;\r\n    this.metrics.currentSize = this.cache.size;\r\n    this.metrics.totalSizeBytes -= evictedNode.entry.sizeBytes;\r\n\r\n    if (this.config.enableLogging) {\r\n      console.log(`[MemoryCache] Вытеснена запись: ${evictedNode.key.substring(0, 16)}...`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Добавление узла в начало списка\r\n   */\r\n  private addToHead(node: LRUNode): void {\r\n    node.prev = null;\r\n    node.next = this.head;\r\n\r\n    if (this.head) {\r\n      this.head.prev = node;\r\n    }\r\n\r\n    this.head = node;\r\n\r\n    if (!this.tail) {\r\n      this.tail = node;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Удаление узла из списка\r\n   */\r\n  private removeNode(node: LRUNode): void {\r\n    if (node.prev) {\r\n      node.prev.next = node.next;\r\n    } else {\r\n      this.head = node.next;\r\n    }\r\n\r\n    if (node.next) {\r\n      node.next.prev = node.prev;\r\n    } else {\r\n      this.tail = node.prev;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Перемещение узла в начало списка\r\n   */\r\n  private moveToHead(node: LRUNode): void {\r\n    this.removeNode(node);\r\n    this.addToHead(node);\r\n  }\r\n\r\n  /**\r\n   * Запуск таймера автоматической очистки\r\n   */\r\n  private startCleanupTimer(): void {\r\n    this.cleanupTimer = setInterval(() => {\r\n      try {\r\n        this.cleanup();\r\n      } catch (error) {\r\n        if (this.config.enableLogging) {\r\n          console.error('[MemoryCache] Ошибка при автоматической очистке:', error);\r\n        }\r\n      }\r\n    }, this.config.cleanupIntervalMs);\r\n  }\r\n\r\n  /**\r\n   * Проверка, что кэш не был освобожден\r\n   */\r\n  private ensureNotDisposed(): void {\r\n    if (this.disposed) {\r\n      throw new EmbeddingError(\r\n        'Cache has been disposed',\r\n        'CACHE_DISPOSED'\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Фабрика для создания экземпляров кэша с предустановленными конфигурациями\r\n */\r\nexport class MemoryCacheFactory {\r\n  /**\r\n   * Создание малого кэша для разработки и тестирования\r\n   *\r\n   * @returns Настроенный экземпляр кэша\r\n   */\r\n  public static createSmall(): MemoryCache {\r\n    return new MemoryCache({\r\n      maxEntries: 100,\r\n      maxSizeBytes: 5 * 1024 * 1024, // 5MB\r\n      enableLogging: true,\r\n      cleanupIntervalMs: 2 * 60 * 1000, // 2 минуты\r\n      maxEntryAge: 30 * 60 * 1000, // 30 минут\r\n      enableDetailedMetrics: true\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Создание среднего кэша для типичного использования\r\n   *\r\n   * @returns Настроенный экземпляр кэша\r\n   */\r\n  public static createMedium(): MemoryCache {\r\n    return new MemoryCache({\r\n      maxEntries: 1000,\r\n      maxSizeBytes: 50 * 1024 * 1024, // 50MB\r\n      enableLogging: false,\r\n      cleanupIntervalMs: 5 * 60 * 1000, // 5 минут\r\n      maxEntryAge: 60 * 60 * 1000, // 1 час\r\n      enableDetailedMetrics: true\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Создание большого кэша для интенсивного использования\r\n   *\r\n   * @returns Настроенный экземпляр кэша\r\n   */\r\n  public static createLarge(): MemoryCache {\r\n    return new MemoryCache({\r\n      maxEntries: 5000,\r\n      maxSizeBytes: 200 * 1024 * 1024, // 200MB\r\n      enableLogging: false,\r\n      cleanupIntervalMs: 10 * 60 * 1000, // 10 минут\r\n      maxEntryAge: 2 * 60 * 60 * 1000, // 2 часа\r\n      enableDetailedMetrics: true\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Создание кэша без автоматической очистки\r\n   *\r\n   * @returns Настроенный экземпляр кэша\r\n   */\r\n  public static createPersistent(): MemoryCache {\r\n    return new MemoryCache({\r\n      maxEntries: 2000,\r\n      maxSizeBytes: 100 * 1024 * 1024, // 100MB\r\n      enableLogging: false,\r\n      cleanupIntervalMs: 0, // Отключаем автоочистку\r\n      maxEntryAge: 24 * 60 * 60 * 1000, // 24 часа\r\n      enableDetailedMetrics: true\r\n    });\r\n  }\r\n}","/**\r\n * LocalRetrieve Embedding System - Main Export\r\n *\r\n * Данный модуль предоставляет полную систему эмбеддингов для LocalRetrieve,\r\n * включая локальные и внешние провайдеры, утилиты обработки текста и кэширование.\r\n */\r\n\r\n// Core provider interfaces and base classes\r\nexport {\r\n  type EmbeddingProvider,\r\n  type ProviderHealthStatus,\r\n  type ProviderMetrics,\r\n  type EmbeddingProviderFactory,\r\n  type ModelInfo,\r\n  BaseEmbeddingProvider,\r\n  ProviderUtils\r\n} from './providers/BaseProvider.js';\r\n\r\n// External provider base class\r\nexport {\r\n  ExternalProvider,\r\n  type ExternalProviderConfig\r\n} from './providers/ExternalProvider.js';\r\n\r\n// Specific provider implementations\r\nexport {\r\n  OpenAIProvider,\r\n  createOpenAIProvider,\r\n  isValidModelDimensionCombo,\r\n  getRecommendedConfig\r\n} from './providers/OpenAIProvider.js';\r\n\r\nexport {\r\n  TransformersProvider,\r\n  createTransformersProvider,\r\n  isTransformersSupported,\r\n  getModelInfo as getTransformersModelInfo,\r\n  type TransformersProviderConfig\r\n} from './providers/TransformersProvider.js';\r\n\r\n// Type definitions\r\nexport type {\r\n  CollectionEmbeddingConfig,\r\n  EmbeddingConfig,\r\n  EmbeddingProviderType,\r\n  CacheStrategy,\r\n  TextPreprocessingConfig,\r\n  EmbeddingWorkerConfig,\r\n  EmbeddingResult,\r\n  EmbeddingMetadata,\r\n  EmbeddingRequest,\r\n  EmbeddingRequestOptions,\r\n  EmbeddingPriority,\r\n  BatchEmbeddingResult,\r\n  BatchMetadata,\r\n  EmbeddingOperationStatus,\r\n  EmbeddingOperationState,\r\n  Collection,\r\n  CollectionMetadata,\r\n  IndexingSettings,\r\n  CollectionStatistics,\r\n  CollectionEmbeddingStatus,\r\n  SemanticSearchOptions,\r\n  HybridSearchOptions,\r\n  RerankingOptions,\r\n  SearchResultWithEmbedding,\r\n  EmbeddingExportConfig,\r\n  EmbeddingImportConfig,\r\n  EmbeddingChangeEvent,\r\n  EmbeddingMonitoringConfig\r\n} from './types.js';\r\n\r\n// Error classes\r\nexport {\r\n  EmbeddingError,\r\n  ProviderError,\r\n  ProviderInitializationError,\r\n  ModelLoadError,\r\n  NetworkError,\r\n  AuthenticationError,\r\n  ConfigurationError,\r\n  ValidationError,\r\n  QuotaExceededError,\r\n  TimeoutError,\r\n  CacheError,\r\n  WorkerError,\r\n  ErrorUtils,\r\n  type ErrorCategory,\r\n  type NetworkErrorType,\r\n  type AuthErrorType,\r\n  type QuotaType,\r\n  type CacheOperation,\r\n  type ErrorRecoveryInfo,\r\n  type ErrorJSON\r\n} from './errors.js';\r\n\r\n// Text processing utilities\r\nexport {\r\n  TextProcessor,\r\n  type TextProcessingResult,\r\n  type TruncationOptions,\r\n  type ProcessingStatistics\r\n} from './TextProcessor.js';\r\n\r\n// Utility classes and interfaces\r\nexport {\r\n  EmbeddingUtils,\r\n  CollectionUtils,\r\n  EmbeddingConstants,\r\n  type HashResult,\r\n  type HashOptions,\r\n  type CacheKeyConfig,\r\n  type DimensionValidationResult,\r\n  type PerformanceMetrics,\r\n  type SupportedDimensions,\r\n  type ProviderType,\r\n  type HashAlgorithm\r\n} from './utils.js';\r\n\r\n// Cache implementations\r\nexport {\r\n  MemoryCache,\r\n  type MemoryCacheConfig,\r\n  type CacheEntry,\r\n  type CacheMetrics\r\n} from './cache/MemoryCache.js';\r\n\r\n// Provider Factory\r\nexport {\r\n  EmbeddingProviderFactoryImpl,\r\n  providerFactory,\r\n  createEmbeddingProvider as createProvider,\r\n  validateProviderConfig,\r\n  checkProviderSupport,\r\n  getProviderRecommendations,\r\n  getAvailableProviders,\r\n  getAvailableModels,\r\n  type ProviderSupportInfo,\r\n  type ProviderConfigInfo,\r\n  type ProviderRecommendation\r\n} from './ProviderFactory.js';\r\nimport { providerFactory as providerFactoryImpl } from './ProviderFactory.js';\r\nimport { getRecommendedConfig as getRecommendedConfigImpl } from './providers/OpenAIProvider.js';\r\n\r\n// Constants and defaults\r\nexport const EMBEDDING_DEFAULTS = {\r\n  DIMENSIONS: {\r\n    SMALL: 384,\r\n    MEDIUM: 768,\r\n    LARGE: 1536\r\n  },\r\n  BATCH_SIZE: {\r\n    LOCAL: 32,\r\n    EXTERNAL: 100\r\n  },\r\n  TIMEOUT: {\r\n    DEFAULT: 30000,\r\n    LOCAL: 60000,\r\n    EXTERNAL: 30000\r\n  },\r\n  CACHE: {\r\n    MAX_SIZE: 10000,\r\n    TTL: 24 * 60 * 60 * 1000 // 24 hours\r\n  },\r\n  TEXT_LIMITS: {\r\n    MAX_LENGTH: 8192,\r\n    ESTIMATED_TOKENS_PER_CHAR: 0.25\r\n  }\r\n} as const;\r\n\r\nexport const SUPPORTED_PROVIDERS: Record<import('./types.js').EmbeddingProviderType, {\r\n  name: string;\r\n  type: 'local' | 'external';\r\n  description: string;\r\n  requiresApiKey: boolean;\r\n  supportedDimensions: number[];\r\n}> = {\r\n  transformers: {\r\n    name: 'Transformers.js',\r\n    type: 'local',\r\n    description: 'Local embedding generation using Transformers.js',\r\n    requiresApiKey: false,\r\n    supportedDimensions: [384]\r\n  },\r\n  openai: {\r\n    name: 'OpenAI Embeddings',\r\n    type: 'external',\r\n    description: 'OpenAI text-embedding-3-small and text-embedding-3-large models',\r\n    requiresApiKey: true,\r\n    supportedDimensions: [384, 768, 1536, 256, 512, 1024, 3072]\r\n  },\r\n  cohere: {\r\n    name: 'Cohere Embeddings',\r\n    type: 'external',\r\n    description: 'Cohere embedding models (coming soon)',\r\n    requiresApiKey: true,\r\n    supportedDimensions: [384, 768, 1024]\r\n  },\r\n  huggingface: {\r\n    name: 'Hugging Face',\r\n    type: 'external',\r\n    description: 'Hugging Face Inference API (coming soon)',\r\n    requiresApiKey: true,\r\n    supportedDimensions: [384, 768, 1024]\r\n  },\r\n  custom: {\r\n    name: 'Custom Provider',\r\n    type: 'external',\r\n    description: 'Custom embedding provider implementation',\r\n    requiresApiKey: false,\r\n    supportedDimensions: []\r\n  }\r\n} as const;\r\n\r\n/**\r\n * Фабричная функция для создания провайдеров эмбеддингов\r\n *\r\n * @deprecated Use the new ProviderFactory instead: `import { createProvider } from './ProviderFactory.js'`\r\n * @param config - Конфигурация коллекции эмбеддингов\r\n * @returns Экземпляр провайдера эмбеддингов\r\n */\r\nexport async function createEmbeddingProvider(\r\n  config: import('./types.js').CollectionEmbeddingConfig\r\n): Promise<import('./providers/BaseProvider.js').EmbeddingProvider> {\r\n  // Delegate to the new provider factory for better error handling and validation\r\n  return providerFactoryImpl.createProvider(config);\r\n}\r\n\r\n/**\r\n * Валидация конфигурации эмбеддингов\r\n *\r\n * @deprecated Use the new ProviderFactory validation instead: `import { validateProviderConfig } from './ProviderFactory.js'`\r\n * @param config - Конфигурация для валидации\r\n * @returns Результат валидации\r\n */\r\nexport function validateEmbeddingConfig(config: import('./types.js').CollectionEmbeddingConfig): {\r\n  isValid: boolean;\r\n  errors: string[];\r\n  warnings: string[];\r\n  suggestions: string[];\r\n} {\r\n  // Delegate to the new provider factory for comprehensive validation\r\n  return (providerFactoryImpl as any).validateConfiguration(config);\r\n}\r\n\r\n/**\r\n * Получение рекомендуемой конфигурации для заданных требований\r\n *\r\n * @param requirements - Требования к конфигурации\r\n * @returns Рекомендуемая конфигурация\r\n */\r\nexport function getRecommendedEmbeddingConfig(requirements: {\r\n  dimensions?: number;\r\n  offline?: boolean;\r\n  budget?: 'low' | 'medium' | 'high';\r\n  performance?: 'fast' | 'balanced' | 'accurate';\r\n  apiKey?: string;\r\n}): import('./types.js').CollectionEmbeddingConfig {\r\n  const {\r\n    dimensions = EMBEDDING_DEFAULTS.DIMENSIONS.SMALL,\r\n    offline = false,\r\n    budget = 'medium',\r\n    performance = 'balanced',\r\n    apiKey\r\n  } = requirements;\r\n\r\n  // Если требуется offline режим, используем Transformers.js\r\n  if (offline || !apiKey) {\r\n    return {\r\n      provider: 'transformers',\r\n      model: 'all-MiniLM-L6-v2',\r\n      dimensions: EMBEDDING_DEFAULTS.DIMENSIONS.SMALL, // Transformers.js поддерживает только 384\r\n      batchSize: EMBEDDING_DEFAULTS.BATCH_SIZE.LOCAL,\r\n      cacheEnabled: true,\r\n      autoGenerate: true,\r\n      timeout: EMBEDDING_DEFAULTS.TIMEOUT.LOCAL\r\n    };\r\n  }\r\n\r\n  // Для online режима выбираем OpenAI на основе требований\r\n  const openaiConfig = (getRecommendedConfigImpl as any)({ dimensions, budget, performance });\r\n\r\n  return {\r\n    provider: 'openai',\r\n    model: openaiConfig.model,\r\n    dimensions: openaiConfig.dimensions,\r\n    apiKey,\r\n    batchSize: EMBEDDING_DEFAULTS.BATCH_SIZE.EXTERNAL,\r\n    cacheEnabled: true,\r\n    autoGenerate: true,\r\n    timeout: EMBEDDING_DEFAULTS.TIMEOUT.EXTERNAL\r\n  };\r\n}\r\n\r\n/**\r\n * Проверка совместимости конфигураций для миграции\r\n *\r\n * @param oldConfig - Старая конфигурация\r\n * @param newConfig - Новая конфигурация\r\n * @returns Информация о совместимости\r\n */\r\nexport function checkConfigCompatibility(\r\n  oldConfig: import('./types.js').CollectionEmbeddingConfig,\r\n  newConfig: import('./types.js').CollectionEmbeddingConfig\r\n): {\r\n  compatible: boolean;\r\n  requiresRegeneration: boolean;\r\n  issues: string[];\r\n  recommendations: string[];\r\n} {\r\n  const issues: string[] = [];\r\n  const recommendations: string[] = [];\r\n  let requiresRegeneration = false;\r\n\r\n  // Проверка размерности\r\n  if (oldConfig.dimensions !== newConfig.dimensions) {\r\n    issues.push('Dimension mismatch');\r\n    requiresRegeneration = true;\r\n    recommendations.push('All embeddings will need to be regenerated');\r\n  }\r\n\r\n  // Проверка провайдера\r\n  if (oldConfig.provider !== newConfig.provider) {\r\n    issues.push('Provider change');\r\n    requiresRegeneration = true;\r\n    recommendations.push('Embeddings from different providers may not be compatible');\r\n  }\r\n\r\n  // Проверка модели\r\n  if (oldConfig.model !== newConfig.model) {\r\n    issues.push('Model change');\r\n    requiresRegeneration = true;\r\n    recommendations.push('Different models produce different embeddings');\r\n  }\r\n\r\n  const compatible = issues.length === 0;\r\n\r\n  return {\r\n    compatible,\r\n    requiresRegeneration,\r\n    issues,\r\n    recommendations\r\n  };\r\n}","/**\r\n * InternalPipeline - основная система генерации эмбеддингов по запросу\r\n *\r\n * Реализует интеллектуальную генерацию эмбеддингов с многоуровневым кэшированием,\r\n * интеграцией с системой очередей Phase 5 и оптимизацией производительности.\r\n *\r\n * Архитектурные принципы:\r\n * - Кэш-ориентированная генерация (memory → IndexedDB → database)\r\n * - Интеграция с существующей системой очередей Phase 5\r\n * - Batch обработка с отслеживанием прогресса\r\n * - Переиспользование загруженных моделей\r\n * - Graceful fallback при ошибках\r\n */\r\n\r\nimport type {\r\n  EmbeddingProviderType,\r\n  EmbeddingResult as EmbeddingResultType,\r\n  EmbeddingRequest as EmbeddingRequestType,\r\n  EmbeddingRequestOptions,\r\n  BatchEmbeddingResult as BatchEmbeddingResultType,\r\n  CollectionEmbeddingConfig\r\n} from '../embedding/types.js';\r\nimport type { CacheManager } from '../cache/CacheManager.js';\r\nimport type { ModelManager } from './ModelManager.js';\r\nimport { EmbeddingError, ConfigurationError, TimeoutError } from '../embedding/errors.js';\r\nimport { EmbeddingUtils } from '../embedding/utils.js';\r\nimport { providerFactory } from '../embedding/ProviderFactory.js';\r\n\r\n/**\r\n * Параметры генерации эмбеддингов по запросу\r\n */\r\nexport interface EmbeddingOptions {\r\n  /** Принудительное обновление кэша */\r\n  forceRefresh?: boolean;\r\n  /** Таймаут операции в миллисекундах */\r\n  timeout?: number;\r\n  /** Приоритет для очереди */\r\n  priority?: number;\r\n  /** Контекст для оптимизации кэша */\r\n  context?: {\r\n    userId?: string;\r\n    sessionId?: string;\r\n    source?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Параметры batch обработки\r\n */\r\nexport interface BatchOptions {\r\n  /** Размер batch для обработки */\r\n  batchSize?: number;\r\n  /** Максимальное количество параллельных batch */\r\n  concurrency?: number;\r\n  /** Таймаут для всей batch операции */\r\n  timeout?: number;\r\n  /** Callback для отслеживания прогресса */\r\n  onProgress?: (completed: number, total: number, current?: string) => void;\r\n}\r\n\r\n/**\r\n * Результат генерации эмбеддинга\r\n */\r\nexport interface PipelineEmbeddingResult {\r\n  /** Вектор эмбеддинга */\r\n  embedding: Float32Array;\r\n  /** Размерность вектора */\r\n  dimensions: number;\r\n  /** Источник результата */\r\n  source: 'cache_memory' | 'cache_indexeddb' | 'cache_database' | 'provider_fresh';\r\n  /** Время генерации в миллисекундах */\r\n  processingTime: number;\r\n  /** Метаданные */\r\n  metadata?: {\r\n    cacheHit?: boolean;\r\n    modelUsed?: string;\r\n    provider?: string;\r\n    confidence?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Batch результат с детальной информацией\r\n */\r\nexport interface PipelineBatchEmbeddingResult extends PipelineEmbeddingResult {\r\n  /** ID запроса в batch */\r\n  requestId: string;\r\n  /** Статус обработки */\r\n  status: 'completed' | 'failed' | 'skipped';\r\n  /** Сообщение об ошибке при неудаче */\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Запрос на генерацию эмбеддинга\r\n */\r\nexport interface PipelineEmbeddingRequest {\r\n  /** Уникальный ID запроса */\r\n  id: string;\r\n  /** Текст для обработки */\r\n  query: string;\r\n  /** Имя коллекции */\r\n  collection: string;\r\n  /** Дополнительные опции */\r\n  options?: EmbeddingOptions;\r\n}\r\n\r\n/**\r\n * Интерфейс основного класса InternalPipeline\r\n */\r\nexport interface InternalPipeline {\r\n  /**\r\n   * Генерация эмбеддинга для поискового запроса с кэшированием\r\n   */\r\n  generateQueryEmbedding(query: string, collection: string, options?: EmbeddingOptions): Promise<PipelineEmbeddingResult>;\r\n\r\n  /**\r\n   * Batch генерация эмбеддингов с управлением прогрессом\r\n   */\r\n  batchGenerateEmbeddings(requests: PipelineEmbeddingRequest[], options?: BatchOptions): Promise<PipelineBatchEmbeddingResult[]>;\r\n\r\n  /**\r\n   * Получение кэшированного эмбеддинга\r\n   */\r\n  getCachedEmbedding(query: string, collection: string): Promise<PipelineEmbeddingResult | null>;\r\n\r\n  /**\r\n   * Предварительный прогрев кэша для популярных запросов\r\n   */\r\n  warmCache(commonQueries: string[], collection: string): Promise<void>;\r\n\r\n  /**\r\n   * Очистка кэшей и освобождение ресурсов\r\n   */\r\n  clearCache(collection?: string): Promise<void>;\r\n\r\n  /**\r\n   * Получение статистики производительности\r\n   */\r\n  getPerformanceStats(): PipelinePerformanceStats;\r\n}\r\n\r\n/**\r\n * Статистика производительности пайплайна\r\n */\r\nexport interface PipelinePerformanceStats {\r\n  /** Общее количество запросов */\r\n  totalRequests: number;\r\n  /** Процент попаданий в кэш */\r\n  cacheHitRate: number;\r\n  /** Среднее время генерации */\r\n  averageGenerationTime: number;\r\n  /** Количество активных моделей в памяти */\r\n  activeModels: number;\r\n  /** Использование памяти в MB */\r\n  memoryUsage: number;\r\n  /** Статистика по уровням кэша */\r\n  cacheStats: {\r\n    memory: { hits: number; misses: number };\r\n    indexedDB: { hits: number; misses: number };\r\n    database: { hits: number; misses: number };\r\n  };\r\n}\r\n\r\n/**\r\n * Основная реализация InternalPipeline\r\n */\r\nexport class InternalPipelineImpl implements InternalPipeline {\r\n  private cacheManager: CacheManager;\r\n  private modelManager: ModelManager;\r\n\r\n  // Статистика производительности\r\n  private stats: {\r\n    totalRequests: number;\r\n    cacheHits: number;\r\n    cacheMisses: number;\r\n    totalGenerationTime: number;\r\n    cacheHitsByLevel: Map<string, number>;\r\n  };\r\n\r\n  // Провайдеры по коллекциям\r\n  private providers: Map<string, any>;\r\n\r\n  // Конфигурации коллекций\r\n  private collectionConfigs: Map<string, CollectionEmbeddingConfig>;\r\n\r\n  constructor(cacheManager: CacheManager, modelManager: ModelManager) {\r\n    this.cacheManager = cacheManager;\r\n    this.modelManager = modelManager;\r\n\r\n    this.stats = {\r\n      totalRequests: 0,\r\n      cacheHits: 0,\r\n      cacheMisses: 0,\r\n      totalGenerationTime: 0,\r\n      cacheHitsByLevel: new Map()\r\n    };\r\n\r\n    this.providers = new Map();\r\n    this.collectionConfigs = new Map();\r\n  }\r\n\r\n  /**\r\n   * Генерация эмбеддинга для поискового запроса с многоуровневым кэшированием\r\n   */\r\n  async generateQueryEmbedding(query: string, collection: string, options?: EmbeddingOptions): Promise<PipelineEmbeddingResult> {\r\n    const startTime = Date.now();\r\n    this.stats.totalRequests++;\r\n\r\n    try {\r\n      // Валидация входных параметров\r\n      this.validateInputs(query, collection);\r\n\r\n      // Попытка получить из кэша\r\n      if (!options?.forceRefresh) {\r\n        const cached = await this.getCachedEmbedding(query, collection);\r\n        if (cached) {\r\n          this.stats.cacheHits++;\r\n          this.updateCacheHitStats(cached.source);\r\n          return cached;\r\n        }\r\n      }\r\n\r\n      this.stats.cacheMisses++;\r\n\r\n      // Получение провайдера для коллекции\r\n      const provider = await this.getProviderForCollection(collection);\r\n\r\n      // Настройка таймаута\r\n      const timeout = options?.timeout || 5000; // 5 секунд по умолчанию\r\n      const embeddingPromise = this.generateFreshEmbedding(query, provider);\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new TimeoutError(`Embedding generation timeout after ${timeout}ms`, timeout, 'generateQueryEmbedding')), timeout)\r\n      );\r\n\r\n      // Генерация эмбеддинга с таймаутом\r\n      const embedding = await Promise.race([embeddingPromise, timeoutPromise]);\r\n\r\n      const processingTime = Date.now() - startTime;\r\n      this.stats.totalGenerationTime += processingTime;\r\n\r\n      const result: PipelineEmbeddingResult = {\r\n        embedding,\r\n        dimensions: embedding.length,\r\n        source: 'provider_fresh',\r\n        processingTime,\r\n        metadata: {\r\n          cacheHit: false,\r\n          modelUsed: provider.getModelInfo?.()?.name,\r\n          provider: this.getProviderType(provider),\r\n          confidence: 1.0\r\n        }\r\n      };\r\n\r\n      // Сохранение в кэш асинхронно\r\n      this.saveToCacheAsync(query, collection, result).catch(error =>\r\n        console.warn('Failed to cache embedding result:', error)\r\n      );\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      const processingTime = Date.now() - startTime;\r\n      this.stats.totalGenerationTime += processingTime;\r\n\r\n      if (error instanceof EmbeddingError) {\r\n        throw error;\r\n      }\r\n\r\n      throw new EmbeddingError(\r\n        `Failed to generate query embedding: ${error instanceof Error ? error.message : String(error)}`,\r\n        'GENERATION_FAILED',\r\n        'provider',\r\n        { query: query.substring(0, 100), collection }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Batch генерация эмбеддингов с управлением прогрессом\r\n   */\r\n  async batchGenerateEmbeddings(requests: PipelineEmbeddingRequest[], options?: BatchOptions): Promise<PipelineBatchEmbeddingResult[]> {\r\n    if (requests.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    const batchSize = options?.batchSize || 32;\r\n    const concurrency = options?.concurrency || 3;\r\n    const results: PipelineBatchEmbeddingResult[] = [];\r\n\r\n    // Разбиваем запросы на batch'и\r\n    const batches: PipelineEmbeddingRequest[][] = [];\r\n    for (let i = 0; i < requests.length; i += batchSize) {\r\n      batches.push(requests.slice(i, i + batchSize));\r\n    }\r\n\r\n    let completedCount = 0;\r\n    const total = requests.length;\r\n\r\n    // Обработка batch'ей с ограниченным параллелизмом\r\n    const processBatch = async (batch: PipelineEmbeddingRequest[]): Promise<PipelineBatchEmbeddingResult[]> => {\r\n      const batchResults: PipelineBatchEmbeddingResult[] = [];\r\n\r\n      for (const request of batch) {\r\n        try {\r\n          options?.onProgress?.(completedCount, total, request.query.substring(0, 50) + '...');\r\n\r\n          const embeddingResult = await this.generateQueryEmbedding(\r\n            request.query,\r\n            request.collection,\r\n            request.options\r\n          );\r\n\r\n          batchResults.push({\r\n            requestId: request.id,\r\n            ...embeddingResult,\r\n            status: 'completed'\r\n          });\r\n\r\n          completedCount++;\r\n\r\n        } catch (error) {\r\n          batchResults.push({\r\n            requestId: request.id,\r\n            embedding: new Float32Array(0),\r\n            dimensions: 0,\r\n            source: 'provider_fresh',\r\n            processingTime: 0,\r\n            status: 'failed',\r\n            error: error instanceof Error ? error.message : String(error)\r\n          });\r\n\r\n          completedCount++;\r\n        }\r\n      }\r\n\r\n      return batchResults;\r\n    };\r\n\r\n    // Параллельная обработка с ограничением concurrency\r\n    for (let i = 0; i < batches.length; i += concurrency) {\r\n      const batchSlice = batches.slice(i, i + concurrency);\r\n      const batchPromises = batchSlice.map(processBatch);\r\n      const batchResults = await Promise.all(batchPromises);\r\n\r\n      results.push(...batchResults.flat());\r\n    }\r\n\r\n    options?.onProgress?.(completedCount, total, 'Completed');\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Получение кэшированного эмбеддинга с проверкой всех уровней\r\n   */\r\n  async getCachedEmbedding(query: string, collection: string): Promise<PipelineEmbeddingResult | null> {\r\n    const cacheKey = this.generateCacheKey(query, collection);\r\n\r\n    try {\r\n      // Уровень 1: Memory cache\r\n      const memoryResult = await this.cacheManager.get(cacheKey, 'memory');\r\n      if (memoryResult) {\r\n        return {\r\n          ...memoryResult,\r\n          source: 'cache_memory',\r\n          metadata: { ...memoryResult.metadata, cacheHit: true }\r\n        };\r\n      }\r\n\r\n      // Уровень 2: IndexedDB cache\r\n      const indexedDBResult = await this.cacheManager.get(cacheKey, 'indexeddb');\r\n      if (indexedDBResult) {\r\n        // Сохраняем обратно в memory для быстрого доступа\r\n        await this.cacheManager.set(cacheKey, indexedDBResult, { level: 'memory', ttl: 300000 }); // 5 мин\r\n\r\n        return {\r\n          ...indexedDBResult,\r\n          source: 'cache_indexeddb',\r\n          metadata: { ...indexedDBResult.metadata, cacheHit: true }\r\n        };\r\n      }\r\n\r\n      // Уровень 3: Database cache (через CacheManager)\r\n      const databaseResult = await this.cacheManager.get(cacheKey, 'database');\r\n      if (databaseResult) {\r\n        // Сохраняем в вышестоящие кэши\r\n        await Promise.all([\r\n          this.cacheManager.set(cacheKey, databaseResult, { level: 'memory', ttl: 300000 }),\r\n          this.cacheManager.set(cacheKey, databaseResult, { level: 'indexeddb', ttl: 86400000 }) // 24 часа\r\n        ]);\r\n\r\n        return {\r\n          ...databaseResult,\r\n          source: 'cache_database',\r\n          metadata: { ...databaseResult.metadata, cacheHit: true }\r\n        };\r\n      }\r\n\r\n      return null;\r\n\r\n    } catch (error) {\r\n      console.warn(`Cache lookup failed for query \"${query.substring(0, 50)}\":`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Предварительный прогрев кэша для популярных запросов\r\n   */\r\n  async warmCache(commonQueries: string[], collection: string): Promise<void> {\r\n    const batchSize = 10;\r\n    const requests: PipelineEmbeddingRequest[] = commonQueries.map((query, index) => ({\r\n      id: `warmup-${index}`,\r\n      query,\r\n      collection,\r\n      options: { priority: 0 } // Низкий приоритет для прогрева\r\n    }));\r\n\r\n    // Генерируем эмбеддинги batch'ами\r\n    await this.batchGenerateEmbeddings(requests, {\r\n      batchSize,\r\n      concurrency: 2,\r\n      onProgress: (completed, total) => {\r\n        console.log(`Cache warming progress: ${completed}/${total}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Очистка кэшей и освобождение ресурсов\r\n   */\r\n  async clearCache(collection?: string): Promise<void> {\r\n    if (collection) {\r\n      // Очистка кэша конкретной коллекции\r\n      const pattern = `*:${collection}:*`;\r\n      await this.cacheManager.invalidate(pattern);\r\n    } else {\r\n      // Полная очистка\r\n      await this.cacheManager.invalidate('*');\r\n    }\r\n\r\n    // Сброс статистики\r\n    this.stats.cacheHitsByLevel.clear();\r\n  }\r\n\r\n  /**\r\n   * Получение статистики производительности\r\n   */\r\n  getPerformanceStats(): PipelinePerformanceStats {\r\n    const cacheHitRate = this.stats.totalRequests > 0\r\n      ? (this.stats.cacheHits / this.stats.totalRequests) * 100\r\n      : 0;\r\n\r\n    const averageGenerationTime = this.stats.totalRequests > 0\r\n      ? this.stats.totalGenerationTime / this.stats.totalRequests\r\n      : 0;\r\n\r\n    return {\r\n      totalRequests: this.stats.totalRequests,\r\n      cacheHitRate,\r\n      averageGenerationTime,\r\n      activeModels: this.modelManager.getModelStatus().loadedModels.length,\r\n      memoryUsage: this.estimateMemoryUsage(),\r\n      cacheStats: {\r\n        memory: {\r\n          hits: this.stats.cacheHitsByLevel.get('cache_memory') || 0,\r\n          misses: this.stats.cacheMisses\r\n        },\r\n        indexedDB: {\r\n          hits: this.stats.cacheHitsByLevel.get('cache_indexeddb') || 0,\r\n          misses: 0 // Будет реализовано в CacheManager\r\n        },\r\n        database: {\r\n          hits: this.stats.cacheHitsByLevel.get('cache_database') || 0,\r\n          misses: 0 // Будет реализовано в CacheManager\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  // === Приватные методы ===\r\n\r\n  /**\r\n   * Валидация входных параметров\r\n   */\r\n  private validateInputs(query: string, collection: string): void {\r\n    if (!query || typeof query !== 'string' || query.trim().length === 0) {\r\n      throw new ConfigurationError('Query must be a non-empty string', 'query', 'non-empty string', query);\r\n    }\r\n\r\n    if (query.length > 8192) { // Лимит из embedding constants\r\n      throw new ConfigurationError('Query is too long (max 8192 characters)', 'query', 'string with length <= 8192', query.length);\r\n    }\r\n\r\n    if (!collection || typeof collection !== 'string') {\r\n      throw new ConfigurationError('Collection must be specified', 'collection', 'non-empty string', collection);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение провайдера для коллекции\r\n   */\r\n  private async getProviderForCollection(collection: string): Promise<any> {\r\n    // Проверяем кэш провайдеров\r\n    if (this.providers.has(collection)) {\r\n      const provider = this.providers.get(collection)!;\r\n      return provider;\r\n    }\r\n\r\n    // Получаем конфигурацию коллекции (заглушка - в реальной реализации это будет из базы данных)\r\n    const config = await this.getCollectionConfig(collection);\r\n\r\n    // Создаем провайдера\r\n    const provider = await providerFactory.createProvider(config);\r\n\r\n    // Кэшируем провайдера\r\n    this.providers.set(collection, provider);\r\n    this.collectionConfigs.set(collection, config);\r\n\r\n    return provider;\r\n  }\r\n\r\n  /**\r\n   * Генерация свежего эмбеддинга через провайдера\r\n   */\r\n  private async generateFreshEmbedding(query: string, provider: any): Promise<Float32Array> {\r\n    const result = await provider.generateEmbedding(query);\r\n\r\n    if (!result.success || !result.embedding) {\r\n      throw new EmbeddingError(\r\n        'Provider failed to generate embedding',\r\n        'PROVIDER_ERROR',\r\n        'provider',\r\n        { error: result.error }\r\n      );\r\n    }\r\n\r\n    return result.embedding;\r\n  }\r\n\r\n  /**\r\n   * Асинхронное сохранение в кэш\r\n   */\r\n  private async saveToCacheAsync(query: string, collection: string, result: PipelineEmbeddingResult): Promise<void> {\r\n    const cacheKey = this.generateCacheKey(query, collection);\r\n\r\n    try {\r\n      // Сохраняем на всех уровнях с разными TTL\r\n      await Promise.all([\r\n        this.cacheManager.set(cacheKey, result, { level: 'memory', ttl: 300000 }), // 5 мин\r\n        this.cacheManager.set(cacheKey, result, { level: 'indexeddb', ttl: 86400000 }), // 24 часа\r\n        this.cacheManager.set(cacheKey, result, { level: 'database', ttl: 604800000 }) // 7 дней\r\n      ]);\r\n    } catch (error) {\r\n      // Логируем, но не прерываем работу\r\n      console.warn('Failed to save to cache:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Генерация ключа кэша\r\n   */\r\n  private generateCacheKey(query: string, collection: string): string {\r\n    const config = this.collectionConfigs.get(collection);\r\n    const configHash = config ? EmbeddingUtils.hashText(JSON.stringify(config), { algorithm: 'simple' }).hash : 'default';\r\n    const queryHash = EmbeddingUtils.hashText(query.trim().toLowerCase(), { algorithm: 'simple' }).hash;\r\n\r\n    return `embedding:${collection}:${configHash}:${queryHash}`;\r\n  }\r\n\r\n  /**\r\n   * Получение конфигурации коллекции (заглушка)\r\n   */\r\n  private async getCollectionConfig(collection: string): Promise<CollectionEmbeddingConfig> {\r\n    // Заглушка - в реальной реализации это будет запрос к базе данных\r\n    // Возвращаем конфигурацию по умолчанию\r\n    return {\r\n      provider: 'transformers',\r\n      model: 'all-MiniLM-L6-v2',\r\n      dimensions: 384,\r\n      batchSize: 32,\r\n      cacheEnabled: true,\r\n      autoGenerate: true,\r\n      timeout: 30000\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Получение типа провайдера\r\n   */\r\n  private getProviderType(provider: any): string {\r\n    // Проверяем по классу или свойствам провайдера\r\n    const modelInfo = provider.getModelInfo?.();\r\n    return modelInfo?.provider || 'unknown';\r\n  }\r\n\r\n  /**\r\n   * Обновление статистики попаданий в кэш\r\n   */\r\n  private updateCacheHitStats(source: PipelineEmbeddingResult['source']): void {\r\n    const current = this.stats.cacheHitsByLevel.get(source) || 0;\r\n    this.stats.cacheHitsByLevel.set(source, current + 1);\r\n  }\r\n\r\n  /**\r\n   * Оценка использования памяти\r\n   */\r\n  private estimateMemoryUsage(): number {\r\n    // Приблизительная оценка (в MB)\r\n    let memoryUsage = 0;\r\n\r\n    // Кэш провайдеров\r\n    memoryUsage += this.providers.size * 10; // ~10MB на провайдера\r\n\r\n    // Модели в памяти\r\n    memoryUsage += this.modelManager.getModelStatus().loadedModels.length * 50; // ~50MB на модель\r\n\r\n    // Кэш результатов (будет точнее реализовано в CacheManager)\r\n    memoryUsage += 20; // ~20MB для кэша результатов\r\n\r\n    return memoryUsage;\r\n  }\r\n}\r\n\r\n/**\r\n * Фабричная функция для создания InternalPipeline\r\n */\r\nexport async function createInternalPipeline(\r\n  cacheManager: CacheManager,\r\n  modelManager: ModelManager\r\n): Promise<InternalPipeline> {\r\n  return new InternalPipelineImpl(cacheManager, modelManager);\r\n}","/**\r\n * ModelManager - управление жизненным циклом embedding моделей\r\n *\r\n * Отвечает за интеллектуальную загрузку, кэширование и оптимизацию памяти\r\n * для embedding моделей. Поддерживает стратегии предзагрузки и автоматическую\r\n * выгрузку неиспользуемых моделей для оптимизации ресурсов.\r\n */\r\n\r\nimport type { EmbeddingProviderType, CollectionEmbeddingConfig } from '../embedding/types.js';\r\nimport { providerFactory } from '../embedding/ProviderFactory.js';\r\nimport { ModelLoadError, ConfigurationError, EmbeddingError } from '../embedding/errors.js';\r\n\r\n/**\r\n * Стратегии загрузки моделей\r\n */\r\nexport type LoadingStrategy = 'eager' | 'lazy' | 'predictive';\r\n\r\n/**\r\n * Информация о загруженной модели\r\n */\r\nexport interface LoadedModel {\r\n  /** Уникальный ID модели */\r\n  modelId: string;\r\n  /** Тип провайдера */\r\n  provider: EmbeddingProviderType;\r\n  /** Название модели */\r\n  modelName: string;\r\n  /** Размерность эмбеддингов */\r\n  dimensions: number;\r\n  /** Экземпляр провайдера */\r\n  providerInstance: any;\r\n  /** Время последнего использования */\r\n  lastUsed: number;\r\n  /** Счетчик использований */\r\n  usageCount: number;\r\n  /** Приблизительное использование памяти в MB */\r\n  memoryUsage: number;\r\n  /** Время загрузки модели */\r\n  loadTime: number;\r\n  /** Статус модели */\r\n  status: 'loading' | 'ready' | 'error' | 'unloading';\r\n  /** Сообщение об ошибке (если есть) */\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Статус ModelManager\r\n */\r\nexport interface ModelStatus {\r\n  /** Загруженные модели */\r\n  loadedModels: LoadedModel[];\r\n  /** Общее использование памяти в MB */\r\n  totalMemoryUsage: number;\r\n  /** Количество активных моделей */\r\n  activeCount: number;\r\n  /** Статистика по провайдерам */\r\n  providerStats: Record<EmbeddingProviderType, {\r\n    count: number;\r\n    memoryUsage: number;\r\n    avgLoadTime: number;\r\n  }>;\r\n}\r\n\r\n/**\r\n * Опции оптимизации памяти\r\n */\r\nexport interface MemoryOptimizationOptions {\r\n  /** Максимальное использование памяти в MB */\r\n  maxMemoryUsage?: number;\r\n  /** Максимальное количество одновременно загруженных моделей */\r\n  maxModels?: number;\r\n  /** Время неактивности перед выгрузкой (мс) */\r\n  idleTimeout?: number;\r\n  /** Принудительная очистка всех неиспользуемых моделей */\r\n  aggressive?: boolean;\r\n}\r\n\r\n/**\r\n * Модель с метриками производительности\r\n */\r\nexport interface EmbeddingModel {\r\n  /** Конфигурация */\r\n  config: CollectionEmbeddingConfig;\r\n  /** Провайдер */\r\n  provider: any;\r\n  /** Метрики производительности */\r\n  metrics: {\r\n    averageInferenceTime: number;\r\n    totalRequests: number;\r\n    successRate: number;\r\n    lastPerformanceCheck: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Интерфейс ModelManager\r\n */\r\nexport interface ModelManager {\r\n  /**\r\n   * Загрузка модели с указанным провайдером\r\n   */\r\n  loadModel(provider: EmbeddingProviderType, model?: string): Promise<EmbeddingModel>;\r\n\r\n  /**\r\n   * Предзагрузка моделей по стратегии\r\n   */\r\n  preloadModels(strategy: LoadingStrategy): Promise<void>;\r\n\r\n  /**\r\n   * Оптимизация использования памяти\r\n   */\r\n  optimizeMemory(options?: MemoryOptimizationOptions): Promise<void>;\r\n\r\n  /**\r\n   * Получение статуса всех моделей\r\n   */\r\n  getModelStatus(): ModelStatus;\r\n\r\n  /**\r\n   * Выгрузка неиспользуемых моделей\r\n   */\r\n  unloadUnusedModels(): Promise<void>;\r\n\r\n  /**\r\n   * Получение модели для коллекции\r\n   */\r\n  getModelForCollection(collection: string): Promise<EmbeddingModel | null>;\r\n\r\n  /**\r\n   * Прогрев модели (предварительная инициализация)\r\n   */\r\n  warmModel(modelId: string): Promise<void>;\r\n}\r\n\r\n/**\r\n * Основная реализация ModelManager\r\n */\r\nexport class ModelManagerImpl implements ModelManager {\r\n  private models: Map<string, LoadedModel>;\r\n  private modelConfigs: Map<string, CollectionEmbeddingConfig>;\r\n  private memoryLimit: number;\r\n  private maxModels: number;\r\n  private idleTimeout: number;\r\n  private cleanupInterval: NodeJS.Timeout | null;\r\n\r\n  // Статистика использования\r\n  private stats: {\r\n    totalLoads: number;\r\n    totalUnloads: number;\r\n    cacheHits: number;\r\n    cacheMisses: number;\r\n    avgLoadTime: number;\r\n  };\r\n\r\n  constructor(options: {\r\n    memoryLimit?: number;\r\n    maxModels?: number;\r\n    idleTimeout?: number;\r\n    cleanupInterval?: number;\r\n  } = {}) {\r\n    this.models = new Map();\r\n    this.modelConfigs = new Map();\r\n    this.memoryLimit = options.memoryLimit || 500; // 500MB по умолчанию\r\n    this.maxModels = options.maxModels || 5; // Максимум 5 моделей одновременно\r\n    this.idleTimeout = options.idleTimeout || 10 * 60 * 1000; // 10 минут неактивности\r\n    this.cleanupInterval = null;\r\n\r\n    this.stats = {\r\n      totalLoads: 0,\r\n      totalUnloads: 0,\r\n      cacheHits: 0,\r\n      cacheMisses: 0,\r\n      avgLoadTime: 0\r\n    };\r\n\r\n    // Запускаем периодическую очистку\r\n    this.startCleanupTimer(options.cleanupInterval || 5 * 60 * 1000); // Каждые 5 минут\r\n  }\r\n\r\n  /**\r\n   * Загрузка модели с кэшированием и оптимизацией\r\n   */\r\n  async loadModel(provider: EmbeddingProviderType, model?: string): Promise<EmbeddingModel> {\r\n    const modelId = this.generateModelId(provider, model);\r\n\r\n    // Проверяем наличие в кэше\r\n    if (this.models.has(modelId)) {\r\n      const cachedModel = this.models.get(modelId)!;\r\n\r\n      if (cachedModel.status === 'ready') {\r\n        // Обновляем статистику использования\r\n        cachedModel.lastUsed = Date.now();\r\n        cachedModel.usageCount++;\r\n        this.stats.cacheHits++;\r\n\r\n        return {\r\n          config: this.modelConfigs.get(modelId)!,\r\n          provider: cachedModel.providerInstance,\r\n          metrics: this.getModelMetrics(modelId)\r\n        };\r\n      } else if (cachedModel.status === 'loading') {\r\n        // Ждем завершения загрузки\r\n        return this.waitForModelLoad(modelId);\r\n      } else if (cachedModel.status === 'error') {\r\n        // Удаляем поврежденную модель и загружаем заново\r\n        this.models.delete(modelId);\r\n        this.modelConfigs.delete(modelId);\r\n      }\r\n    }\r\n\r\n    this.stats.cacheMisses++;\r\n\r\n    // Проверяем лимиты и освобождаем место при необходимости\r\n    await this.ensureResourcesAvailable();\r\n\r\n    // Загружаем новую модель\r\n    return this.loadNewModel(provider, model, modelId);\r\n  }\r\n\r\n  /**\r\n   * Предзагрузка моделей по стратегии\r\n   */\r\n  async preloadModels(strategy: LoadingStrategy): Promise<void> {\r\n    const modelsToLoad = this.getModelsForPreloading(strategy);\r\n\r\n    const loadPromises = modelsToLoad.map(async ({ provider, model }) => {\r\n      try {\r\n        await this.loadModel(provider, model);\r\n      } catch (error) {\r\n        console.warn(`Failed to preload model ${provider}:${model}:`, error);\r\n      }\r\n    });\r\n\r\n    await Promise.all(loadPromises);\r\n  }\r\n\r\n  /**\r\n   * Оптимизация использования памяти\r\n   */\r\n  async optimizeMemory(options?: MemoryOptimizationOptions): Promise<void> {\r\n    const {\r\n      maxMemoryUsage = this.memoryLimit,\r\n      maxModels = this.maxModels,\r\n      idleTimeout = this.idleTimeout,\r\n      aggressive = false\r\n    } = options || {};\r\n\r\n    const currentMemory = this.getTotalMemoryUsage();\r\n    const currentModelCount = this.models.size;\r\n\r\n    // Список моделей для выгрузки, отсортированный по приоритету\r\n    const modelsToUnload = Array.from(this.models.values())\r\n      .filter(model => {\r\n        if (aggressive) return true;\r\n\r\n        const timeSinceLastUsed = Date.now() - model.lastUsed;\r\n        return timeSinceLastUsed > idleTimeout;\r\n      })\r\n      .sort((a, b) => {\r\n        // Приоритет выгрузки: старые + малоиспользуемые модели\r\n        const scoreA = a.lastUsed + (a.usageCount * 1000);\r\n        const scoreB = b.lastUsed + (b.usageCount * 1000);\r\n        return scoreA - scoreB;\r\n      });\r\n\r\n    // Выгружаем модели пока не достигнем целевых лимитов\r\n    let freedMemory = 0;\r\n    let unloadedCount = 0;\r\n\r\n    for (const model of modelsToUnload) {\r\n      const shouldUnload = (\r\n        (currentMemory - freedMemory) > maxMemoryUsage ||\r\n        (currentModelCount - unloadedCount) > maxModels\r\n      );\r\n\r\n      if (!shouldUnload) break;\r\n\r\n      try {\r\n        await this.unloadModel(model.modelId);\r\n        freedMemory += model.memoryUsage;\r\n        unloadedCount++;\r\n      } catch (error) {\r\n        console.warn(`Failed to unload model ${model.modelId}:`, error);\r\n      }\r\n    }\r\n\r\n    console.log(`Memory optimization completed: freed ${freedMemory}MB, unloaded ${unloadedCount} models`);\r\n  }\r\n\r\n  /**\r\n   * Получение статуса всех моделей\r\n   */\r\n  getModelStatus(): ModelStatus {\r\n    const loadedModels = Array.from(this.models.values());\r\n    const totalMemoryUsage = this.getTotalMemoryUsage();\r\n    const activeCount = loadedModels.filter(m => m.status === 'ready').length;\r\n\r\n    // Статистика по провайдерам\r\n    const providerStats: Record<EmbeddingProviderType, any> = {} as any;\r\n\r\n    for (const model of loadedModels) {\r\n      if (!providerStats[model.provider]) {\r\n        providerStats[model.provider] = {\r\n          count: 0,\r\n          memoryUsage: 0,\r\n          avgLoadTime: 0,\r\n          totalLoadTime: 0\r\n        };\r\n      }\r\n\r\n      const stats = providerStats[model.provider];\r\n      stats.count++;\r\n      stats.memoryUsage += model.memoryUsage;\r\n      stats.totalLoadTime += model.loadTime;\r\n      stats.avgLoadTime = stats.totalLoadTime / stats.count;\r\n    }\r\n\r\n    return {\r\n      loadedModels,\r\n      totalMemoryUsage,\r\n      activeCount,\r\n      providerStats\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Выгрузка неиспользуемых моделей\r\n   */\r\n  async unloadUnusedModels(): Promise<void> {\r\n    const cutoffTime = Date.now() - this.idleTimeout;\r\n    const modelsToUnload = Array.from(this.models.values())\r\n      .filter(model => model.lastUsed < cutoffTime && model.status !== 'loading');\r\n\r\n    const unloadPromises = modelsToUnload.map(model => this.unloadModel(model.modelId));\r\n    await Promise.all(unloadPromises);\r\n\r\n    console.log(`Unloaded ${modelsToUnload.length} unused models`);\r\n  }\r\n\r\n  /**\r\n   * Получение модели для коллекции\r\n   */\r\n  async getModelForCollection(collection: string): Promise<EmbeddingModel | null> {\r\n    // Заглушка - получение конфигурации коллекции\r\n    const config = await this.getCollectionConfig(collection);\r\n    if (!config) return null;\r\n\r\n    try {\r\n      return await this.loadModel(config.provider, config.model);\r\n    } catch (error) {\r\n      console.error(`Failed to load model for collection ${collection}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Прогрев модели\r\n   */\r\n  async warmModel(modelId: string): Promise<void> {\r\n    const model = this.models.get(modelId);\r\n    if (!model || model.status !== 'ready') {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Выполняем тестовый вызов для инициализации модели\r\n      const testText = \"test warmup query\";\r\n      await model.providerInstance.generateEmbedding(testText);\r\n      console.log(`Model ${modelId} warmed up successfully`);\r\n    } catch (error) {\r\n      console.warn(`Failed to warm up model ${modelId}:`, error);\r\n    }\r\n  }\r\n\r\n  // === Приватные методы ===\r\n\r\n  /**\r\n   * Загрузка новой модели\r\n   */\r\n  private async loadNewModel(provider: EmbeddingProviderType, model: string | undefined, modelId: string): Promise<EmbeddingModel> {\r\n    const startTime = Date.now();\r\n\r\n    // Создаем конфигурацию модели\r\n    const config: CollectionEmbeddingConfig = {\r\n      provider,\r\n      model: model || this.getDefaultModelForProvider(provider),\r\n      dimensions: this.getDimensionsForProvider(provider),\r\n      batchSize: 32,\r\n      cacheEnabled: true,\r\n      autoGenerate: true,\r\n      timeout: 30000\r\n    };\r\n\r\n    // Добавляем запись о загружающейся модели\r\n    const loadingModel: LoadedModel = {\r\n      modelId,\r\n      provider,\r\n      modelName: config.model!,\r\n      dimensions: config.dimensions,\r\n      providerInstance: null as any, // Будет установлено после загрузки\r\n      lastUsed: Date.now(),\r\n      usageCount: 0,\r\n      memoryUsage: this.estimateModelMemoryUsage(provider),\r\n      loadTime: 0,\r\n      status: 'loading'\r\n    };\r\n\r\n    this.models.set(modelId, loadingModel);\r\n    this.modelConfigs.set(modelId, config);\r\n\r\n    try {\r\n      // Создаем провайдера\r\n      const providerInstance = await providerFactory.createProvider(config);\r\n      const loadTime = Date.now() - startTime;\r\n\r\n      // Обновляем модель\r\n      loadingModel.providerInstance = providerInstance;\r\n      loadingModel.loadTime = loadTime;\r\n      loadingModel.status = 'ready';\r\n      loadingModel.usageCount = 1;\r\n\r\n      // Обновляем статистику\r\n      this.stats.totalLoads++;\r\n      this.stats.avgLoadTime = (this.stats.avgLoadTime * (this.stats.totalLoads - 1) + loadTime) / this.stats.totalLoads;\r\n\r\n      console.log(`Model ${modelId} loaded successfully in ${loadTime}ms`);\r\n\r\n      return {\r\n        config,\r\n        provider: providerInstance,\r\n        metrics: this.getModelMetrics(modelId)\r\n      };\r\n\r\n    } catch (error) {\r\n      // Помечаем модель как ошибочную\r\n      loadingModel.status = 'error';\r\n      loadingModel.error = error instanceof Error ? error.message : String(error);\r\n\r\n      throw new ModelLoadError(\r\n        `Failed to load model ${modelId}: ${loadingModel.error}`,\r\n        provider,\r\n        modelId,\r\n        undefined,\r\n        { model }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Выгрузка модели\r\n   */\r\n  private async unloadModel(modelId: string): Promise<void> {\r\n    const model = this.models.get(modelId);\r\n    if (!model) return;\r\n\r\n    model.status = 'unloading';\r\n\r\n    try {\r\n      // Освобождаем ресурсы провайдера, если есть соответствующий метод\r\n      if (model.providerInstance && typeof model.providerInstance.dispose === 'function') {\r\n        await model.providerInstance.dispose();\r\n      }\r\n\r\n      this.models.delete(modelId);\r\n      this.modelConfigs.delete(modelId);\r\n      this.stats.totalUnloads++;\r\n\r\n      console.log(`Model ${modelId} unloaded successfully`);\r\n\r\n    } catch (error) {\r\n      console.warn(`Failed to properly unload model ${modelId}:`, error);\r\n      // Удаляем из кэша в любом случае\r\n      this.models.delete(modelId);\r\n      this.modelConfigs.delete(modelId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ожидание завершения загрузки модели\r\n   */\r\n  private async waitForModelLoad(modelId: string): Promise<EmbeddingModel> {\r\n    const pollInterval = 100;\r\n    const maxWaitTime = 30000; // 30 секунд\r\n    const startTime = Date.now();\r\n\r\n    while (Date.now() - startTime < maxWaitTime) {\r\n      const model = this.models.get(modelId);\r\n      if (!model) {\r\n        throw new ModelLoadError(`Model ${modelId} was removed during loading`, 'unknown', modelId);\r\n      }\r\n\r\n      if (model.status === 'ready') {\r\n        model.lastUsed = Date.now();\r\n        model.usageCount++;\r\n\r\n        return {\r\n          config: this.modelConfigs.get(modelId)!,\r\n          provider: model.providerInstance,\r\n          metrics: this.getModelMetrics(modelId)\r\n        };\r\n      }\r\n\r\n      if (model.status === 'error') {\r\n        throw new ModelLoadError(`Model ${modelId} failed to load: ${model.error}`, 'unknown', modelId);\r\n      }\r\n\r\n      await new Promise(resolve => setTimeout(resolve, pollInterval));\r\n    }\r\n\r\n    throw new ModelLoadError(`Model ${modelId} loading timeout`, 'unknown', modelId);\r\n  }\r\n\r\n  /**\r\n   * Обеспечение доступности ресурсов\r\n   */\r\n  private async ensureResourcesAvailable(): Promise<void> {\r\n    const currentMemory = this.getTotalMemoryUsage();\r\n    const currentModelCount = this.models.size;\r\n\r\n    // Проверяем превышение лимитов\r\n    if (currentMemory > this.memoryLimit || currentModelCount >= this.maxModels) {\r\n      await this.optimizeMemory({\r\n        maxMemoryUsage: this.memoryLimit * 0.8, // Освобождаем до 80% лимита\r\n        maxModels: this.maxModels - 1 // Оставляем место для новой модели\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение общего использования памяти\r\n   */\r\n  private getTotalMemoryUsage(): number {\r\n    return Array.from(this.models.values())\r\n      .reduce((total, model) => total + model.memoryUsage, 0);\r\n  }\r\n\r\n  /**\r\n   * Генерация ID модели\r\n   */\r\n  private generateModelId(provider: EmbeddingProviderType, model?: string): string {\r\n    const modelName = model || this.getDefaultModelForProvider(provider);\r\n    return `${provider}:${modelName}`;\r\n  }\r\n\r\n  /**\r\n   * Получение модели по умолчанию для провайдера\r\n   */\r\n  private getDefaultModelForProvider(provider: EmbeddingProviderType): string {\r\n    const defaults: Record<EmbeddingProviderType, string> = {\r\n      transformers: 'all-MiniLM-L6-v2',\r\n      openai: 'text-embedding-3-small',\r\n      cohere: 'embed-english-light-v3.0',\r\n      huggingface: 'sentence-transformers/all-MiniLM-L6-v2',\r\n      custom: 'custom-model'\r\n    };\r\n\r\n    return defaults[provider] || 'unknown-model';\r\n  }\r\n\r\n  /**\r\n   * Получение размерности для провайдера\r\n   */\r\n  private getDimensionsForProvider(provider: EmbeddingProviderType): number {\r\n    const dimensions: Record<EmbeddingProviderType, number> = {\r\n      transformers: 384,\r\n      openai: 1536,\r\n      cohere: 1024,\r\n      huggingface: 384,\r\n      custom: 384\r\n    };\r\n\r\n    return dimensions[provider] || 384;\r\n  }\r\n\r\n  /**\r\n   * Оценка использования памяти моделью\r\n   */\r\n  private estimateModelMemoryUsage(provider: EmbeddingProviderType): number {\r\n    const estimates: Record<EmbeddingProviderType, number> = {\r\n      transformers: 100, // ~100MB для all-MiniLM-L6-v2\r\n      openai: 5,         // ~5MB для API клиента\r\n      cohere: 5,         // ~5MB для API клиента\r\n      huggingface: 80,   // ~80MB в среднем\r\n      custom: 50         // ~50MB по умолчанию\r\n    };\r\n\r\n    return estimates[provider] || 50;\r\n  }\r\n\r\n  /**\r\n   * Получение конфигурации коллекции (заглушка)\r\n   */\r\n  private async getCollectionConfig(collection: string): Promise<CollectionEmbeddingConfig | null> {\r\n    // Заглушка - в реальной реализации это будет запрос к базе данных\r\n    return {\r\n      provider: 'transformers',\r\n      model: 'all-MiniLM-L6-v2',\r\n      dimensions: 384,\r\n      batchSize: 32,\r\n      cacheEnabled: true,\r\n      autoGenerate: true,\r\n      timeout: 30000\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Получение моделей для предзагрузки\r\n   */\r\n  private getModelsForPreloading(strategy: LoadingStrategy): Array<{ provider: EmbeddingProviderType; model?: string }> {\r\n    switch (strategy) {\r\n      case 'eager':\r\n        // Загружаем все основные модели\r\n        return [\r\n          { provider: 'transformers', model: 'all-MiniLM-L6-v2' },\r\n          { provider: 'openai', model: 'text-embedding-3-small' }\r\n        ];\r\n\r\n      case 'predictive':\r\n        // Загружаем наиболее часто используемые модели\r\n        return [\r\n          { provider: 'transformers', model: 'all-MiniLM-L6-v2' }\r\n        ];\r\n\r\n      case 'lazy':\r\n      default:\r\n        // Не загружаем ничего заранее\r\n        return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение метрик производительности модели\r\n   */\r\n  private getModelMetrics(modelId: string): EmbeddingModel['metrics'] {\r\n    // Заглушка - в реальной реализации здесь будет реальная статистика\r\n    return {\r\n      averageInferenceTime: 150, // мс\r\n      totalRequests: 0,\r\n      successRate: 1.0,\r\n      lastPerformanceCheck: Date.now()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Запуск таймера автоматической очистки\r\n   */\r\n  private startCleanupTimer(interval: number): void {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n    }\r\n\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.unloadUnusedModels().catch(error => {\r\n        console.warn('Automated cleanup failed:', error);\r\n      });\r\n    }, interval);\r\n  }\r\n\r\n  /**\r\n   * Остановка таймера и освобождение ресурсов\r\n   */\r\n  dispose(): void {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n      this.cleanupInterval = null;\r\n    }\r\n\r\n    // Выгружаем все модели\r\n    const unloadPromises = Array.from(this.models.keys()).map(modelId => this.unloadModel(modelId));\r\n    Promise.all(unloadPromises).catch(error => {\r\n      console.warn('Failed to dispose all models:', error);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Фабричная функция для создания ModelManager\r\n */\r\nexport function createModelManager(options: {\r\n  memoryLimit?: number;\r\n  maxModels?: number;\r\n  idleTimeout?: number;\r\n  cleanupInterval?: number;\r\n} = {}): ModelManager {\r\n  return new ModelManagerImpl(options);\r\n}","/**\r\n * QueryCache - специализированный кэш для query embeddings\r\n *\r\n * Реализует LRU (Least Recently Used) кэширование с оптимизацией\r\n * для поисковых запросов. Включает интеллектуальную политику выселения,\r\n * приоритизацию по частоте использования и статистику производительности.\r\n */\r\n\r\nimport { CacheError } from '../embedding/errors.js';\r\n\r\n/**\r\n * Опции для записи в кэш\r\n */\r\nexport interface QueryCacheOptions {\r\n  /** Время жизни в миллисекундах */\r\n  ttl?: number;\r\n  /** Приоритет элемента */\r\n  priority?: 'low' | 'normal' | 'high';\r\n  /** Теги для группировки */\r\n  tags?: string[];\r\n}\r\n\r\n/**\r\n * Элемент кэша с метаданными\r\n */\r\nexport interface QueryCacheEntry<T = any> {\r\n  /** Ключ кэша */\r\n  key: string;\r\n  /** Значение */\r\n  value: T;\r\n  /** Время создания */\r\n  timestamp: number;\r\n  /** Время истечения */\r\n  expiresAt?: number;\r\n  /** Время последнего доступа */\r\n  lastAccessed: number;\r\n  /** Количество обращений */\r\n  accessCount: number;\r\n  /** Приоритет */\r\n  priority: 'low' | 'normal' | 'high';\r\n  /** Теги */\r\n  tags: string[];\r\n  /** Размер в байтах (приблизительно) */\r\n  size: number;\r\n}\r\n\r\n/**\r\n * Конфигурация QueryCache\r\n */\r\nexport interface QueryCacheConfig {\r\n  /** Максимальный размер кэша (количество элементов) */\r\n  maxSize?: number;\r\n  /** Максимальное использование памяти в байтах */\r\n  maxMemory?: number;\r\n  /** TTL по умолчанию в миллисекундах */\r\n  ttl?: number;\r\n  /** Интервал очистки устаревших элементов */\r\n  cleanupInterval?: number;\r\n  /** Стратегия выселения */\r\n  evictionStrategy?: 'lru' | 'lfu' | 'priority' | 'hybrid';\r\n}\r\n\r\n/**\r\n * Статистика QueryCache\r\n */\r\nexport interface QueryCacheStats {\r\n  /** Общее количество элементов */\r\n  size: number;\r\n  /** Максимальный размер */\r\n  maxSize: number;\r\n  /** Использование памяти в байтах */\r\n  memoryUsage: number;\r\n  /** Максимальное использование памяти */\r\n  maxMemory: number;\r\n  /** Количество попаданий */\r\n  hits: number;\r\n  /** Количество промахов */\r\n  misses: number;\r\n  /** Процент попаданий */\r\n  hitRate: number;\r\n  /** Количество выселений */\r\n  evictions: number;\r\n  /** Средний размер элемента */\r\n  averageEntrySize: number;\r\n  /** Количество истекших элементов */\r\n  expiredEntries: number;\r\n}\r\n\r\n/**\r\n * Основная реализация QueryCache\r\n */\r\nexport class QueryCache<T = any> {\r\n  private cache: Map<string, QueryCacheEntry<T>>;\r\n  private accessOrder: string[]; // Для LRU tracking\r\n  private config: Required<QueryCacheConfig>;\r\n  private cleanupTimer: NodeJS.Timeout | null;\r\n\r\n  // Статистика\r\n  private stats: {\r\n    hits: number;\r\n    misses: number;\r\n    evictions: number;\r\n    expiredEntries: number;\r\n    totalAccessTime: number;\r\n    totalAccessCount: number;\r\n  };\r\n\r\n  constructor(config: QueryCacheConfig = {}) {\r\n    this.cache = new Map();\r\n    this.accessOrder = [];\r\n\r\n    this.config = {\r\n      maxSize: config.maxSize || 1000,\r\n      maxMemory: config.maxMemory || 100 * 1024 * 1024, // 100MB\r\n      ttl: config.ttl || 5 * 60 * 1000, // 5 минут\r\n      cleanupInterval: config.cleanupInterval || 60 * 1000, // 1 минута\r\n      evictionStrategy: config.evictionStrategy || 'lru'\r\n    };\r\n\r\n    this.stats = {\r\n      hits: 0,\r\n      misses: 0,\r\n      evictions: 0,\r\n      expiredEntries: 0,\r\n      totalAccessTime: 0,\r\n      totalAccessCount: 0\r\n    };\r\n\r\n    this.cleanupTimer = null;\r\n    this.startCleanupTimer();\r\n  }\r\n\r\n  /**\r\n   * Получение значения из кэша\r\n   */\r\n  async get(key: string): Promise<T | null> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const entry = this.cache.get(key);\r\n\r\n      if (!entry) {\r\n        this.stats.misses++;\r\n        return null;\r\n      }\r\n\r\n      // Проверяем истечение TTL\r\n      if (entry.expiresAt && Date.now() > entry.expiresAt) {\r\n        this.cache.delete(key);\r\n        this.removeFromAccessOrder(key);\r\n        this.stats.expiredEntries++;\r\n        this.stats.misses++;\r\n        return null;\r\n      }\r\n\r\n      // Обновляем статистику доступа\r\n      entry.lastAccessed = Date.now();\r\n      entry.accessCount++;\r\n      this.moveToFront(key);\r\n\r\n      this.stats.hits++;\r\n      return entry.value;\r\n\r\n    } finally {\r\n      this.stats.totalAccessTime += Date.now() - startTime;\r\n      this.stats.totalAccessCount++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Сохранение значения в кэше\r\n   */\r\n  async set(key: string, value: T, options: QueryCacheOptions = {}): Promise<void> {\r\n    const {\r\n      ttl = this.config.ttl,\r\n      priority = 'normal',\r\n      tags = []\r\n    } = options;\r\n\r\n    const now = Date.now();\r\n    const size = this.estimateSize(value);\r\n\r\n    // Создаем элемент кэша\r\n    const entry: QueryCacheEntry<T> = {\r\n      key,\r\n      value,\r\n      timestamp: now,\r\n      expiresAt: ttl ? now + ttl : undefined,\r\n      lastAccessed: now,\r\n      accessCount: 1,\r\n      priority,\r\n      tags,\r\n      size\r\n    };\r\n\r\n    // Проверяем, нужно ли освободить место\r\n    await this.ensureSpace(size);\r\n\r\n    // Сохраняем элемент\r\n    if (this.cache.has(key)) {\r\n      // Обновляем существующий элемент\r\n      this.removeFromAccessOrder(key);\r\n    }\r\n\r\n    this.cache.set(key, entry);\r\n    this.accessOrder.unshift(key);\r\n\r\n    // Проверяем превышение лимитов после добавления\r\n    await this.enforceConstraints();\r\n  }\r\n\r\n  /**\r\n   * Удаление элемента из кэша\r\n   */\r\n  async delete(key: string): Promise<boolean> {\r\n    const deleted = this.cache.delete(key);\r\n    if (deleted) {\r\n      this.removeFromAccessOrder(key);\r\n    }\r\n    return deleted;\r\n  }\r\n\r\n  /**\r\n   * Проверка наличия ключа в кэше\r\n   */\r\n  has(key: string): boolean {\r\n    const entry = this.cache.get(key);\r\n    if (!entry) return false;\r\n\r\n    // Проверяем истечение TTL\r\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\r\n      this.cache.delete(key);\r\n      this.removeFromAccessOrder(key);\r\n      this.stats.expiredEntries++;\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Получение размера кэша\r\n   */\r\n  size(): number {\r\n    return this.cache.size;\r\n  }\r\n\r\n  /**\r\n   * Очистка кэша\r\n   */\r\n  async clear(): Promise<void> {\r\n    this.cache.clear();\r\n    this.accessOrder = [];\r\n\r\n    // Сброс статистики (кроме общих метрик)\r\n    const totalHits = this.stats.hits;\r\n    const totalMisses = this.stats.misses;\r\n\r\n    this.stats = {\r\n      hits: totalHits,\r\n      misses: totalMisses,\r\n      evictions: 0,\r\n      expiredEntries: 0,\r\n      totalAccessTime: this.stats.totalAccessTime,\r\n      totalAccessCount: this.stats.totalAccessCount\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Удаление элементов по паттерну или тегам\r\n   */\r\n  async invalidate(pattern: string): Promise<void> {\r\n    const keysToDelete: string[] = [];\r\n\r\n    if (pattern === '*') {\r\n      // Удаляем все элементы\r\n      keysToDelete.push(...this.cache.keys());\r\n    } else if (pattern.startsWith('tag:')) {\r\n      // Удаляем по тегу\r\n      const tag = pattern.substring(4);\r\n      for (const [key, entry] of this.cache.entries()) {\r\n        if (entry.tags.includes(tag)) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n    } else if (pattern.includes('*')) {\r\n      // Удаляем по wildcard паттерну\r\n      const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\r\n      for (const key of this.cache.keys()) {\r\n        if (regex.test(key)) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n    } else {\r\n      // Точное совпадение\r\n      if (this.cache.has(pattern)) {\r\n        keysToDelete.push(pattern);\r\n      }\r\n    }\r\n\r\n    // Удаляем найденные ключи\r\n    for (const key of keysToDelete) {\r\n      await this.delete(key);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение статистики кэша\r\n   */\r\n  getStats(): QueryCacheStats {\r\n    const memoryUsage = this.getMemoryUsage();\r\n    const totalRequests = this.stats.hits + this.stats.misses;\r\n    const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests) * 100 : 0;\r\n\r\n    const averageEntrySize = this.cache.size > 0\r\n      ? Array.from(this.cache.values()).reduce((sum, entry) => sum + entry.size, 0) / this.cache.size\r\n      : 0;\r\n\r\n    return {\r\n      size: this.cache.size,\r\n      maxSize: this.config.maxSize,\r\n      memoryUsage,\r\n      maxMemory: this.config.maxMemory,\r\n      hits: this.stats.hits,\r\n      misses: this.stats.misses,\r\n      hitRate,\r\n      evictions: this.stats.evictions,\r\n      averageEntrySize,\r\n      expiredEntries: this.stats.expiredEntries\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Оптимизация кэша\r\n   */\r\n  async optimize(): Promise<void> {\r\n    // Удаляем истекшие элементы\r\n    await this.cleanupExpired();\r\n\r\n    // Применяем стратегию выселения если нужно\r\n    await this.enforceConstraints();\r\n\r\n    // Дефрагментируем accessOrder\r\n    this.defragmentAccessOrder();\r\n  }\r\n\r\n  /**\r\n   * Получение текущего использования памяти\r\n   */\r\n  getMemoryUsage(): number {\r\n    let totalSize = 0;\r\n    for (const entry of this.cache.values()) {\r\n      totalSize += entry.size;\r\n    }\r\n    return totalSize;\r\n  }\r\n\r\n  // === Приватные методы ===\r\n\r\n  /**\r\n   * Обеспечение доступного места в кэше\r\n   */\r\n  private async ensureSpace(requiredSize: number): Promise<void> {\r\n    const currentMemory = this.getMemoryUsage();\r\n\r\n    if (currentMemory + requiredSize > this.config.maxMemory ||\r\n        this.cache.size >= this.config.maxSize) {\r\n      await this.evictEntries(requiredSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Применение ограничений кэша\r\n   */\r\n  private async enforceConstraints(): Promise<void> {\r\n    // Удаляем истекшие элементы\r\n    await this.cleanupExpired();\r\n\r\n    // Проверяем размерные ограничения\r\n    const currentMemory = this.getMemoryUsage();\r\n\r\n    if (currentMemory > this.config.maxMemory || this.cache.size > this.config.maxSize) {\r\n      await this.evictEntries(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Выселение элементов согласно стратегии\r\n   */\r\n  private async evictEntries(requiredSpace: number): Promise<void> {\r\n    const targetMemory = this.config.maxMemory * 0.8; // Освобождаем до 80% лимита\r\n    const targetSize = Math.floor(this.config.maxSize * 0.8);\r\n\r\n    let freedMemory = 0;\r\n    const keysToEvict: string[] = [];\r\n\r\n    // Сортируем элементы по приоритету выселения\r\n    const entries = Array.from(this.cache.entries());\r\n    const sortedEntries = this.sortForEviction(entries);\r\n\r\n    for (const [key, entry] of sortedEntries) {\r\n      keysToEvict.push(key);\r\n      freedMemory += entry.size;\r\n\r\n      const remainingMemory = this.getMemoryUsage() - freedMemory;\r\n      const remainingCount = this.cache.size - keysToEvict.length;\r\n\r\n      // Проверяем, достигли ли целевых показателей\r\n      if (remainingMemory <= targetMemory &&\r\n          remainingMemory <= this.config.maxMemory - requiredSpace &&\r\n          remainingCount <= targetSize) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Выселяем элементы\r\n    for (const key of keysToEvict) {\r\n      this.cache.delete(key);\r\n      this.removeFromAccessOrder(key);\r\n      this.stats.evictions++;\r\n    }\r\n\r\n    console.log(`Evicted ${keysToEvict.length} entries, freed ${freedMemory} bytes`);\r\n  }\r\n\r\n  /**\r\n   * Сортировка элементов для выселения\r\n   */\r\n  private sortForEviction(entries: [string, QueryCacheEntry<T>][]): [string, QueryCacheEntry<T>][] {\r\n    switch (this.config.evictionStrategy) {\r\n      case 'lru':\r\n        return entries.sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);\r\n\r\n      case 'lfu':\r\n        return entries.sort((a, b) => a[1].accessCount - b[1].accessCount);\r\n\r\n      case 'priority':\r\n        const priorityOrder = { 'low': 0, 'normal': 1, 'high': 2 };\r\n        return entries.sort((a, b) => {\r\n          const priorityDiff = priorityOrder[a[1].priority] - priorityOrder[b[1].priority];\r\n          if (priorityDiff !== 0) return priorityDiff;\r\n          return a[1].lastAccessed - b[1].lastAccessed; // LRU как tiebreaker\r\n        });\r\n\r\n      case 'hybrid':\r\n      default:\r\n        // Гибридная стратегия: учитываем приоритет, частоту и время\r\n        return entries.sort((a, b) => {\r\n          const priorityOrder = { 'low': 0, 'normal': 1, 'high': 2 };\r\n          const priorityScore = (entry: QueryCacheEntry<T>) => priorityOrder[entry.priority] * 1000;\r\n          const frequencyScore = (entry: QueryCacheEntry<T>) => entry.accessCount * 100;\r\n          const recencyScore = (entry: QueryCacheEntry<T>) => (Date.now() - entry.lastAccessed) / 1000;\r\n\r\n          const scoreA = priorityScore(a[1]) + frequencyScore(a[1]) - recencyScore(a[1]);\r\n          const scoreB = priorityScore(b[1]) + frequencyScore(b[1]) - recencyScore(b[1]);\r\n\r\n          return scoreA - scoreB; // Меньший score = выселяется первым\r\n        });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Очистка истекших элементов\r\n   */\r\n  private async cleanupExpired(): Promise<void> {\r\n    const now = Date.now();\r\n    const keysToDelete: string[] = [];\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (entry.expiresAt && now > entry.expiresAt) {\r\n        keysToDelete.push(key);\r\n      }\r\n    }\r\n\r\n    for (const key of keysToDelete) {\r\n      this.cache.delete(key);\r\n      this.removeFromAccessOrder(key);\r\n      this.stats.expiredEntries++;\r\n    }\r\n\r\n    if (keysToDelete.length > 0) {\r\n      console.log(`Cleaned up ${keysToDelete.length} expired entries`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Перемещение элемента в начало списка доступа (LRU)\r\n   */\r\n  private moveToFront(key: string): void {\r\n    this.removeFromAccessOrder(key);\r\n    this.accessOrder.unshift(key);\r\n  }\r\n\r\n  /**\r\n   * Удаление элемента из списка доступа\r\n   */\r\n  private removeFromAccessOrder(key: string): void {\r\n    const index = this.accessOrder.indexOf(key);\r\n    if (index > -1) {\r\n      this.accessOrder.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Дефрагментация списка доступа\r\n   */\r\n  private defragmentAccessOrder(): void {\r\n    this.accessOrder = this.accessOrder.filter(key => this.cache.has(key));\r\n  }\r\n\r\n  /**\r\n   * Оценка размера значения в байтах\r\n   */\r\n  private estimateSize(value: T): number {\r\n    try {\r\n      const jsonString = JSON.stringify(value);\r\n      return jsonString.length * 2; // UTF-16 uses 2 bytes per character\r\n    } catch {\r\n      // Fallback для объектов, которые не сериализуются\r\n      return 1000; // 1KB по умолчанию\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Запуск таймера очистки\r\n   */\r\n  private startCleanupTimer(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n    }\r\n\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanupExpired().catch(error => {\r\n        console.warn('Cleanup timer error:', error);\r\n      });\r\n    }, this.config.cleanupInterval);\r\n  }\r\n\r\n  /**\r\n   * Остановка таймера и освобождение ресурсов\r\n   */\r\n  dispose(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = null;\r\n    }\r\n\r\n    this.clear();\r\n  }\r\n}","/**\r\n * ModelCache - кэширование embedding моделей и их метаданных\r\n *\r\n * Специализированный кэш для embedding моделей, обеспечивающий:\r\n * - Кэширование загруженных моделей и их состояний\r\n * - Оптимизацию памяти для больших моделей\r\n * - Предзагрузку и warming стратегии\r\n * - Статистику использования моделей\r\n */\r\n\r\nimport type { EmbeddingProviderType } from '../embedding/types.js';\r\nimport type { EmbeddingProvider } from '../embedding/providers/BaseProvider.js';\r\nimport { CacheError } from '../embedding/errors.js';\r\n\r\n/**\r\n * Кэшированная информация о модели\r\n */\r\nexport interface CachedModelInfo {\r\n  /** ID модели */\r\n  modelId: string;\r\n  /** Тип провайдера */\r\n  provider: EmbeddingProviderType;\r\n  /** Название модели */\r\n  modelName: string;\r\n  /** Размерность эмбеддингов */\r\n  dimensions: number;\r\n  /** Время загрузки модели */\r\n  loadTime: number;\r\n  /** Время кэширования */\r\n  cachedAt: number;\r\n  /** Время последнего использования */\r\n  lastUsed: number;\r\n  /** Количество использований */\r\n  usageCount: number;\r\n  /** Приблизительное использование памяти в MB */\r\n  memoryUsage: number;\r\n  /** Статус модели */\r\n  status: 'cached' | 'loading' | 'ready' | 'error';\r\n  /** Метаданные производительности */\r\n  performance: {\r\n    averageInferenceTime: number;\r\n    successRate: number;\r\n    errorCount: number;\r\n    lastBenchmark: number;\r\n  };\r\n  /** Теги для группировки */\r\n  tags: string[];\r\n}\r\n\r\n/**\r\n * Конфигурация ModelCache\r\n */\r\nexport interface ModelCacheConfig {\r\n  /** Максимальное количество моделей в кэше */\r\n  maxSize?: number;\r\n  /** Максимальное использование памяти в MB */\r\n  maxMemory?: number;\r\n  /** TTL для кэшированных моделей в мс */\r\n  ttl?: number;\r\n  /** Стратегия выселения моделей */\r\n  evictionStrategy?: 'lru' | 'memory_usage' | 'usage_count' | 'hybrid';\r\n  /** Интервал оптимизации кэша */\r\n  optimizationInterval?: number;\r\n}\r\n\r\n/**\r\n * Статистика ModelCache\r\n */\r\nexport interface ModelCacheStats {\r\n  /** Количество кэшированных моделей */\r\n  size: number;\r\n  /** Максимальный размер кэша */\r\n  maxSize: number;\r\n  /** Общее использование памяти в MB */\r\n  memoryUsage: number;\r\n  /** Максимально разрешенная память */\r\n  maxMemory: number;\r\n  /** Статистика по провайдерам */\r\n  providerStats: Record<string, {\r\n    count: number;\r\n    memoryUsage: number;\r\n    avgInferenceTime: number;\r\n    successRate: number;\r\n  }>;\r\n  /** Производительность кэша */\r\n  cachePerformance: {\r\n    hits: number;\r\n    misses: number;\r\n    hitRate: number;\r\n    evictions: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Запись в кэше моделей\r\n */\r\nexport interface ModelCacheEntry {\r\n  /** Информация о модели */\r\n  modelInfo: CachedModelInfo;\r\n  /** Экземпляр провайдера (если загружен) */\r\n  providerInstance?: EmbeddingProvider;\r\n  /** Время истечения кэша */\r\n  expiresAt?: number;\r\n}\r\n\r\n/**\r\n * Основная реализация ModelCache\r\n */\r\nexport class ModelCache {\r\n  private cache: Map<string, ModelCacheEntry>;\r\n  private config: Required<ModelCacheConfig>;\r\n  private optimizationTimer: NodeJS.Timeout | null;\r\n\r\n  // Статистика\r\n  private stats: {\r\n    hits: number;\r\n    misses: number;\r\n    evictions: number;\r\n    totalLoadTime: number;\r\n    totalLoads: number;\r\n  };\r\n\r\n  constructor(config: ModelCacheConfig = {}) {\r\n    this.cache = new Map();\r\n\r\n    this.config = {\r\n      maxSize: config.maxSize || 10,\r\n      maxMemory: config.maxMemory || 500, // 500MB\r\n      ttl: config.ttl || 30 * 60 * 1000, // 30 минут\r\n      evictionStrategy: config.evictionStrategy || 'hybrid',\r\n      optimizationInterval: config.optimizationInterval || 5 * 60 * 1000 // 5 минут\r\n    };\r\n\r\n    this.stats = {\r\n      hits: 0,\r\n      misses: 0,\r\n      evictions: 0,\r\n      totalLoadTime: 0,\r\n      totalLoads: 0\r\n    };\r\n\r\n    this.optimizationTimer = null;\r\n    this.startOptimizationTimer();\r\n  }\r\n\r\n  /**\r\n   * Получение модели из кэша\r\n   */\r\n  async get(modelId: string): Promise<CachedModelInfo | null> {\r\n    const entry = this.cache.get(modelId);\r\n\r\n    if (!entry) {\r\n      this.stats.misses++;\r\n      return null;\r\n    }\r\n\r\n    // Проверяем истечение TTL\r\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\r\n      this.cache.delete(modelId);\r\n      this.stats.misses++;\r\n      return null;\r\n    }\r\n\r\n    // Обновляем статистику использования\r\n    entry.modelInfo.lastUsed = Date.now();\r\n    entry.modelInfo.usageCount++;\r\n\r\n    this.stats.hits++;\r\n    return entry.modelInfo;\r\n  }\r\n\r\n  /**\r\n   * Сохранение модели в кэш\r\n   */\r\n  async set(modelId: string, modelInfo: CachedModelInfo, providerInstance?: EmbeddingProvider): Promise<void> {\r\n    // Проверяем необходимость освобождения места\r\n    await this.ensureSpace(modelInfo.memoryUsage);\r\n\r\n    const entry: ModelCacheEntry = {\r\n      modelInfo: {\r\n        ...modelInfo,\r\n        cachedAt: Date.now(),\r\n        lastUsed: Date.now()\r\n      },\r\n      providerInstance,\r\n      expiresAt: this.config.ttl ? Date.now() + this.config.ttl : undefined\r\n    };\r\n\r\n    this.cache.set(modelId, entry);\r\n    this.stats.totalLoads++;\r\n    this.stats.totalLoadTime += modelInfo.loadTime;\r\n\r\n    console.log(`Model ${modelId} cached successfully (${modelInfo.memoryUsage}MB)`);\r\n  }\r\n\r\n  /**\r\n   * Получение экземпляра провайдера\r\n   */\r\n  async getProvider(modelId: string): Promise<EmbeddingProvider | null> {\r\n    const entry = this.cache.get(modelId);\r\n    return entry?.providerInstance || null;\r\n  }\r\n\r\n  /**\r\n   * Обновление производительности модели\r\n   */\r\n  async updatePerformance(modelId: string, stats: {\r\n    inferenceTime?: number;\r\n    success?: boolean;\r\n    error?: boolean;\r\n  }): Promise<void> {\r\n    const entry = this.cache.get(modelId);\r\n    if (!entry) return;\r\n\r\n    const perf = entry.modelInfo.performance;\r\n\r\n    if (stats.inferenceTime !== undefined) {\r\n      const totalInferences = entry.modelInfo.usageCount;\r\n      perf.averageInferenceTime = totalInferences > 1\r\n        ? (perf.averageInferenceTime * (totalInferences - 1) + stats.inferenceTime) / totalInferences\r\n        : stats.inferenceTime;\r\n    }\r\n\r\n    if (stats.success !== undefined) {\r\n      const totalRequests = entry.modelInfo.usageCount;\r\n      const successfulRequests = Math.round(perf.successRate * (totalRequests - 1));\r\n      const newSuccessful = successfulRequests + (stats.success ? 1 : 0);\r\n      perf.successRate = newSuccessful / totalRequests;\r\n    }\r\n\r\n    if (stats.error) {\r\n      perf.errorCount++;\r\n    }\r\n\r\n    perf.lastBenchmark = Date.now();\r\n  }\r\n\r\n  /**\r\n   * Проверка наличия модели в кэше\r\n   */\r\n  has(modelId: string): boolean {\r\n    const entry = this.cache.get(modelId);\r\n    if (!entry) return false;\r\n\r\n    // Проверяем истечение TTL\r\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\r\n      this.cache.delete(modelId);\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Удаление модели из кэша\r\n   */\r\n  async delete(modelId: string): Promise<boolean> {\r\n    const entry = this.cache.get(modelId);\r\n    if (!entry) return false;\r\n\r\n    // Освобождаем ресурсы провайдера\r\n    if (entry.providerInstance && 'dispose' in entry.providerInstance && typeof (entry.providerInstance as any).dispose === 'function') {\r\n      try {\r\n        await (entry.providerInstance as any).dispose();\r\n      } catch (error) {\r\n        console.warn(`Failed to dispose provider for model ${modelId}:`, error);\r\n      }\r\n    }\r\n\r\n    return this.cache.delete(modelId);\r\n  }\r\n\r\n  /**\r\n   * Удаление моделей по паттерну\r\n   */\r\n  async invalidate(pattern: string): Promise<void> {\r\n    const keysToDelete: string[] = [];\r\n\r\n    if (pattern === '*') {\r\n      keysToDelete.push(...this.cache.keys());\r\n    } else if (pattern.startsWith('provider:')) {\r\n      const provider = pattern.substring(9);\r\n      for (const [key, entry] of this.cache.entries()) {\r\n        if (entry.modelInfo.provider === provider) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n    } else if (pattern.startsWith('tag:')) {\r\n      const tag = pattern.substring(4);\r\n      for (const [key, entry] of this.cache.entries()) {\r\n        if (entry.modelInfo.tags.includes(tag)) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n    } else if (pattern.includes('*')) {\r\n      const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\r\n      for (const key of this.cache.keys()) {\r\n        if (regex.test(key)) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n    } else {\r\n      if (this.cache.has(pattern)) {\r\n        keysToDelete.push(pattern);\r\n      }\r\n    }\r\n\r\n    // Удаляем найденные модели\r\n    for (const key of keysToDelete) {\r\n      await this.delete(key);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение всех кэшированных моделей\r\n   */\r\n  getAllModels(): CachedModelInfo[] {\r\n    return Array.from(this.cache.values()).map(entry => entry.modelInfo);\r\n  }\r\n\r\n  /**\r\n   * Получение моделей по провайдеру\r\n   */\r\n  getModelsByProvider(provider: EmbeddingProviderType): CachedModelInfo[] {\r\n    return this.getAllModels().filter(model => model.provider === provider);\r\n  }\r\n\r\n  /**\r\n   * Получение наиболее используемых моделей\r\n   */\r\n  getMostUsedModels(limit: number = 5): CachedModelInfo[] {\r\n    return this.getAllModels()\r\n      .sort((a, b) => b.usageCount - a.usageCount)\r\n      .slice(0, limit);\r\n  }\r\n\r\n  /**\r\n   * Получение статистики кэша\r\n   */\r\n  getStats(): ModelCacheStats {\r\n    const models = this.getAllModels();\r\n    const totalMemoryUsage = models.reduce((sum, model) => sum + model.memoryUsage, 0);\r\n\r\n    // Статистика по провайдерам\r\n    const providerStats: Record<string, any> = {};\r\n    for (const model of models) {\r\n      if (!providerStats[model.provider]) {\r\n        providerStats[model.provider] = {\r\n          count: 0,\r\n          memoryUsage: 0,\r\n          totalInferenceTime: 0,\r\n          totalSuccessRate: 0\r\n        };\r\n      }\r\n\r\n      const stats = providerStats[model.provider];\r\n      stats.count++;\r\n      stats.memoryUsage += model.memoryUsage;\r\n      stats.totalInferenceTime += model.performance.averageInferenceTime;\r\n      stats.totalSuccessRate += model.performance.successRate;\r\n    }\r\n\r\n    // Вычисляем средние значения\r\n    for (const provider of Object.keys(providerStats)) {\r\n      const stats = providerStats[provider];\r\n      stats.avgInferenceTime = stats.totalInferenceTime / stats.count;\r\n      stats.successRate = stats.totalSuccessRate / stats.count;\r\n      delete stats.totalInferenceTime;\r\n      delete stats.totalSuccessRate;\r\n    }\r\n\r\n    const totalRequests = this.stats.hits + this.stats.misses;\r\n    const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests) * 100 : 0;\r\n\r\n    return {\r\n      size: this.cache.size,\r\n      maxSize: this.config.maxSize,\r\n      memoryUsage: totalMemoryUsage,\r\n      maxMemory: this.config.maxMemory,\r\n      providerStats,\r\n      cachePerformance: {\r\n        hits: this.stats.hits,\r\n        misses: this.stats.misses,\r\n        hitRate,\r\n        evictions: this.stats.evictions\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Очистка всего кэша\r\n   */\r\n  async clear(): Promise<void> {\r\n    const deletePromises = Array.from(this.cache.keys()).map(key => this.delete(key));\r\n    await Promise.all(deletePromises);\r\n\r\n    this.cache.clear();\r\n\r\n    // Сброс статистики\r\n    this.stats = {\r\n      hits: this.stats.hits,\r\n      misses: this.stats.misses,\r\n      evictions: 0,\r\n      totalLoadTime: 0,\r\n      totalLoads: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Оптимизация кэша\r\n   */\r\n  async optimize(): Promise<void> {\r\n    // Удаляем истекшие модели\r\n    await this.cleanupExpired();\r\n\r\n    // Применяем стратегию выселения если превышены лимиты\r\n    const currentMemory = this.getCurrentMemoryUsage();\r\n    if (currentMemory > this.config.maxMemory || this.cache.size > this.config.maxSize) {\r\n      await this.evictModels();\r\n    }\r\n\r\n    console.log('Model cache optimization completed');\r\n  }\r\n\r\n  /**\r\n   * Получение текущего использования памяти\r\n   */\r\n  getMemoryUsage(): number {\r\n    return this.getCurrentMemoryUsage();\r\n  }\r\n\r\n  // === Приватные методы ===\r\n\r\n  /**\r\n   * Обеспечение свободного места в кэше\r\n   */\r\n  private async ensureSpace(requiredMemory: number): Promise<void> {\r\n    const currentMemory = this.getCurrentMemoryUsage();\r\n\r\n    if (currentMemory + requiredMemory > this.config.maxMemory ||\r\n        this.cache.size >= this.config.maxSize) {\r\n      await this.evictModels(requiredMemory);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Выселение моделей согласно стратегии\r\n   */\r\n  private async evictModels(requiredSpace: number = 0): Promise<void> {\r\n    const targetMemory = Math.min(\r\n      this.config.maxMemory * 0.8,\r\n      this.config.maxMemory - requiredSpace\r\n    );\r\n    const targetSize = Math.floor(this.config.maxSize * 0.8);\r\n\r\n    const entries = Array.from(this.cache.entries());\r\n    const sortedEntries = this.sortForEviction(entries);\r\n\r\n    let freedMemory = 0;\r\n    const keysToEvict: string[] = [];\r\n\r\n    for (const [key, entry] of sortedEntries) {\r\n      keysToEvict.push(key);\r\n      freedMemory += entry.modelInfo.memoryUsage;\r\n\r\n      const remainingMemory = this.getCurrentMemoryUsage() - freedMemory;\r\n      const remainingCount = this.cache.size - keysToEvict.length;\r\n\r\n      if (remainingMemory <= targetMemory && remainingCount <= targetSize) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Выселяем модели\r\n    for (const key of keysToEvict) {\r\n      await this.delete(key);\r\n      this.stats.evictions++;\r\n    }\r\n\r\n    console.log(`Evicted ${keysToEvict.length} models, freed ${freedMemory}MB`);\r\n  }\r\n\r\n  /**\r\n   * Сортировка моделей для выселения\r\n   */\r\n  private sortForEviction(entries: [string, ModelCacheEntry][]): [string, ModelCacheEntry][] {\r\n    switch (this.config.evictionStrategy) {\r\n      case 'lru':\r\n        return entries.sort((a, b) => a[1].modelInfo.lastUsed - b[1].modelInfo.lastUsed);\r\n\r\n      case 'memory_usage':\r\n        return entries.sort((a, b) => b[1].modelInfo.memoryUsage - a[1].modelInfo.memoryUsage);\r\n\r\n      case 'usage_count':\r\n        return entries.sort((a, b) => a[1].modelInfo.usageCount - b[1].modelInfo.usageCount);\r\n\r\n      case 'hybrid':\r\n      default:\r\n        // Гибридная стратегия: учитываем все факторы\r\n        return entries.sort((a, b) => {\r\n          const scoreA = this.calculateEvictionScore(a[1].modelInfo);\r\n          const scoreB = this.calculateEvictionScore(b[1].modelInfo);\r\n          return scoreA - scoreB; // Меньший score = выселяется первым\r\n        });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Вычисление оценки для выселения (гибридная стратегия)\r\n   */\r\n  private calculateEvictionScore(model: CachedModelInfo): number {\r\n    const now = Date.now();\r\n    const ageScore = (now - model.lastUsed) / (60 * 1000); // Минуты с последнего использования\r\n    const usageScore = Math.max(1, model.usageCount) * 100; // Частота использования\r\n    const memoryScore = model.memoryUsage * 10; // Использование памяти\r\n    const performanceScore = model.performance.successRate * 50; // Производительность\r\n\r\n    // Итоговая оценка: возраст + память - использование - производительность\r\n    return ageScore + memoryScore - usageScore - performanceScore;\r\n  }\r\n\r\n  /**\r\n   * Очистка истекших моделей\r\n   */\r\n  private async cleanupExpired(): Promise<void> {\r\n    const now = Date.now();\r\n    const keysToDelete: string[] = [];\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (entry.expiresAt && now > entry.expiresAt) {\r\n        keysToDelete.push(key);\r\n      }\r\n    }\r\n\r\n    for (const key of keysToDelete) {\r\n      await this.delete(key);\r\n    }\r\n\r\n    if (keysToDelete.length > 0) {\r\n      console.log(`Cleaned up ${keysToDelete.length} expired models`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение текущего использования памяти\r\n   */\r\n  private getCurrentMemoryUsage(): number {\r\n    let totalMemory = 0;\r\n    for (const entry of this.cache.values()) {\r\n      totalMemory += entry.modelInfo.memoryUsage;\r\n    }\r\n    return totalMemory;\r\n  }\r\n\r\n  /**\r\n   * Запуск таймера оптимизации\r\n   */\r\n  private startOptimizationTimer(): void {\r\n    if (this.optimizationTimer) {\r\n      clearInterval(this.optimizationTimer);\r\n    }\r\n\r\n    this.optimizationTimer = setInterval(() => {\r\n      this.optimize().catch(error => {\r\n        console.warn('Model cache optimization failed:', error);\r\n      });\r\n    }, this.config.optimizationInterval);\r\n  }\r\n\r\n  /**\r\n   * Остановка таймера и освобождение ресурсов\r\n   */\r\n  dispose(): void {\r\n    if (this.optimizationTimer) {\r\n      clearInterval(this.optimizationTimer);\r\n      this.optimizationTimer = null;\r\n    }\r\n\r\n    this.clear().catch(error => {\r\n      console.warn('Failed to clear model cache during disposal:', error);\r\n    });\r\n  }\r\n}","/**\r\n * CacheManager - координатор многоуровневого кэширования\r\n *\r\n * Реализует трехуровневую архитектуру кэширования:\r\n * 1. Memory Cache - быстрый доступ, ограниченный размер\r\n * 2. IndexedDB - персистентное хранилище в браузере\r\n * 3. SQLite Database - долгосрочное хранение через worker\r\n *\r\n * Стратегия кэширования:\r\n * - Чтение: Memory → IndexedDB → SQLite → null\r\n * - Запись: во все уровни с разными TTL\r\n * - Invalidation: каскадная очистка по паттернам\r\n */\r\n\r\nimport { QueryCache } from './QueryCache.js';\r\nimport { ModelCache } from './ModelCache.js';\r\nimport { EmbeddingError, CacheError } from '../embedding/errors.js';\r\n\r\n/**\r\n * Уровни кэширования\r\n */\r\nexport type CacheLevel = 'memory' | 'indexeddb' | 'database';\r\n\r\n/**\r\n * Опции кэширования\r\n */\r\nexport interface CacheOptions {\r\n  /** Уровень кэша для записи */\r\n  level?: CacheLevel;\r\n  /** Время жизни в миллисекундах */\r\n  ttl?: number;\r\n  /** Теги для группировки данных */\r\n  tags?: string[];\r\n  /** Приоритет элемента кэша */\r\n  priority?: 'low' | 'normal' | 'high';\r\n  /** Сжатие данных */\r\n  compression?: boolean;\r\n}\r\n\r\n/**\r\n * Статистика кэширования\r\n */\r\nexport interface CacheStatistics {\r\n  /** Общее количество запросов */\r\n  totalRequests: number;\r\n  /** Попадания в кэш */\r\n  hits: {\r\n    memory: number;\r\n    indexeddb: number;\r\n    database: number;\r\n    total: number;\r\n  };\r\n  /** Промахи кэша */\r\n  misses: number;\r\n  /** Процент попаданий */\r\n  hitRate: number;\r\n  /** Использование памяти по уровням (MB) */\r\n  memoryUsage: {\r\n    memory: number;\r\n    indexeddb: number;\r\n    database: number;\r\n  };\r\n  /** Средние времена доступа (мс) */\r\n  avgAccessTime: {\r\n    memory: number;\r\n    indexeddb: number;\r\n    database: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Результат операции кэширования\r\n */\r\nexport interface CacheResult<T = any> {\r\n  /** Данные из кэша */\r\n  data: T | null;\r\n  /** Источник данных */\r\n  source: CacheLevel | 'miss';\r\n  /** Время доступа в мс */\r\n  accessTime: number;\r\n  /** Попадание в кэш */\r\n  hit: boolean;\r\n}\r\n\r\n/**\r\n * Интерфейс CacheManager\r\n */\r\nexport interface CacheManager {\r\n  /**\r\n   * Получение данных из кэша (проверка всех уровней)\r\n   */\r\n  get<T = any>(key: string, level?: CacheLevel): Promise<T | null>;\r\n\r\n  /**\r\n   * Сохранение данных в кэш\r\n   */\r\n  set<T = any>(key: string, value: T, options?: CacheOptions): Promise<void>;\r\n\r\n  /**\r\n   * Удаление данных по паттерну или конкретному ключу\r\n   */\r\n  invalidate(pattern: string): Promise<void>;\r\n\r\n  /**\r\n   * Предварительный прогрев кэша\r\n   */\r\n  warmCache(collection: string, queries: string[]): Promise<void>;\r\n\r\n  /**\r\n   * Предзагрузка моделей в кэш\r\n   */\r\n  preloadModels(providers: string[]): Promise<void>;\r\n\r\n  /**\r\n   * Получение статистики кэширования\r\n   */\r\n  getStats(): CacheStatistics;\r\n\r\n  /**\r\n   * Очистка всех уровней кэша\r\n   */\r\n  clear(): Promise<void>;\r\n\r\n  /**\r\n   * Оптимизация кэша (удаление устаревших данных)\r\n   */\r\n  optimize(): Promise<void>;\r\n}\r\n\r\n/**\r\n * Основная реализация CacheManager\r\n */\r\nexport class CacheManagerImpl implements CacheManager {\r\n  private queryCache: QueryCache;\r\n  private modelCache: ModelCache;\r\n\r\n  // Статистика производительности\r\n  private stats: {\r\n    totalRequests: number;\r\n    memoryHits: number;\r\n    indexedDBHits: number;\r\n    databaseHits: number;\r\n    misses: number;\r\n    totalAccessTime: number;\r\n    levelAccessTimes: Map<CacheLevel, { total: number; count: number }>;\r\n  };\r\n\r\n  // IndexedDB для второго уровня кэширования\r\n  private indexedDB: IDBDatabase | null;\r\n  private dbReady: Promise<void>;\r\n\r\n  constructor(options: {\r\n    memorySize?: number;\r\n    indexedDBName?: string;\r\n    dbVersion?: number;\r\n  } = {}) {\r\n    this.queryCache = new QueryCache({\r\n      maxSize: options.memorySize || 1000,\r\n      ttl: 5 * 60 * 1000, // 5 минут для memory cache\r\n    });\r\n\r\n    this.modelCache = new ModelCache({\r\n      maxSize: 50, // Максимум 50 моделей в кэше\r\n      ttl: 30 * 60 * 1000, // 30 минут для моделей\r\n    });\r\n\r\n    this.stats = {\r\n      totalRequests: 0,\r\n      memoryHits: 0,\r\n      indexedDBHits: 0,\r\n      databaseHits: 0,\r\n      misses: 0,\r\n      totalAccessTime: 0,\r\n      levelAccessTimes: new Map([\r\n        ['memory', { total: 0, count: 0 }],\r\n        ['indexeddb', { total: 0, count: 0 }],\r\n        ['database', { total: 0, count: 0 }]\r\n      ])\r\n    };\r\n\r\n    this.indexedDB = null;\r\n    this.dbReady = this.initIndexedDB(options.indexedDBName || 'LocalRetrieveCache', options.dbVersion || 1);\r\n  }\r\n\r\n  /**\r\n   * Получение данных с каскадным поиском по уровням кэша\r\n   */\r\n  async get<T = any>(key: string, level?: CacheLevel): Promise<T | null> {\r\n    const startTime = Date.now();\r\n    this.stats.totalRequests++;\r\n\r\n    try {\r\n      // Если указан конкретный уровень, ищем только в нем\r\n      if (level) {\r\n        const result = await this.getFromLevel<T>(key, level);\r\n        this.updateAccessTimeStats(level, Date.now() - startTime);\r\n        return result;\r\n      }\r\n\r\n      // Поиск по всем уровням в порядке приоритета\r\n\r\n      // Уровень 1: Memory Cache\r\n      const memoryResult = await this.getFromLevel<T>(key, 'memory');\r\n      if (memoryResult !== null) {\r\n        this.stats.memoryHits++;\r\n        this.updateAccessTimeStats('memory', Date.now() - startTime);\r\n        return memoryResult;\r\n      }\r\n\r\n      // Уровень 2: IndexedDB\r\n      const indexedDBResult = await this.getFromLevel<T>(key, 'indexeddb');\r\n      if (indexedDBResult !== null) {\r\n        this.stats.indexedDBHits++;\r\n        this.updateAccessTimeStats('indexeddb', Date.now() - startTime);\r\n\r\n        // Восстанавливаем в memory cache для быстрого доступа\r\n        await this.queryCache.set(key, indexedDBResult);\r\n\r\n        return indexedDBResult;\r\n      }\r\n\r\n      // Уровень 3: Database (через SQLite)\r\n      const databaseResult = await this.getFromLevel<T>(key, 'database');\r\n      if (databaseResult !== null) {\r\n        this.stats.databaseHits++;\r\n        this.updateAccessTimeStats('database', Date.now() - startTime);\r\n\r\n        // Восстанавливаем в вышестоящие кэши\r\n        await Promise.all([\r\n          this.queryCache.set(key, databaseResult),\r\n          this.setInIndexedDB(key, databaseResult, { ttl: 24 * 60 * 60 * 1000 }) // 24 часа\r\n        ]);\r\n\r\n        return databaseResult;\r\n      }\r\n\r\n      // Ничего не найдено\r\n      this.stats.misses++;\r\n      return null;\r\n\r\n    } catch (error) {\r\n      console.warn(`Cache get operation failed for key \"${key}\":`, error);\r\n      this.stats.misses++;\r\n      return null;\r\n    } finally {\r\n      this.stats.totalAccessTime += Date.now() - startTime;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Сохранение данных во всех уровнях кэша\r\n   */\r\n  async set<T = any>(key: string, value: T, options?: CacheOptions): Promise<void> {\r\n    const {\r\n      level,\r\n      ttl,\r\n      tags = [],\r\n      priority = 'normal',\r\n      compression = false\r\n    } = options || {};\r\n\r\n    try {\r\n      const promises: Promise<void>[] = [];\r\n\r\n      if (!level || level === 'memory') {\r\n        // Сохранение в memory cache\r\n        promises.push(this.queryCache.set(key, value, {\r\n          ttl: ttl || 5 * 60 * 1000, // 5 минут по умолчанию\r\n          priority,\r\n          tags\r\n        }));\r\n      }\r\n\r\n      if (!level || level === 'indexeddb') {\r\n        // Сохранение в IndexedDB\r\n        promises.push(this.setInIndexedDB(key, value, {\r\n          ttl: ttl || 24 * 60 * 60 * 1000, // 24 часа по умолчанию\r\n          tags,\r\n          compression\r\n        }));\r\n      }\r\n\r\n      if (!level || level === 'database') {\r\n        // Сохранение в SQLite database (заглушка - будет реализовано в worker integration)\r\n        promises.push(this.setInDatabase(key, value, {\r\n          ttl: ttl || 7 * 24 * 60 * 60 * 1000, // 7 дней по умолчанию\r\n          tags\r\n        }));\r\n      }\r\n\r\n      await Promise.all(promises);\r\n\r\n    } catch (error) {\r\n      throw new CacheError(\r\n        `Failed to set cache value for key \"${key}\": ${error instanceof Error ? error.message : String(error)}`,\r\n        'SET_FAILED',\r\n        key,\r\n        { level, options }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Каскадное удаление данных по паттерну\r\n   */\r\n  async invalidate(pattern: string): Promise<void> {\r\n    const promises: Promise<void>[] = [];\r\n\r\n    try {\r\n      // Очистка во всех кэшах\r\n      promises.push(this.queryCache.invalidate(pattern));\r\n      promises.push(this.modelCache.invalidate(pattern));\r\n      promises.push(this.invalidateIndexedDB(pattern));\r\n      promises.push(this.invalidateDatabase(pattern));\r\n\r\n      await Promise.all(promises);\r\n\r\n    } catch (error) {\r\n      throw new CacheError(\r\n        `Failed to invalidate cache pattern \"${pattern}\": ${error instanceof Error ? error.message : String(error)}`,\r\n        'INVALIDATION_FAILED',\r\n        pattern\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Предварительный прогрев кэша для популярных запросов\r\n   */\r\n  async warmCache(collection: string, queries: string[]): Promise<void> {\r\n    // Заглушка - в реальной реализации здесь будет взаимодействие с InternalPipeline\r\n    console.log(`Warming cache for collection \"${collection}\" with ${queries.length} queries`);\r\n\r\n    // Пока что просто сохраняем пустые плейсхолдеры\r\n    const warmupPromises = queries.map(async (query, index) => {\r\n      const cacheKey = `warmup:${collection}:${this.hashString(query)}`;\r\n      const placeholder = {\r\n        warmedAt: Date.now(),\r\n        collection,\r\n        query,\r\n        status: 'placeholder'\r\n      };\r\n\r\n      await this.set(cacheKey, placeholder, {\r\n        level: 'memory',\r\n        ttl: 10 * 60 * 1000, // 10 минут для прогрева\r\n        tags: ['warmup', collection]\r\n      });\r\n    });\r\n\r\n    await Promise.all(warmupPromises);\r\n  }\r\n\r\n  /**\r\n   * Предзагрузка моделей в кэш\r\n   */\r\n  async preloadModels(providers: string[]): Promise<void> {\r\n    // Используем ModelCache для предзагрузки\r\n    const preloadPromises = providers.map(async (provider) => {\r\n      const modelInfo: import('./ModelCache.js').CachedModelInfo = {\r\n        modelId: `${provider}-default`,\r\n        provider: provider as any, // Type assertion for provider\r\n        modelName: `${provider} Default Model`,\r\n        dimensions: 384, // Default dimensions\r\n        loadTime: 0,\r\n        cachedAt: Date.now(),\r\n        lastUsed: Date.now(),\r\n        usageCount: 0,\r\n        memoryUsage: 0,\r\n        status: 'ready',\r\n        performance: {\r\n          averageInferenceTime: 0,\r\n          successRate: 1.0,\r\n          errorCount: 0,\r\n          lastBenchmark: Date.now()\r\n        },\r\n        tags: ['default', 'preloaded']\r\n      };\r\n\r\n      await this.modelCache.set(`model:${provider}`, modelInfo);\r\n    });\r\n\r\n    await Promise.all(preloadPromises);\r\n    console.log(`Preloaded ${providers.length} models into cache`);\r\n  }\r\n\r\n  /**\r\n   * Получение статистики кэширования\r\n   */\r\n  getStats(): CacheStatistics {\r\n    const totalHits = this.stats.memoryHits + this.stats.indexedDBHits + this.stats.databaseHits;\r\n    const hitRate = this.stats.totalRequests > 0\r\n      ? (totalHits / this.stats.totalRequests) * 100\r\n      : 0;\r\n\r\n    // Вычисляем средние времена доступа\r\n    const avgAccessTime: CacheStatistics['avgAccessTime'] = {\r\n      memory: 0,\r\n      indexeddb: 0,\r\n      database: 0\r\n    };\r\n\r\n    for (const [level, stats] of this.stats.levelAccessTimes.entries()) {\r\n      avgAccessTime[level] = stats.count > 0 ? stats.total / stats.count : 0;\r\n    }\r\n\r\n    return {\r\n      totalRequests: this.stats.totalRequests,\r\n      hits: {\r\n        memory: this.stats.memoryHits,\r\n        indexeddb: this.stats.indexedDBHits,\r\n        database: this.stats.databaseHits,\r\n        total: totalHits\r\n      },\r\n      misses: this.stats.misses,\r\n      hitRate,\r\n      memoryUsage: {\r\n        memory: this.queryCache.getMemoryUsage(),\r\n        indexeddb: this.estimateIndexedDBUsage(),\r\n        database: this.estimateDatabaseUsage()\r\n      },\r\n      avgAccessTime\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Очистка всех уровней кэша\r\n   */\r\n  async clear(): Promise<void> {\r\n    const promises: Promise<void>[] = [\r\n      this.queryCache.clear(),\r\n      this.modelCache.clear(),\r\n      this.clearIndexedDB(),\r\n      this.clearDatabase()\r\n    ];\r\n\r\n    await Promise.all(promises);\r\n\r\n    // Сбрасываем статистику\r\n    this.stats = {\r\n      totalRequests: 0,\r\n      memoryHits: 0,\r\n      indexedDBHits: 0,\r\n      databaseHits: 0,\r\n      misses: 0,\r\n      totalAccessTime: 0,\r\n      levelAccessTimes: new Map([\r\n        ['memory', { total: 0, count: 0 }],\r\n        ['indexeddb', { total: 0, count: 0 }],\r\n        ['database', { total: 0, count: 0 }]\r\n      ])\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Оптимизация кэша\r\n   */\r\n  async optimize(): Promise<void> {\r\n    const promises: Promise<void>[] = [\r\n      this.queryCache.optimize(),\r\n      this.modelCache.optimize(),\r\n      this.optimizeIndexedDB(),\r\n      this.optimizeDatabase()\r\n    ];\r\n\r\n    await Promise.all(promises);\r\n    console.log('Cache optimization completed');\r\n  }\r\n\r\n  // === Приватные методы ===\r\n\r\n  /**\r\n   * Получение данных с конкретного уровня\r\n   */\r\n  private async getFromLevel<T>(key: string, level: CacheLevel): Promise<T | null> {\r\n    switch (level) {\r\n      case 'memory':\r\n        return this.queryCache.get(key);\r\n\r\n      case 'indexeddb':\r\n        return this.getFromIndexedDB<T>(key);\r\n\r\n      case 'database':\r\n        return this.getFromDatabase<T>(key);\r\n\r\n      default:\r\n        throw new CacheError(`Unknown cache level: ${level}`, 'read', `unknown:${level}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Инициализация IndexedDB\r\n   */\r\n  private async initIndexedDB(dbName: string, version: number): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (typeof indexedDB === 'undefined') {\r\n        console.warn('IndexedDB not available, skipping initialization');\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      const request = indexedDB.open(dbName, version);\r\n\r\n      request.onerror = () => {\r\n        console.warn('Failed to open IndexedDB:', request.error);\r\n        resolve(); // Продолжаем работу без IndexedDB\r\n      };\r\n\r\n      request.onsuccess = () => {\r\n        this.indexedDB = request.result;\r\n        resolve();\r\n      };\r\n\r\n      request.onupgradeneeded = () => {\r\n        const db = request.result;\r\n\r\n        // Создаем object store для кэша\r\n        if (!db.objectStoreNames.contains('cache')) {\r\n          const store = db.createObjectStore('cache', { keyPath: 'key' });\r\n          store.createIndex('timestamp', 'timestamp');\r\n          store.createIndex('tags', 'tags', { multiEntry: true });\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Получение данных из IndexedDB\r\n   */\r\n  private async getFromIndexedDB<T>(key: string): Promise<T | null> {\r\n    await this.dbReady;\r\n\r\n    if (!this.indexedDB) return null;\r\n\r\n    return new Promise((resolve) => {\r\n      const transaction = this.indexedDB!.transaction(['cache'], 'readonly');\r\n      const store = transaction.objectStore('cache');\r\n      const request = store.get(key);\r\n\r\n      request.onsuccess = () => {\r\n        const result = request.result;\r\n\r\n        if (!result) {\r\n          resolve(null);\r\n          return;\r\n        }\r\n\r\n        // Проверяем TTL\r\n        if (result.expiresAt && Date.now() > result.expiresAt) {\r\n          // Асинхронно удаляем устаревшую запись\r\n          this.deleteFromIndexedDB(key).catch(console.warn);\r\n          resolve(null);\r\n          return;\r\n        }\r\n\r\n        resolve(result.value);\r\n      };\r\n\r\n      request.onerror = () => {\r\n        console.warn(`IndexedDB get failed for key \"${key}\":`, request.error);\r\n        resolve(null);\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Сохранение данных в IndexedDB\r\n   */\r\n  private async setInIndexedDB<T>(key: string, value: T, options: { ttl?: number; tags?: string[]; compression?: boolean } = {}): Promise<void> {\r\n    await this.dbReady;\r\n\r\n    if (!this.indexedDB) return;\r\n\r\n    const { ttl, tags = [], compression = false } = options;\r\n\r\n    const cacheEntry = {\r\n      key,\r\n      value: compression ? this.compress(value) : value,\r\n      timestamp: Date.now(),\r\n      expiresAt: ttl ? Date.now() + ttl : null,\r\n      tags,\r\n      compressed: compression\r\n    };\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.indexedDB!.transaction(['cache'], 'readwrite');\r\n      const store = transaction.objectStore('cache');\r\n      const request = store.put(cacheEntry);\r\n\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => {\r\n        console.warn(`IndexedDB set failed for key \"${key}\":`, request.error);\r\n        reject(request.error);\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Удаление данных из IndexedDB\r\n   */\r\n  private async deleteFromIndexedDB(key: string): Promise<void> {\r\n    if (!this.indexedDB) return;\r\n\r\n    return new Promise((resolve) => {\r\n      const transaction = this.indexedDB!.transaction(['cache'], 'readwrite');\r\n      const store = transaction.objectStore('cache');\r\n      const request = store.delete(key);\r\n\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => {\r\n        console.warn(`IndexedDB delete failed for key \"${key}\":`, request.error);\r\n        resolve(); // Не прерываем работу при ошибке удаления\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Очистка данных в IndexedDB по паттерну\r\n   */\r\n  private async invalidateIndexedDB(pattern: string): Promise<void> {\r\n    if (!this.indexedDB) return;\r\n\r\n    // Упрощенная реализация - очищаем все если pattern === '*'\r\n    if (pattern === '*') {\r\n      await this.clearIndexedDB();\r\n      return;\r\n    }\r\n\r\n    // Для более сложных паттернов нужна полная реализация\r\n    console.warn('IndexedDB pattern invalidation not fully implemented');\r\n  }\r\n\r\n  /**\r\n   * Полная очистка IndexedDB\r\n   */\r\n  private async clearIndexedDB(): Promise<void> {\r\n    if (!this.indexedDB) return;\r\n\r\n    return new Promise((resolve) => {\r\n      const transaction = this.indexedDB!.transaction(['cache'], 'readwrite');\r\n      const store = transaction.objectStore('cache');\r\n      const request = store.clear();\r\n\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => {\r\n        console.warn('IndexedDB clear failed:', request.error);\r\n        resolve();\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Оптимизация IndexedDB (удаление устаревших записей)\r\n   */\r\n  private async optimizeIndexedDB(): Promise<void> {\r\n    if (!this.indexedDB) return;\r\n\r\n    const now = Date.now();\r\n\r\n    return new Promise((resolve) => {\r\n      const transaction = this.indexedDB!.transaction(['cache'], 'readwrite');\r\n      const store = transaction.objectStore('cache');\r\n      const request = store.openCursor();\r\n\r\n      request.onsuccess = () => {\r\n        const cursor = request.result;\r\n\r\n        if (cursor) {\r\n          const record = cursor.value;\r\n\r\n          // Удаляем устаревшие записи\r\n          if (record.expiresAt && now > record.expiresAt) {\r\n            cursor.delete();\r\n          }\r\n\r\n          cursor.continue();\r\n        } else {\r\n          resolve();\r\n        }\r\n      };\r\n\r\n      request.onerror = () => {\r\n        console.warn('IndexedDB optimization failed:', request.error);\r\n        resolve();\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Заглушки для database operations (будут реализованы при интеграции с worker)\r\n   */\r\n  private async getFromDatabase<T>(key: string): Promise<T | null> {\r\n    // Заглушка - будет реализовано при интеграции с worker\r\n    console.debug(`Database get for key \"${key}\" - not implemented yet`);\r\n    return null;\r\n  }\r\n\r\n  private async setInDatabase<T>(key: string, value: T, options: { ttl?: number; tags?: string[] }): Promise<void> {\r\n    // Заглушка - будет реализовано при интеграции с worker\r\n    console.debug(`Database set for key \"${key}\" - not implemented yet`);\r\n  }\r\n\r\n  private async invalidateDatabase(pattern: string): Promise<void> {\r\n    // Заглушка - будет реализовано при интеграции с worker\r\n    console.debug(`Database invalidation for pattern \"${pattern}\" - not implemented yet`);\r\n  }\r\n\r\n  private async clearDatabase(): Promise<void> {\r\n    // Заглушка - будет реализовано при интеграции с worker\r\n    console.debug('Database clear - not implemented yet');\r\n  }\r\n\r\n  private async optimizeDatabase(): Promise<void> {\r\n    // Заглушка - будет реализовано при интеграции с worker\r\n    console.debug('Database optimization - not implemented yet');\r\n  }\r\n\r\n  /**\r\n   * Вспомогательные методы\r\n   */\r\n  private updateAccessTimeStats(level: CacheLevel, time: number): void {\r\n    const stats = this.stats.levelAccessTimes.get(level)!;\r\n    stats.total += time;\r\n    stats.count++;\r\n  }\r\n\r\n  private estimateIndexedDBUsage(): number {\r\n    // Приблизительная оценка использования IndexedDB в MB\r\n    return 10; // Заглушка\r\n  }\r\n\r\n  private estimateDatabaseUsage(): number {\r\n    // Приблизительная оценка использования SQLite database в MB\r\n    return 50; // Заглушка\r\n  }\r\n\r\n  private hashString(str: string): string {\r\n    // Простая hash функция\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    return Math.abs(hash).toString(36);\r\n  }\r\n\r\n  private compress<T>(data: T): string {\r\n    // Простая реализация сжатия через JSON\r\n    return JSON.stringify(data);\r\n  }\r\n\r\n  private decompress<T>(compressed: string): T {\r\n    return JSON.parse(compressed);\r\n  }\r\n}\r\n\r\n/**\r\n * Фабричная функция для создания CacheManager\r\n */\r\nexport function createCacheManager(options: {\r\n  memorySize?: number;\r\n  indexedDBName?: string;\r\n  dbVersion?: number;\r\n} = {}): CacheManager {\r\n  return new CacheManagerImpl(options);\r\n}","/**\r\n * LocalRetrieve SDK - Main Export\r\n * \r\n * Provides sql.js compatible Database interface with LocalRetrieve\r\n * hybrid search capabilities built on SQLite WASM + sqlite-vec.\r\n */\r\n\r\n// Core Database exports\r\nexport { Database } from './database/Database.js';\r\nexport { Statement } from './database/Statement.js';\r\n\r\n// Import classes for internal use (with different names to avoid conflicts)\r\nimport { Database as DatabaseClass } from './database/Database.js';\r\nimport { Statement as StatementClass } from './database/Statement.js';\r\n\r\n// Type exports for external usage\r\nexport type {\r\n  DatabaseAPI,\r\n  StatementAPI,\r\n  DatabaseConfig,\r\n  SQLValue,\r\n  SQLParams,\r\n  StatementResult,\r\n  ExecOptions,\r\n  BindOptions\r\n} from './types/database.js';\r\n\r\n// Import types for internal use\r\nimport type { DatabaseAPI, StatementAPI, DatabaseConfig } from './types/database.js';\r\n\r\nexport type {\r\n  SearchRequest,\r\n  SearchResponse,\r\n  SearchQuery,\r\n  SearchResult,\r\n  CollectionInfo,\r\n  WorkerConfig,\r\n  CreateCollectionParams,\r\n  InsertDocumentWithEmbeddingParams,\r\n  SemanticSearchParams,\r\n  CollectionEmbeddingStatusResult\r\n} from './types/worker.js';\r\n\r\n// Utility exports\r\nexport {\r\n  DatabaseError,\r\n  StatementError,\r\n  DEFAULT_DATABASE_CONFIG,\r\n  resolveWorkerUrl,\r\n  validateSQL,\r\n  validateSQLParams,\r\n  isStatementResult,\r\n  isSQLValue\r\n} from './types/database.js';\r\n\r\nexport {\r\n  WorkerError,\r\n  DatabaseError as WorkerDatabaseError,\r\n  VectorError,\r\n  OPFSError\r\n} from './types/worker.js';\r\n\r\n// Worker utilities (for advanced usage)\r\nexport { WorkerRPC, createWorkerRPC } from './utils/rpc.js';\r\n\r\n// Embedding system exports\r\nexport {\r\n  // Provider implementations\r\n  OpenAIProvider,\r\n  createOpenAIProvider,\r\n  isValidModelDimensionCombo,\r\n  getRecommendedConfig,\r\n  TransformersProvider,\r\n  createTransformersProvider,\r\n\r\n  // Factory and utilities\r\n  createEmbeddingProvider,\r\n  validateEmbeddingConfig,\r\n  getRecommendedEmbeddingConfig,\r\n  checkConfigCompatibility,\r\n\r\n  // Provider Factory (new)\r\n  EmbeddingProviderFactoryImpl,\r\n  providerFactory,\r\n  createProvider,\r\n  validateProviderConfig,\r\n  checkProviderSupport,\r\n  getProviderRecommendations,\r\n  getAvailableProviders,\r\n  getAvailableModels,\r\n\r\n  // Base classes and interfaces\r\n  BaseEmbeddingProvider,\r\n  ExternalProvider,\r\n  ProviderUtils,\r\n\r\n  // Constants\r\n  EMBEDDING_DEFAULTS,\r\n  SUPPORTED_PROVIDERS,\r\n\r\n  // Errors\r\n  EmbeddingError,\r\n  ProviderError,\r\n  AuthenticationError,\r\n  ConfigurationError,\r\n  ValidationError,\r\n  QuotaExceededError,\r\n  TimeoutError,\r\n\r\n  // Utilities\r\n  TextProcessor,\r\n  MemoryCache,\r\n  EmbeddingUtils,\r\n  CollectionUtils,\r\n  EmbeddingConstants\r\n} from './embedding/index.js';\r\n\r\n// Task 6.2: Internal Embedding Pipeline exports\r\nexport {\r\n  // Core pipeline components\r\n  InternalPipelineImpl,\r\n  createInternalPipeline,\r\n\r\n  // Model management\r\n  ModelManagerImpl,\r\n  createModelManager,\r\n\r\n  // Cache management\r\n  CacheManagerImpl,\r\n  createCacheManager,\r\n  QueryCache,\r\n  ModelCache\r\n} from './pipeline/index.js';\r\n\r\n// Task 6.2: Pipeline type exports\r\nexport type {\r\n  // Core interfaces\r\n  InternalPipeline,\r\n  ModelManager,\r\n  CacheManager,\r\n\r\n  // Pipeline types\r\n  PipelineEmbeddingResult,\r\n  PipelineBatchEmbeddingResult,\r\n  PipelineEmbeddingRequest,\r\n  PipelinePerformanceStats,\r\n  EmbeddingOptions,\r\n  BatchOptions,\r\n\r\n  // Model management types\r\n  LoadedModel,\r\n  ModelStatus,\r\n  LoadingStrategy,\r\n  MemoryOptimizationOptions,\r\n  EmbeddingModel,\r\n\r\n  // Cache management types\r\n  CacheLevel,\r\n  CacheOptions,\r\n  CacheStatistics,\r\n  CacheResult,\r\n  QueryCacheOptions,\r\n  QueryCacheEntry,\r\n  QueryCacheConfig,\r\n  QueryCacheStats,\r\n  CachedModelInfo,\r\n  ModelCacheConfig,\r\n  ModelCacheStats,\r\n  ModelCacheEntry\r\n} from './pipeline/index.js';\r\n\r\n// Embedding type exports\r\nexport type {\r\n  EmbeddingProvider,\r\n  CollectionEmbeddingConfig,\r\n  EmbeddingConfig,\r\n  EmbeddingProviderType,\r\n  EmbeddingResult,\r\n  BatchEmbeddingResult,\r\n  SemanticSearchOptions,\r\n  HybridSearchOptions,\r\n  SearchResultWithEmbedding,\r\n\r\n  // Provider Factory types\r\n  ProviderSupportInfo,\r\n  ProviderConfigInfo,\r\n  ProviderRecommendation,\r\n  ModelInfo\r\n} from './embedding/index.js';\r\n\r\n// Version information\r\nexport const VERSION = '1.0.0-mvp';\r\nexport const FEATURES = [\r\n  'sql.js-compatibility',\r\n  'opfs-persistence',\r\n  'hybrid-search',\r\n  'sqlite-vec',\r\n  'fts5',\r\n  'worker-based',\r\n  'embedding-generation',\r\n  'collection-based-embeddings',\r\n  'automatic-embedding-generation',\r\n  'semantic-search'\r\n] as const;\r\n\r\n/**\r\n * Initialize LocalRetrieve with a database file\r\n * \r\n * @param filename Database filename (use 'opfs:/path/to/file.db' for OPFS persistence)\r\n * @param config Optional configuration\r\n * @returns Promise<Database> Ready-to-use database instance\r\n * \r\n * @example\r\n * ```typescript\r\n * import { initLocalRetrieve } from 'localretrieve';\r\n *\r\n * // Initialize with OPFS persistence\r\n * const db = await initLocalRetrieve('opfs:/myapp/search.db');\r\n *\r\n * // Initialize schema for hybrid search\r\n * await db.initializeSchema();\r\n *\r\n * // Create a collection with embedding configuration\r\n * await db.createCollection({\r\n *   name: 'documents',\r\n *   embeddingConfig: {\r\n *     provider: 'transformers',\r\n *     model: 'all-MiniLM-L6-v2',\r\n *     dimensions: 384\r\n *   }\r\n * });\r\n *\r\n * // Insert document with automatic embedding generation\r\n * await db.insertDocumentWithEmbedding({\r\n *   collection: 'documents',\r\n *   document: {\r\n *     title: 'Sample Document',\r\n *     content: 'This is a sample document content.'\r\n *   }\r\n * });\r\n *\r\n * // Perform semantic search\r\n * const results = await db.searchSemantic({\r\n *   collection: 'documents',\r\n *   query: 'sample content',\r\n *   options: { limit: 10 }\r\n * });\r\n *\r\n * // Or use traditional sql.js compatible API\r\n * db.run('INSERT INTO docs_default (id, content) VALUES (?, ?)', ['doc1', 'hello world']);\r\n *\r\n * // Or use hybrid search with manual vectors\r\n * const hybridResults = await db.search({\r\n *   query: { text: 'hello', vector: myVector },\r\n *   limit: 10\r\n * });\r\n * ```\r\n */\r\nexport async function initLocalRetrieve(\r\n  filename: string = 'opfs:/localretrieve/default.db',\r\n  config?: Partial<DatabaseConfig>\r\n): Promise<DatabaseClass> {\r\n  const finalConfig: DatabaseConfig = {\r\n    ...config,\r\n    filename\r\n  };\r\n\r\n  const db = new DatabaseClass(finalConfig);\r\n  await db._initialize();\r\n  \r\n  // Initialize schema only if needed (the schema check handles existence)\r\n  try {\r\n    await db.initializeSchema();\r\n  } catch (error) {\r\n    // Schema initialization failed - this might indicate a more serious issue\r\n    console.error('Schema initialization failed:', error);\r\n    throw error;\r\n  }\r\n\r\n  return db;\r\n}\r\n\r\n/**\r\n * Create a new Database instance (sql.js compatibility)\r\n * \r\n * @param buffer Optional buffer to import\r\n * @param filename Optional filename for persistence\r\n * @returns Promise<Database> Database instance\r\n */\r\nexport async function createDatabase(\r\n  buffer?: Uint8Array,\r\n  filename: string = ':memory:'\r\n): Promise<DatabaseClass> {\r\n  return DatabaseClass.create(buffer, filename);\r\n}\r\n\r\n// Re-export main Database class as default for convenience\r\nexport { DatabaseClass as default };\r\n\r\n// SQL.js compatibility namespace\r\nexport namespace SQL {\r\n  export const Database = DatabaseClass;\r\n  export type Database = DatabaseAPI;\r\n  export const Statement = StatementClass;\r\n  export type Statement = StatementAPI;\r\n}"],"names":["SQLError","message","code","SQLStatementError","SQLDatabaseError","isSQLValue","value","isSQLParams","params","validateSQL","sql","transformToSQLResult","rows","firstRow","columns","values","row","col","DEFAULT_SQL_COMPAT_CONFIG","Statement","database","workerRPC","error","result","executePromise","isResolved","res","err","DatabaseError","StatementError","isStatementResult","obj","DEFAULT_DATABASE_CONFIG","resolveWorkerUrl","workerUrl","validateSQLParams","Database","config","finalConfig","buffer","filename","db","validateSQLQuery","statement","name","savepointName","func","funcs","request","query","options","results","prompt","collection","requests","batchOptions","commonQueries","pattern","providers","strategy","createWorkerRPC","fallbackResult","fallbackError","fallbackMessage","TextProcessor","text","startTime","originalLength","appliedOperations","metadata","processedText","effectiveConfig","htmlResult","markdownResult","beforeLength","truncationResult","wasTruncated","processedLength","estimatedTokens","processingTime","removedCount","match","replacement","description","matches","maxCharacters","maxTokens","preserveWordBoundaries","addTruncationIndicator","truncationIndicator","maxLength","maxCharsFromTokens","indicatorLength","targetLength","truncatedText","halfLength","startPart","endPart","lastSpaceIndex","ValidationError","totalTime","totalOriginalLength","totalProcessedLength","newConfig","EmbeddingUtils","algorithm","includeTimestamp","salt","includeDebugInfo","hashInput","sortedInput","inputString","cacheKey","processingConfig","input","data","hashBuffer","b","hash","i","item","sortedKeys","sortedObj","key","firstKey","embedding","expectedDimensions","actualDimensions","isValid","supportedDimensions","array","copy","base","override","overrideValue","bytes","k","sizes","milliseconds","seconds","minutes","operation","timer","endTime","prefix","timestamp","random","jsonString","defaultValue","resolve","delay","timeoutId","args","limit","inThrottle","EmbeddingConstants","CollectionUtils","collectionId","dimensions","provider","LRUNode","entry","prev","next","MemoryCache","collectionConfig","globalConfig","cacheKeyConfig","node","providerMetadata","sizeBytes","existingNode","newNode","EmbeddingError","hashResult","currentSize","currentSizeBytes","now","maxAge","utilization","textSize","embeddingSize","metadataSize","newEntrySize","evictedNode","EMBEDDING_DEFAULTS","SUPPORTED_PROVIDERS","createEmbeddingProvider","providerFactoryImpl","validateEmbeddingConfig","getRecommendedEmbeddingConfig","requirements","offline","budget","performance","apiKey","openaiConfig","getRecommendedConfigImpl","checkConfigCompatibility","oldConfig","issues","recommendations","requiresRegeneration","InternalPipelineImpl","cacheManager","modelManager","cached","timeout","embeddingPromise","timeoutPromise","_","reject","TimeoutError","batchSize","concurrency","batches","completedCount","total","processBatch","batch","batchResults","embeddingResult","batchPromises","memoryResult","indexedDBResult","databaseResult","index","completed","cacheHitRate","averageGenerationTime","ConfigurationError","providerFactory","configHash","queryHash","source","current","memoryUsage","createInternalPipeline","ModelManagerImpl","model","modelId","cachedModel","loadPromises","maxMemoryUsage","maxModels","idleTimeout","aggressive","currentMemory","currentModelCount","modelsToUnload","a","scoreA","scoreB","freedMemory","unloadedCount","loadedModels","totalMemoryUsage","activeCount","m","providerStats","stats","cutoffTime","unloadPromises","loadingModel","providerInstance","loadTime","ModelLoadError","modelName","interval","createModelManager","QueryCache","ttl","priority","tags","size","deleted","totalHits","totalMisses","keysToDelete","tag","regex","totalRequests","hitRate","averageEntrySize","sum","totalSize","requiredSize","requiredSpace","targetMemory","targetSize","keysToEvict","entries","sortedEntries","remainingMemory","remainingCount","priorityOrder","priorityDiff","priorityScore","frequencyScore","recencyScore","ModelCache","modelInfo","perf","totalInferences","newSuccessful","models","deletePromises","requiredMemory","ageScore","usageScore","memoryScore","performanceScore","totalMemory","CacheManagerImpl","level","compression","promises","CacheError","queries","warmupPromises","placeholder","preloadPromises","avgAccessTime","dbName","version","store","cacheEntry","cursor","record","time","str","char","compressed","createCacheManager","VERSION","FEATURES","initLocalRetrieve","DatabaseClass","createDatabase","SQL","StatementClass"],"mappings":"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"}