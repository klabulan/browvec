{"version":3,"file":"ProviderFactory-BqrsaSK-.mjs","sources":["../src/types/worker.ts","../src/utils/rpc.ts","../src/embedding/errors.ts","../src/embedding/providers/BaseProvider.ts","../src/embedding/providers/ExternalProvider.ts","../src/embedding/providers/OpenAIProvider.ts","../src/embedding/providers/TransformersProvider.ts","../src/embedding/ProviderFactory.ts"],"sourcesContent":["/**\n * Worker Types for LocalRetrieve Database Worker\n * \n * This file defines the message types and interfaces for communication\n * between the main thread and the database worker via RPC.\n */\n\n// Base SQL value types compatible with sql.js\nexport type SQLValue = number | string | Uint8Array | null;\n\n// Extended SQL value types for internal worker use (includes Float32Array for vectors)\nexport type ExtendedSQLValue = SQLValue | Float32Array;\n\n// SQL parameter types\nexport type SQLParams = Record<string, SQLValue> | SQLValue[];\n\n// Extended SQL parameter types for internal worker use\nexport type ExtendedSQLParams = Record<string, ExtendedSQLValue> | ExtendedSQLValue[];\n\n// Database operation result types\nexport interface QueryResult {\n  rows: Record<string, any>[];\n  columns?: string[];\n  rowsAffected?: number;\n  lastInsertRowid?: number;\n}\n\n// Search-specific types\nexport interface SearchQuery {\n  text?: string;\n  vector?: Float32Array;\n  filters?: Record<string, any>;\n}\n\nexport interface SearchRequest {\n  query: SearchQuery;\n  collection?: string;\n  limit?: number;\n  fusionMethod?: 'rrf' | 'weighted';\n  fusionWeights?: { fts: number; vec: number };\n}\n\nexport interface SearchResult {\n  id: string;\n  title?: string;\n  content?: string;\n  metadata?: Record<string, any>;\n  score: number;\n  ftsScore?: number;\n  vecScore?: number;\n}\n\nexport interface SearchResponse {\n  results: SearchResult[];\n  totalResults: number;\n  searchTime: number;\n}\n\n// Collection management types\nexport interface CollectionInfo {\n  name: string;\n  createdAt: number;\n  schemaVersion: number;\n  vectorDimensions: number;\n  documentCount: number;\n}\n\n// Collection creation with embedding support\nexport interface CreateCollectionParams {\n  name: string;\n  dimensions?: number;\n  config?: Record<string, any>;\n  embeddingConfig?: import('../embedding/types.js').CollectionEmbeddingConfig;\n  description?: string;\n  metadata?: Record<string, any>;\n}\n\n// Document insertion with automatic embedding generation\nexport interface InsertDocumentWithEmbeddingParams {\n  collection: string;\n  document: {\n    id?: string;\n    title?: string;\n    content: string;\n    metadata?: Record<string, any>;\n  };\n  options?: {\n    generateEmbedding?: boolean;\n    embeddingOptions?: import('../embedding/types.js').EmbeddingRequestOptions;\n  };\n}\n\n// Semantic search with optional embedding inclusion\nexport interface SemanticSearchParams {\n  collection: string;\n  query: string;\n  options?: {\n    limit?: number;\n    similarityThreshold?: number;\n    includeEmbeddings?: boolean;\n    filters?: Record<string, any>;\n    generateQueryEmbedding?: boolean;\n  };\n}\n\n// Collection embedding status\nexport interface CollectionEmbeddingStatusResult {\n  collection: string;\n  collectionId: string;\n  provider?: string;\n  model?: string;\n  dimensions?: number;\n  documentsWithEmbeddings: number;\n  totalDocuments: number;\n  isReady: boolean;\n  generationProgress: number;\n  lastUpdated?: Date;\n  configErrors: string[];\n}\n\n// Batch embedding operations\nexport interface BatchEmbeddingRequest {\n  collection: string;\n  documents: Array<{\n    id: string;\n    content: string;\n    metadata?: Record<string, any>;\n  }>;\n  options?: {\n    batchSize?: number;\n    timeout?: number;\n    onProgress?: (progress: EmbeddingProgress) => void;\n  };\n}\n\nexport interface BatchEmbeddingResult {\n  success: number;\n  failed: number;\n  errors: Array<{\n    documentId: string;\n    error: string;\n  }>;\n  processingTime: number;\n}\n\n// Progress reporting for embedding operations\nexport interface EmbeddingProgress {\n  phase: 'initializing' | 'generating' | 'storing' | 'complete' | 'error';\n  processedCount: number;\n  totalCount: number;\n  currentItem?: string;\n  timeElapsed: number;\n  estimatedTimeRemaining?: number;\n  errorCount?: number;\n}\n\n// Embedding generation request\nexport interface GenerateEmbeddingRequest {\n  collection: string;\n  text: string;\n  options?: {\n    includeInVector?: boolean;\n    cacheKey?: string;\n    timeout?: number;\n  };\n}\n\nexport interface GenerateEmbeddingResult {\n  embedding: Float32Array;\n  dimensions: number;\n  generationTime: number;\n  cached: boolean;\n  provider: string;\n}\n\n// Worker RPC message types\nexport interface WorkerMessage<T = any> {\n  id: string;\n  method: string;\n  params?: T;\n}\n\nexport interface WorkerResponse<T = any> {\n  id: string;\n  result?: T;\n  error?: {\n    message: string;\n    code?: string;\n    stack?: string;\n  };\n}\n\n// Specific message types for each database operation\nexport interface OpenDatabaseParams {\n  filename: string;\n  path?: string;\n  vfs?: 'opfs' | 'opfs-sahpool';\n  pragmas?: Record<string, string>;\n}\n\nexport interface ExecParams {\n  sql: string;\n  params?: SQLParams;\n}\n\nexport interface SelectParams {\n  sql: string;\n  params?: SQLParams;\n}\n\nexport interface BulkInsertParams {\n  table: string;\n  tableName: string;\n  data: any[][];\n  rows: Record<string, any>[];\n  batchSize?: number;\n}\n\n// Progress callback interface for export/import operations\nexport interface ExportImportProgress {\n  phase: 'validating' | 'preparing' | 'exporting' | 'importing' | 'finalizing' | 'complete';\n  bytesProcessed: number;\n  totalBytes: number;\n  timeElapsed: number;\n}\n\nexport interface ExportParams {\n  format?: 'sqlite' | 'json';\n  includeSchema?: boolean;\n  onProgress?: (progress: ExportImportProgress) => void;\n}\n\nexport interface ImportParams {\n  data: Uint8Array;\n  format?: 'sqlite' | 'json';\n  overwrite?: boolean;\n  onProgress?: (progress: ExportImportProgress) => void;\n}\n\n// Queue management types\nexport interface EnqueueEmbeddingParams {\n  collection: string;\n  documentId: string;\n  textContent: string;\n  priority?: number;\n}\n\nexport interface ProcessEmbeddingQueueParams {\n  collection?: string;\n  batchSize?: number;\n  maxProcessingTime?: number;\n}\n\nexport interface ProcessEmbeddingQueueResult {\n  processed: number;\n  failed: number;\n  remainingInQueue: number;\n  errors: Array<{\n    documentId: string;\n    error: string;\n  }>;\n}\n\nexport interface QueueStatusResult {\n  totalCount: number;\n  pendingCount: number;\n  processingCount: number;\n  completedCount: number;\n  failedCount: number;\n  oldestPending?: Date;\n  newestCompleted?: Date;\n}\n\nexport interface ClearEmbeddingQueueParams {\n  collection?: string;\n  status?: 'pending' | 'processing' | 'completed' | 'failed';\n  olderThan?: Date;\n}\n\n// =============================================================================\n// LLM Integration Types (SCRUM-17)\n// =============================================================================\n\n/**\n * Enhanced Query Parameters\n */\nexport interface EnhanceQueryParams {\n  query: string;\n  options?: {\n    provider?: string;\n    model?: string;\n    apiKey?: string;\n    maxSuggestions?: number;\n    includeIntent?: boolean;\n    temperature?: number;\n    timeout?: number;\n  };\n}\n\n/**\n * Enhanced Query Result\n */\nexport interface EnhancedQueryResult {\n  originalQuery: string;\n  enhancedQuery: string;\n  suggestions: string[];\n  intent?: string;\n  confidence: number;\n  provider: string;\n  model: string;\n  processingTime: number;\n}\n\n/**\n * Summarize Results Parameters\n */\nexport interface SummarizeResultsParams {\n  results: SearchResult[];\n  options?: {\n    provider?: string;\n    model?: string;\n    apiKey?: string;\n    maxLength?: number;\n    includeKeyPoints?: boolean;\n    temperature?: number;\n    timeout?: number;\n  };\n}\n\n/**\n * Result Summary Result\n */\nexport interface ResultSummaryResult {\n  summary: string;\n  keyPoints: string[];\n  themes: string[];\n  confidence: number;\n  provider: string;\n  model: string;\n  processingTime: number;\n}\n\n/**\n * Search with LLM Parameters\n */\nexport interface SearchWithLLMParams {\n  query: string;\n  options?: {\n    enhanceQuery?: boolean;\n    summarizeResults?: boolean;\n    searchOptions?: TextSearchOptions;\n    llmOptions?: {\n      provider?: string;\n      model?: string;\n      apiKey?: string;\n      temperature?: number;\n    };\n  };\n}\n\n/**\n * LLM Search Response Result\n */\nexport interface LLMSearchResponseResult {\n  results: SearchResult[];\n  enhancedQuery?: EnhancedQueryResult;\n  summary?: ResultSummaryResult;\n  searchTime: number;\n  llmTime: number;\n  totalTime: number;\n}\n\n/**\n * Generic LLM Call Parameters (SCRUM-17 - Pure LLM API)\n */\nexport interface CallLLMParams {\n  prompt: string;\n  options?: {\n    provider?: string;\n    model?: string;\n    apiKey?: string;\n    temperature?: number;\n    maxTokens?: number;\n    timeout?: number;\n    systemPrompt?: string;\n  };\n}\n\n/**\n * Generic LLM Call Result (SCRUM-17 - Pure LLM API)\n */\nexport interface CallLLMResult {\n  text: string;\n  finishReason: 'stop' | 'length' | 'error' | 'timeout';\n  usage?: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n  model: string;\n  provider: string;\n  processingTime: number;\n}\n\n// Database Worker API Interface\nexport interface DBWorkerAPI {\n  // Core database operations\n  open(params: OpenDatabaseParams): Promise<void>;\n  close(): Promise<void>;\n  exec(params: ExecParams): Promise<void>;\n  select(params: SelectParams): Promise<QueryResult>;\n  bulkInsert(params: BulkInsertParams): Promise<void>;\n\n  // WASM-specific operations\n  initVecExtension(): Promise<void>;\n\n  // Schema management\n  initializeSchema(): Promise<void>;\n  getCollectionInfo(name: string): Promise<CollectionInfo>;\n\n  // Collection management with embedding support\n  createCollection(params: CreateCollectionParams): Promise<void>;\n  getCollectionEmbeddingStatus(collection: string): Promise<CollectionEmbeddingStatusResult>;\n\n  // Document operations with embedding support\n  insertDocumentWithEmbedding(params: InsertDocumentWithEmbeddingParams): Promise<{ id: string; embeddingGenerated: boolean }>;\n\n  // Embedding generation operations\n  generateEmbedding(params: GenerateEmbeddingRequest): Promise<GenerateEmbeddingResult>;\n  batchGenerateEmbeddings(params: BatchEmbeddingRequest): Promise<BatchEmbeddingResult>;\n  regenerateCollectionEmbeddings(collection: string, options?: { batchSize?: number; onProgress?: (progress: EmbeddingProgress) => void }): Promise<BatchEmbeddingResult>;\n\n  // Search operations\n  search(params: SearchRequest): Promise<SearchResponse>;\n  searchSemantic(params: SemanticSearchParams): Promise<SearchResponse>;\n\n  // Enhanced search API (Task 6.1)\n  searchText(params: TextSearchParams): Promise<EnhancedSearchResponse>;\n  searchAdvanced(params: AdvancedSearchParams): Promise<EnhancedSearchResponse>;\n  searchGlobal(params: GlobalSearchParams): Promise<GlobalSearchResponse>;\n\n  // LLM operations (SCRUM-17)\n  enhanceQuery(params: EnhanceQueryParams): Promise<EnhancedQueryResult>;\n  summarizeResults(params: SummarizeResultsParams): Promise<ResultSummaryResult>;\n  searchWithLLM(params: SearchWithLLMParams): Promise<LLMSearchResponseResult>;\n  callLLM(params: CallLLMParams): Promise<CallLLMResult>;\n\n  // Data export/import\n  export(params?: ExportParams): Promise<Uint8Array>;\n  import(params: ImportParams): Promise<void>;\n  clear(): Promise<void>;\n\n  // Embedding queue management\n  enqueueEmbedding(params: EnqueueEmbeddingParams): Promise<number>;\n  processEmbeddingQueue(params?: ProcessEmbeddingQueueParams): Promise<ProcessEmbeddingQueueResult>;\n  getQueueStatus(collection?: string): Promise<QueueStatusResult>;\n  clearEmbeddingQueue(params?: ClearEmbeddingQueueParams): Promise<number>;\n\n  // Task 6.2: Internal Embedding Pipeline Operations\n  generateQueryEmbedding(params: GenerateQueryEmbeddingParams): Promise<QueryEmbeddingResult>;\n  batchGenerateQueryEmbeddings(params: BatchGenerateQueryEmbeddingsParams): Promise<BatchQueryEmbeddingResult[]>;\n  warmEmbeddingCache(params: WarmEmbeddingCacheParams): Promise<void>;\n  clearEmbeddingCache(params?: ClearEmbeddingCacheParams): Promise<void>;\n  getPipelineStats(): Promise<PipelinePerformanceStats>;\n  getModelStatus(): Promise<ModelStatusResult>;\n  preloadModels(params: PreloadModelsParams): Promise<void>;\n  optimizeModelMemory(params?: OptimizeModelMemoryParams): Promise<void>;\n\n  // Utility operations\n  getVersion(): Promise<{ sqlite: string; vec: string; sdk: string }>;\n  getStats(): Promise<{ memory: number; dbSize: number; operations: number }>;\n}\n\n// Worker method names (for type safety in RPC calls)\nexport type WorkerMethodName = keyof DBWorkerAPI;\n\n// Worker events for notifications\nexport interface WorkerEvent<T = any> {\n  type: string;\n  data: T;\n}\n\nexport interface EmbeddingProgressEvent extends WorkerEvent<EmbeddingProgress> {\n  type: 'embedding_progress';\n}\n\nexport interface EmbeddingCompletedEvent extends WorkerEvent<{ collection: string; documentsProcessed: number; errors: number }> {\n  type: 'embedding_completed';\n}\n\nexport interface DatabaseEvent extends WorkerEvent {\n  type: 'database' | 'search' | 'error' | 'performance';\n}\n\n// Error types\nexport class WorkerError extends Error {\n  constructor(\n    message: string,\n    public code?: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'WorkerError';\n  }\n}\n\nexport class DatabaseError extends WorkerError {\n  constructor(message: string, public sqliteCode?: number) {\n    super(message, 'DATABASE_ERROR');\n    this.name = 'DatabaseError';\n  }\n}\n\nexport class VectorError extends WorkerError {\n  constructor(message: string) {\n    super(message, 'VECTOR_ERROR');\n    this.name = 'VectorError';\n  }\n}\n\nexport class OPFSError extends WorkerError {\n  constructor(message: string) {\n    super(message, 'OPFS_ERROR');\n    this.name = 'OPFSError';\n  }\n}\n\n// Configuration types\nexport interface WorkerConfig {\n  maxConcurrentOperations?: number;\n  operationTimeout?: number;\n  enablePerformanceMonitoring?: boolean;\n  logLevel?: 'debug' | 'info' | 'warn' | 'error';\n}\n\n// Performance monitoring types\nexport interface PerformanceMetrics {\n  operationCount: number;\n  averageLatency: number;\n  memoryUsage: number;\n  cacheHitRate: number;\n  lastOperationTime: number;\n}\n\n// Embedding queue management types\nexport interface EmbeddingQueueItem {\n  id: number;\n  collection_name: string;\n  document_id: string;\n  text_content: string;\n  priority: number;\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  created_at: number;\n  processed_at?: number;\n  error_message?: string;\n}\n\nexport interface EnqueueEmbeddingParams {\n  collection: string;\n  documentId: string;\n  textContent: string;\n  priority?: number;\n}\n\nexport interface QueueStatusResult {\n  collection: string;\n  pendingCount: number;\n  processingCount: number;\n  completedCount: number;\n  failedCount: number;\n  totalCount: number;\n  oldestPendingDate?: number;\n  averageProcessingTime?: number;\n}\n\nexport interface ProcessEmbeddingQueueParams {\n  collection?: string;\n  batchSize?: number;\n  maxRetries?: number;\n}\n\n\n\n// Enhanced Search API types (Task 6.1)\nexport interface TextSearchParams {\n  query: string;\n  options?: import(\"./search.js\").TextSearchOptions;\n}\n\nexport interface AdvancedSearchParams {\n  query: string;\n  collections?: string[];\n  searchPlan?: Partial<import(\"./search.js\").SearchExecutionPlan>;\n  boosts?: import(\"./search.js\").FieldBoosts;\n  filters?: import(\"./search.js\").AdvancedFilters;\n  aggregations?: import(\"./search.js\").AggregationRequest[];\n  facets?: import(\"./search.js\").FacetRequest[];\n  explain?: boolean;\n}\n\nexport interface GlobalSearchParams {\n  query: string;\n  options?: import(\"./search.js\").GlobalSearchOptions;\n}\n\n// Task 6.2: Internal Embedding Pipeline RPC Parameters\n\nexport interface GenerateQueryEmbeddingParams {\n  query: string;\n  collection: string;\n  options?: {\n    forceRefresh?: boolean;\n    timeout?: number;\n    priority?: number;\n    context?: {\n      userId?: string;\n      sessionId?: string;\n      source?: string;\n    };\n  };\n}\n\nexport interface BatchGenerateQueryEmbeddingsParams {\n  requests: Array<{\n    id: string;\n    query: string;\n    collection: string;\n    options?: GenerateQueryEmbeddingParams['options'];\n  }>;\n  batchOptions?: {\n    batchSize?: number;\n    concurrency?: number;\n    timeout?: number;\n    onProgress?: (completed: number, total: number, current?: string) => void;\n  };\n}\n\nexport interface WarmEmbeddingCacheParams {\n  collection: string;\n  commonQueries: string[];\n}\n\nexport interface ClearEmbeddingCacheParams {\n  collection?: string;\n  pattern?: string;\n}\n\nexport interface PreloadModelsParams {\n  providers: string[];\n  strategy?: 'eager' | 'lazy' | 'predictive';\n}\n\nexport interface OptimizeModelMemoryParams {\n  maxMemoryUsage?: number;\n  maxModels?: number;\n  idleTimeout?: number;\n  aggressive?: boolean;\n}\n\n// Task 6.2: Pipeline Response Types\n\nexport interface QueryEmbeddingResult {\n  embedding: Float32Array;\n  dimensions: number;\n  source: 'cache_memory' | 'cache_indexeddb' | 'cache_database' | 'provider_fresh';\n  processingTime: number;\n  metadata?: {\n    cacheHit?: boolean;\n    modelUsed?: string;\n    provider?: string;\n    confidence?: number;\n  };\n}\n\nexport interface BatchQueryEmbeddingResult extends QueryEmbeddingResult {\n  requestId: string;\n  status: 'completed' | 'failed' | 'skipped';\n  error?: string;\n}\n\nexport interface PipelinePerformanceStats {\n  totalRequests: number;\n  cacheHitRate: number;\n  averageGenerationTime: number;\n  activeModels: number;\n  memoryUsage: number;\n  cacheStats: {\n    memory: { hits: number; misses: number };\n    indexedDB: { hits: number; misses: number };\n    database: { hits: number; misses: number };\n  };\n}\n\nexport interface ModelStatusResult {\n  loadedModels: Array<{\n    modelId: string;\n    provider: string;\n    modelName: string;\n    dimensions: number;\n    memoryUsage: number;\n    lastUsed: number;\n    usageCount: number;\n    status: 'loading' | 'ready' | 'error' | 'unloading';\n  }>;\n  totalMemoryUsage: number;\n  activeCount: number;\n  providerStats: Record<string, {\n    count: number;\n    memoryUsage: number;\n    avgLoadTime: number;\n  }>;\n}\n\n// Enhanced search response types\nexport interface EnhancedSearchResponse extends SearchResponse {\n  strategy?: import(\"./search.js\").SearchStrategy;\n  fusion?: import(\"./search.js\").FusionMethod;\n  aggregations?: Record<string, any>;\n  facets?: Record<string, any>;\n  suggestions?: string[];\n  debugInfo?: import(\"./search.js\").SearchDebugInfo;\n}\n\nexport interface GlobalSearchResponse extends EnhancedSearchResponse {\n  collectionResults: Array<{\n    collection: string;\n    results: SearchResult[];\n    totalInCollection: number;\n  }>;\n  collectionsSearched: string[];\n}\n","/**\n * RPC Utilities for Worker Communication\n * \n * This module provides a robust RPC (Remote Procedure Call) system for\n * communication between the main thread and database worker.\n */\n\nimport type {\n  WorkerMessage,\n  WorkerResponse,\n  WorkerMethodName,\n  DBWorkerAPI,\n  WorkerConfig\n} from '../types/worker.js';\n\nimport {\n  WorkerError\n} from '../types/worker.js';\n\n// Default configuration\nconst DEFAULT_CONFIG: Required<WorkerConfig> = {\n  maxConcurrentOperations: 10,\n  operationTimeout: 30000, // 30 seconds\n  enablePerformanceMonitoring: true,\n  logLevel: 'info'\n};\n\n/**\n * Client-side RPC wrapper for worker communication\n */\nexport class WorkerRPC implements DBWorkerAPI {\n  private worker: Worker;\n  private config: Required<WorkerConfig>;\n  private pendingCalls = new Map<string, {\n    resolve: (value: any) => void;\n    reject: (error: Error) => void;\n    timeout: ReturnType<typeof setTimeout>;\n    startTime: number;\n  }>();\n  private callCounter = 0;\n  private performanceMetrics = {\n    totalCalls: 0,\n    totalTime: 0,\n    errors: 0,\n    timeouts: 0\n  };\n\n  constructor(worker: Worker, config: Partial<WorkerConfig> = {}) {\n    this.worker = worker;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.setupWorkerListeners();\n  }\n\n  private setupWorkerListeners(): void {\n    this.worker.onmessage = (event: MessageEvent<WorkerResponse | any>) => {\n      const response = event.data;\n\n      // Handle worker log messages\n      if (response.type === 'log') {\n        const level = response.level as 'debug' | 'info' | 'warn' | 'error';\n        const logFn = (console[level] || console.log) as (...args: any[]) => void;\n        logFn(response.message, ...(response.args || []));\n        return;\n      }\n\n      this.handleWorkerResponse(response);\n    };\n\n    this.worker.onerror = (error: ErrorEvent) => {\n      this.log('error', 'Worker error:', error.message);\n      this.rejectAllPending(new WorkerError('Worker error: ' + error.message, 'WORKER_ERROR'));\n    };\n\n    this.worker.onmessageerror = (event: MessageEvent) => {\n      this.log('error', 'Worker message error:', event);\n      this.rejectAllPending(new WorkerError('Worker message error', 'MESSAGE_ERROR'));\n    };\n  }\n\n  private handleWorkerResponse(response: WorkerResponse): void {\n    const pending = this.pendingCalls.get(response.id);\n    if (!pending) {\n      this.log('warn', 'Received response for unknown call ID:', response.id);\n      return;\n    }\n\n    this.pendingCalls.delete(response.id);\n    clearTimeout(pending.timeout);\n\n    // Update performance metrics\n    if (this.config.enablePerformanceMonitoring) {\n      const duration = Date.now() - pending.startTime;\n      this.performanceMetrics.totalCalls++;\n      this.performanceMetrics.totalTime += duration;\n    }\n\n    if (response.error) {\n      this.performanceMetrics.errors++;\n      const error = new WorkerError(\n        response.error.message,\n        response.error.code\n      );\n      if (response.error.stack) {\n        error.stack = response.error.stack;\n      }\n      pending.reject(error);\n    } else {\n      pending.resolve(response.result);\n    }\n  }\n\n  private generateCallId(): string {\n    return `rpc_${++this.callCounter}_${Date.now()}`;\n  }\n\n  private call<T = any>(method: WorkerMethodName, params?: any): Promise<T> {\n    return new Promise((resolve, reject) => {\n      // Check concurrent operations limit\n      if (this.pendingCalls.size >= this.config.maxConcurrentOperations) {\n        this.log('error', `Rate limit exceeded for ${method}: ${this.pendingCalls.size}/${this.config.maxConcurrentOperations}`);\n        reject(new WorkerError(\n          `Too many concurrent operations (max: ${this.config.maxConcurrentOperations})`,\n          'RATE_LIMIT'\n        ));\n        return;\n      }\n\n      const id = this.generateCallId();\n      const startTime = Date.now();\n\n      // Setup timeout\n      const timeout = setTimeout(() => {\n        this.log('error', `Operation timeout for ${method} after ${this.config.operationTimeout}ms`);\n        this.pendingCalls.delete(id);\n        this.performanceMetrics.timeouts++;\n        reject(new WorkerError(\n          `Operation timeout after ${this.config.operationTimeout}ms`,\n          'TIMEOUT'\n        ));\n      }, this.config.operationTimeout);\n\n      // Store pending call\n      this.pendingCalls.set(id, {\n        resolve,\n        reject,\n        timeout,\n        startTime\n      });\n\n      // Send message to worker\n      const message: WorkerMessage = {\n        id,\n        method,\n        params\n      };\n\n      try {\n        this.worker.postMessage(message);\n      } catch (error) {\n        this.log('error', `Failed to send RPC message for ${method}:`, error);\n        this.pendingCalls.delete(id);\n        clearTimeout(timeout);\n        reject(new WorkerError(\n          `Failed to send message: ${error instanceof Error ? error.message : String(error)}`,\n          'SEND_ERROR'\n        ));\n      }\n    });\n  }\n\n  private rejectAllPending(error: Error): void {\n    for (const [id, pending] of this.pendingCalls) {\n      clearTimeout(pending.timeout);\n      pending.reject(error);\n    }\n    this.pendingCalls.clear();\n  }\n\n  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string, ...args: any[]): void {\n    const levels = { debug: 0, info: 1, warn: 2, error: 3 };\n    const configLevel = levels[this.config.logLevel];\n    const messageLevel = levels[level];\n\n    if (messageLevel >= configLevel) {\n      console[level](`[WorkerRPC] ${message}`, ...args);\n    }\n  }\n\n  // DBWorkerAPI implementation\n  async open(params: Parameters<DBWorkerAPI['open']>[0]): Promise<void> {\n    return this.call('open', params);\n  }\n\n  async close(): Promise<void> {\n    const result = await this.call('close');\n    // Clean up any pending calls after close\n    this.rejectAllPending(new WorkerError('Worker closed', 'WORKER_CLOSED'));\n    return result;\n  }\n\n  async exec(params: Parameters<DBWorkerAPI['exec']>[0]): Promise<void> {\n    return this.call('exec', params);\n  }\n\n  async select(params: Parameters<DBWorkerAPI['select']>[0]) {\n    return this.call('select', params);\n  }\n\n  async bulkInsert(params: Parameters<DBWorkerAPI['bulkInsert']>[0]): Promise<void> {\n    return this.call('bulkInsert', params);\n  }\n\n  async initVecExtension(): Promise<void> {\n    return this.call('initVecExtension');\n  }\n\n  async initializeSchema(): Promise<void> {\n    return this.call('initializeSchema');\n  }\n\n  async getCollectionInfo(name: string) {\n    return this.call('getCollectionInfo', name);\n  }\n\n  async search(params: Parameters<DBWorkerAPI['search']>[0]) {\n    return this.call('search', params);\n  }\n\n  async export(params?: Parameters<DBWorkerAPI['export']>[0]): Promise<Uint8Array> {\n    return this.call('export', params);\n  }\n\n  async import(params: Parameters<DBWorkerAPI['import']>[0]): Promise<void> {\n    return this.call('import', params);\n  }\n\n  async clear(): Promise<void> {\n    return this.call('clear');\n  }\n\n  async getVersion() {\n    return this.call('getVersion');\n  }\n\n  async getStats() {\n    return this.call('getStats');\n  }\n\n  // Collection management with embedding support\n  async createCollection(params: Parameters<DBWorkerAPI['createCollection']>[0]): Promise<void> {\n    return this.call('createCollection', params);\n  }\n\n  async getCollectionEmbeddingStatus(collection: string) {\n    return this.call('getCollectionEmbeddingStatus', collection);\n  }\n\n  // Document operations with embedding support\n  async insertDocumentWithEmbedding(params: Parameters<DBWorkerAPI['insertDocumentWithEmbedding']>[0]) {\n    return this.call('insertDocumentWithEmbedding', params);\n  }\n\n  // Search operations\n  async searchSemantic(params: Parameters<DBWorkerAPI['searchSemantic']>[0]) {\n    return this.call('searchSemantic', params);\n  }\n\n  // Enhanced search API (Task 6.1)\n  async searchText(params: Parameters<DBWorkerAPI[\"searchText\"]>[0]) {\n    return this.call(\"searchText\", params);\n  }\n\n  async searchAdvanced(params: Parameters<DBWorkerAPI[\"searchAdvanced\"]>[0]) {\n    return this.call(\"searchAdvanced\", params);\n  }\n\n  async searchGlobal(params: Parameters<DBWorkerAPI[\"searchGlobal\"]>[0]) {\n    return this.call(\"searchGlobal\", params);\n  }\n\n  // Embedding generation operations\n  async generateEmbedding(params: Parameters<DBWorkerAPI['generateEmbedding']>[0]) {\n    return this.call('generateEmbedding', params);\n  }\n\n  async batchGenerateEmbeddings(params: Parameters<DBWorkerAPI['batchGenerateEmbeddings']>[0]) {\n    return this.call('batchGenerateEmbeddings', params);\n  }\n\n  async regenerateCollectionEmbeddings(collection: string, options?: Parameters<DBWorkerAPI['regenerateCollectionEmbeddings']>[1]) {\n    return this.call('regenerateCollectionEmbeddings', { collection, options });\n  }\n\n  // Embedding queue management\n  async enqueueEmbedding(params: Parameters<DBWorkerAPI['enqueueEmbedding']>[0]): Promise<number> {\n    return this.call('enqueueEmbedding', params);\n  }\n\n  async processEmbeddingQueue(params?: Parameters<DBWorkerAPI['processEmbeddingQueue']>[0]) {\n    return this.call('processEmbeddingQueue', params);\n  }\n\n  async getQueueStatus(collection?: string) {\n    return this.call('getQueueStatus', collection);\n  }\n\n  async clearEmbeddingQueue(params?: Parameters<DBWorkerAPI['clearEmbeddingQueue']>[0]): Promise<number> {\n    return this.call('clearEmbeddingQueue', params);\n  }\n\n  // SCRUM-17: LLM Integration RPC methods\n  async enhanceQuery(params: Parameters<DBWorkerAPI['enhanceQuery']>[0]) {\n    return this.call('enhanceQuery', params);\n  }\n\n  async summarizeResults(params: Parameters<DBWorkerAPI['summarizeResults']>[0]) {\n    return this.call('summarizeResults', params);\n  }\n\n  async searchWithLLM(params: Parameters<DBWorkerAPI['searchWithLLM']>[0]) {\n    return this.call('searchWithLLM', params);\n  }\n\n  async callLLM(params: Parameters<DBWorkerAPI['callLLM']>[0]) {\n    return this.call('callLLM', params);\n  }\n\n  // Task 6.2: Internal Embedding Pipeline RPC methods\n  async generateQueryEmbedding(params: Parameters<DBWorkerAPI[\"generateQueryEmbedding\"]>[0]) {\n    return this.call(\"generateQueryEmbedding\", params);\n  }\n\n  async batchGenerateQueryEmbeddings(params: Parameters<DBWorkerAPI[\"batchGenerateQueryEmbeddings\"]>[0]) {\n    return this.call(\"batchGenerateQueryEmbeddings\", params);\n  }\n\n  async warmEmbeddingCache(params: Parameters<DBWorkerAPI[\"warmEmbeddingCache\"]>[0]) {\n    return this.call(\"warmEmbeddingCache\", params);\n  }\n\n  async clearEmbeddingCache(params?: Parameters<DBWorkerAPI[\"clearEmbeddingCache\"]>[0]) {\n    return this.call(\"clearEmbeddingCache\", params);\n  }\n\n  async getPipelineStats() {\n    return this.call(\"getPipelineStats\");\n  }\n\n  async getModelStatus() {\n    return this.call(\"getModelStatus\");\n  }\n\n  async preloadModels(params: Parameters<DBWorkerAPI[\"preloadModels\"]>[0]) {\n    return this.call(\"preloadModels\", params);\n  }\n\n  async optimizeModelMemory(params?: Parameters<DBWorkerAPI[\"optimizeModelMemory\"]>[0]) {\n    return this.call(\"optimizeModelMemory\", params);\n  }\n\n  // Utility methods\n  getPerformanceMetrics() {\n    const avgLatency = this.performanceMetrics.totalCalls > 0 \n      ? this.performanceMetrics.totalTime / this.performanceMetrics.totalCalls \n      : 0;\n\n    return {\n      ...this.performanceMetrics,\n      averageLatency: avgLatency,\n      pendingOperations: this.pendingCalls.size,\n      successRate: this.performanceMetrics.totalCalls > 0\n        ? (this.performanceMetrics.totalCalls - this.performanceMetrics.errors) / this.performanceMetrics.totalCalls\n        : 1\n    };\n  }\n\n  terminate(): void {\n    this.rejectAllPending(new WorkerError('Worker terminated', 'TERMINATED'));\n    this.worker.terminate();\n  }\n}\n\n/**\n * Server-side RPC handler for the worker\n */\nexport class WorkerRPCHandler {\n  private handlers = new Map<string, (params: any) => Promise<any>>();\n  private config: Required<WorkerConfig>;\n\n  constructor(config: Partial<WorkerConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.setupMessageHandler();\n  }\n\n  private setupMessageHandler(): void {\n    self.onmessage = async (event: MessageEvent<WorkerMessage>) => {\n      const message = event.data;\n      await this.handleMessage(message);\n    };\n  }\n\n  private async handleMessage(message: WorkerMessage): Promise<void> {\n    const startTime = Date.now();\n    let response: WorkerResponse;\n\n    try {\n\n      const handler = this.handlers.get(message.method);\n      if (!handler) {\n        throw new WorkerError(`Unknown method: ${message.method}`, 'UNKNOWN_METHOD');\n      }\n\n      const result = await handler(message.params);\n\n      response = {\n        id: message.id,\n        result\n      };\n    } catch (error) {\n      this.log('error', `Method ${message.method} failed:`, error);\n      \n      response = {\n        id: message.id,\n        error: {\n          message: error instanceof Error ? error.message : String(error),\n          code: error instanceof WorkerError ? error.code : 'UNKNOWN_ERROR',\n          stack: error instanceof Error ? error.stack : undefined\n        }\n      };\n    }\n\n    try {\n      self.postMessage(response);\n    } catch (postError) {\n      this.log('error', 'Failed to post response:', postError);\n      \n      // Try to send a simpler error response\n      const errorResponse: WorkerResponse = {\n        id: message.id,\n        error: {\n          message: 'Failed to serialize response',\n          code: 'SERIALIZATION_ERROR'\n        }\n      };\n      \n      try {\n        self.postMessage(errorResponse);\n      } catch (finalError) {\n        this.log('error', 'Failed to send error response:', finalError);\n      }\n    }\n  }\n\n  register(method: string, handler: (params: any) => Promise<any>): void {\n    this.handlers.set(method, handler);\n    this.log('debug', `Registered handler for method: ${method}`);\n  }\n\n  unregister(method: string): void {\n    this.handlers.delete(method);\n    this.log('debug', `Unregistered handler for method: ${method}`);\n  }\n\n  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string, ...args: any[]): void {\n    const levels = { debug: 0, info: 1, warn: 2, error: 3 };\n    const configLevel = levels[this.config.logLevel];\n    const messageLevel = levels[level];\n\n    if (messageLevel >= configLevel) {\n      console[level](`[WorkerRPCHandler] ${message}`, ...args);\n    }\n  }\n}\n\n/**\n * Utility function to create a typed RPC client\n */\nexport function createWorkerRPC(\n  workerUrl: string | URL, \n  config?: Partial<WorkerConfig>\n): WorkerRPC {\n  const worker = new Worker(workerUrl, { type: 'module' });\n  return new WorkerRPC(worker, config);\n}\n\n/**\n * Helper for handling transferable objects in RPC calls\n */\nexport function createTransferableMessage<T = any>(\n  message: WorkerMessage<T>,\n  transferables: Transferable[] = []\n): [WorkerMessage<T>, Transferable[]] {\n  return [message, transferables];\n}\n\n/**\n * Error handling utilities\n */\nexport function isWorkerError(error: any): error is WorkerError {\n  return error instanceof Error && error.name === 'WorkerError';\n}\n\nexport function createTimeoutError(timeout: number): WorkerError {\n  return new WorkerError(\n    `Operation timed out after ${timeout}ms`,\n    'TIMEOUT'\n  );\n}","/**\r\n * Классы ошибок для системы эмбеддингов LocalRetrieve\r\n *\r\n * Данный модуль предоставляет иерархию классов ошибок для различных\r\n * типов проблем, которые могут возникнуть при работе с эмбеддингами.\r\n */\r\n\r\n/**\r\n * Базовый класс для всех ошибок системы эмбеддингов\r\n */\r\nexport class EmbeddingError extends Error {\r\n  /** Код ошибки для программной обработки */\r\n  public readonly code: string;\r\n\r\n  /** Категория ошибки */\r\n  public readonly category: ErrorCategory;\r\n\r\n  /** Дополнительный контекст ошибки */\r\n  public readonly context?: Record<string, any>;\r\n\r\n  /** Информация о возможном восстановлении */\r\n  public readonly recoveryInfo?: ErrorRecoveryInfo;\r\n\r\n  /** Время возникновения ошибки */\r\n  public readonly timestamp: Date;\r\n\r\n  constructor(\r\n    message: string,\r\n    code: string = 'EMBEDDING_ERROR',\r\n    category: ErrorCategory = 'unknown',\r\n    context?: Record<string, any>,\r\n    recoveryInfo?: ErrorRecoveryInfo\r\n  ) {\r\n    super(message);\r\n    this.name = 'EmbeddingError';\r\n    this.code = code;\r\n    this.category = category;\r\n    this.context = context;\r\n    this.recoveryInfo = recoveryInfo;\r\n    this.timestamp = new Date();\r\n\r\n    // Обеспечиваем правильный прототип для instanceof\r\n    Object.setPrototypeOf(this, EmbeddingError.prototype);\r\n  }\r\n\r\n  /**\r\n   * Создает JSON представление ошибки для логирования\r\n   */\r\n  toJSON(): ErrorJSON {\r\n    return {\r\n      name: this.name,\r\n      message: this.message,\r\n      code: this.code,\r\n      category: this.category,\r\n      context: this.context,\r\n      recoveryInfo: this.recoveryInfo,\r\n      timestamp: this.timestamp.toISOString(),\r\n      stack: this.stack\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Создает пользовательски-дружественное сообщение об ошибке\r\n   */\r\n  getUserMessage(): string {\r\n    switch (this.category) {\r\n      case 'provider':\r\n        return `Ошибка провайдера эмбеддингов: ${this.message}`;\r\n      case 'network':\r\n        return `Проблема с сетевым подключением: ${this.message}`;\r\n      case 'configuration':\r\n        return `Ошибка конфигурации: ${this.message}`;\r\n      case 'validation':\r\n        return `Неверные данные: ${this.message}`;\r\n      case 'quota':\r\n        return `Превышен лимит: ${this.message}`;\r\n      case 'timeout':\r\n        return `Превышено время ожидания: ${this.message}`;\r\n      default:\r\n        return this.message;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки провайдера эмбеддингов\r\n */\r\nexport class ProviderError extends EmbeddingError {\r\n  /** Имя провайдера */\r\n  public readonly providerName: string;\r\n\r\n  /** Версия модели (если применимо) */\r\n  public readonly modelVersion?: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    providerName: string,\r\n    code: string = 'PROVIDER_ERROR',\r\n    modelVersion?: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      code,\r\n      'provider',\r\n      { ...context, providerName, modelVersion },\r\n      {\r\n        canRetry: true,\r\n        retryAfter: 1000,\r\n        maxRetries: 3,\r\n        fallbackAvailable: true\r\n      }\r\n    );\r\n    this.name = 'ProviderError';\r\n    this.providerName = providerName;\r\n    this.modelVersion = modelVersion;\r\n\r\n    Object.setPrototypeOf(this, ProviderError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки инициализации провайдера\r\n */\r\nexport class ProviderInitializationError extends ProviderError {\r\n  constructor(\r\n    message: string,\r\n    providerName: string,\r\n    cause?: Error,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      providerName,\r\n      'PROVIDER_INIT_ERROR',\r\n      undefined,\r\n      { ...context, cause: cause?.message }\r\n    );\r\n    this.name = 'ProviderInitializationError';\r\n\r\n    // Инициализация обычно не подлежит автоматическому повтору\r\n    (this as any).recoveryInfo = {\r\n      canRetry: false,\r\n      retryAfter: 0,\r\n      maxRetries: 0,\r\n      fallbackAvailable: true,\r\n      userActionRequired: true,\r\n      suggestedActions: [\r\n        'Проверьте конфигурацию провайдера',\r\n        'Убедитесь, что API ключ корректен',\r\n        'Проверьте доступность сервиса'\r\n      ]\r\n    };\r\n\r\n    Object.setPrototypeOf(this, ProviderInitializationError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки загрузки модели\r\n */\r\nexport class ModelLoadError extends ProviderError {\r\n  /** Имя модели */\r\n  public readonly modelName: string;\r\n\r\n  /** Размер модели в байтах */\r\n  public readonly modelSize?: number;\r\n\r\n  constructor(\r\n    message: string,\r\n    providerName: string,\r\n    modelName: string,\r\n    modelSize?: number,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      providerName,\r\n      'MODEL_LOAD_ERROR',\r\n      undefined,\r\n      { ...context, modelName, modelSize }\r\n    );\r\n    this.name = 'ModelLoadError';\r\n    this.modelName = modelName;\r\n    this.modelSize = modelSize;\r\n\r\n    Object.setPrototypeOf(this, ModelLoadError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Сетевые ошибки\r\n */\r\nexport class NetworkError extends EmbeddingError {\r\n  /** HTTP статус код (если применимо) */\r\n  public readonly statusCode?: number;\r\n\r\n  /** URL запроса */\r\n  public readonly url?: string;\r\n\r\n  /** Тип сетевой ошибки */\r\n  public readonly networkType: NetworkErrorType;\r\n\r\n  constructor(\r\n    message: string,\r\n    networkType: NetworkErrorType,\r\n    statusCode?: number,\r\n    url?: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    const code = `NETWORK_${networkType.toUpperCase()}_ERROR`;\r\n    const retryAfter = NetworkError.getRetryDelay(statusCode, networkType);\r\n\r\n    super(\r\n      message,\r\n      code,\r\n      'network',\r\n      { ...context, statusCode, url, networkType },\r\n      {\r\n        canRetry: NetworkError.isRetryable(statusCode, networkType),\r\n        retryAfter,\r\n        maxRetries: 5,\r\n        fallbackAvailable: false\r\n      }\r\n    );\r\n\r\n    this.name = 'NetworkError';\r\n    this.statusCode = statusCode;\r\n    this.url = url;\r\n    this.networkType = networkType;\r\n\r\n    Object.setPrototypeOf(this, NetworkError.prototype);\r\n  }\r\n\r\n  /**\r\n   * Определяет, можно ли повторить запрос\r\n   */\r\n  private static isRetryable(statusCode?: number, networkType?: NetworkErrorType): boolean {\r\n    if (networkType === 'timeout' || networkType === 'connection') {\r\n      return true;\r\n    }\r\n\r\n    if (statusCode) {\r\n      // Повторяем при серверных ошибках и некоторых клиентских\r\n      return statusCode >= 500 || statusCode === 429 || statusCode === 408;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Вычисляет задержку перед повтором\r\n   */\r\n  private static getRetryDelay(statusCode?: number, networkType?: NetworkErrorType): number {\r\n    if (statusCode === 429) return 60000; // Rate limit - ждем минуту\r\n    if (networkType === 'timeout') return 5000; // Timeout - ждем 5 секунд\r\n    if (statusCode && statusCode >= 500) return 2000; // Server error - ждем 2 секунды\r\n    return 1000; // По умолчанию 1 секунда\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки аутентификации\r\n */\r\nexport class AuthenticationError extends EmbeddingError {\r\n  /** Тип ошибки аутентификации */\r\n  public readonly authType: AuthErrorType;\r\n\r\n  constructor(\r\n    message: string,\r\n    authType: AuthErrorType,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'AUTH_ERROR',\r\n      'authentication',\r\n      { ...context, authType },\r\n      {\r\n        canRetry: false,\r\n        retryAfter: 0,\r\n        maxRetries: 0,\r\n        fallbackAvailable: false,\r\n        userActionRequired: true,\r\n        suggestedActions: AuthenticationError.getSuggestedActions(authType)\r\n      }\r\n    );\r\n\r\n    this.name = 'AuthenticationError';\r\n    this.authType = authType;\r\n\r\n    Object.setPrototypeOf(this, AuthenticationError.prototype);\r\n  }\r\n\r\n  private static getSuggestedActions(authType: AuthErrorType): string[] {\r\n    switch (authType) {\r\n      case 'invalid_key':\r\n        return ['Проверьте правильность API ключа', 'Убедитесь, что ключ не истек'];\r\n      case 'expired_key':\r\n        return ['Обновите API ключ', 'Проверьте дату истечения подписки'];\r\n      case 'insufficient_permissions':\r\n        return ['Проверьте права доступа', 'Обратитесь к администратору'];\r\n      case 'quota_exceeded':\r\n        return ['Проверьте лимиты использования', 'Обновите тарифный план'];\r\n      default:\r\n        return ['Проверьте настройки аутентификации'];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки конфигурации\r\n */\r\nexport class ConfigurationError extends EmbeddingError {\r\n  /** Имя некорректного параметра */\r\n  public readonly parameterName: string;\r\n\r\n  /** Ожидаемое значение или тип */\r\n  public readonly expectedValue?: string;\r\n\r\n  /** Текущее (неверное) значение */\r\n  public readonly actualValue?: any;\r\n\r\n  constructor(\r\n    message: string,\r\n    parameterName: string,\r\n    expectedValue?: string,\r\n    actualValue?: any,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'CONFIG_ERROR',\r\n      'configuration',\r\n      { ...context, parameterName, expectedValue, actualValue },\r\n      {\r\n        canRetry: false,\r\n        retryAfter: 0,\r\n        maxRetries: 0,\r\n        fallbackAvailable: false,\r\n        userActionRequired: true,\r\n        suggestedActions: [\r\n          `Исправьте параметр '${parameterName}'`,\r\n          expectedValue ? `Ожидается: ${expectedValue}` : 'Проверьте документацию'\r\n        ]\r\n      }\r\n    );\r\n\r\n    this.name = 'ConfigurationError';\r\n    this.parameterName = parameterName;\r\n    this.expectedValue = expectedValue;\r\n    this.actualValue = actualValue;\r\n\r\n    Object.setPrototypeOf(this, ConfigurationError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки валидации данных\r\n */\r\nexport class ValidationError extends EmbeddingError {\r\n  /** Поле, которое не прошло валидацию */\r\n  public readonly fieldName: string;\r\n\r\n  /** Правило валидации, которое было нарушено */\r\n  public readonly validationRule: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    fieldName: string,\r\n    validationRule: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'VALIDATION_ERROR',\r\n      'validation',\r\n      { ...context, fieldName, validationRule },\r\n      {\r\n        canRetry: false,\r\n        retryAfter: 0,\r\n        maxRetries: 0,\r\n        fallbackAvailable: false,\r\n        userActionRequired: true,\r\n        suggestedActions: [`Исправьте поле '${fieldName}' согласно правилу: ${validationRule}`]\r\n      }\r\n    );\r\n\r\n    this.name = 'ValidationError';\r\n    this.fieldName = fieldName;\r\n    this.validationRule = validationRule;\r\n\r\n    Object.setPrototypeOf(this, ValidationError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки превышения лимитов\r\n */\r\nexport class QuotaExceededError extends EmbeddingError {\r\n  /** Тип превышенного лимита */\r\n  public readonly quotaType: QuotaType;\r\n\r\n  /** Текущее значение */\r\n  public readonly currentValue: number;\r\n\r\n  /** Максимально допустимое значение */\r\n  public readonly maxValue: number;\r\n\r\n  /** Время сброса лимита */\r\n  public readonly resetTime?: Date;\r\n\r\n  constructor(\r\n    message: string,\r\n    quotaType: QuotaType,\r\n    currentValue: number,\r\n    maxValue: number,\r\n    resetTime?: Date,\r\n    context?: Record<string, any>\r\n  ) {\r\n    const retryAfter = resetTime ? resetTime.getTime() - Date.now() : 3600000; // 1 час по умолчанию\r\n\r\n    super(\r\n      message,\r\n      'QUOTA_EXCEEDED',\r\n      'quota',\r\n      { ...context, quotaType, currentValue, maxValue, resetTime },\r\n      {\r\n        canRetry: true,\r\n        retryAfter: Math.max(retryAfter, 0),\r\n        maxRetries: 1,\r\n        fallbackAvailable: quotaType !== 'api_calls',\r\n        suggestedActions: QuotaExceededError.getSuggestedActions(quotaType, resetTime)\r\n      }\r\n    );\r\n\r\n    this.name = 'QuotaExceededError';\r\n    this.quotaType = quotaType;\r\n    this.currentValue = currentValue;\r\n    this.maxValue = maxValue;\r\n    this.resetTime = resetTime;\r\n\r\n    Object.setPrototypeOf(this, QuotaExceededError.prototype);\r\n  }\r\n\r\n  private static getSuggestedActions(quotaType: QuotaType, resetTime?: Date): string[] {\r\n    const actions = [`Превышен лимит: ${quotaType}`];\r\n\r\n    if (resetTime) {\r\n      actions.push(`Лимит будет сброшен: ${resetTime.toLocaleString()}`);\r\n    }\r\n\r\n    switch (quotaType) {\r\n      case 'api_calls':\r\n        actions.push('Подождите до сброса лимита или обновите тариф');\r\n        break;\r\n      case 'tokens':\r\n        actions.push('Сократите размер текста или разбейте на части');\r\n        break;\r\n      case 'memory':\r\n        actions.push('Очистите кэш или используйте меньшую модель');\r\n        break;\r\n      case 'concurrent_requests':\r\n        actions.push('Дождитесь завершения текущих запросов');\r\n        break;\r\n    }\r\n\r\n    return actions;\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки тайм-аута\r\n */\r\nexport class TimeoutError extends EmbeddingError {\r\n  /** Время ожидания в миллисекундах */\r\n  public readonly timeoutMs: number;\r\n\r\n  /** Операция, которая была прервана */\r\n  public readonly operation: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    timeoutMs: number,\r\n    operation: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'TIMEOUT_ERROR',\r\n      'timeout',\r\n      { ...context, timeoutMs, operation },\r\n      {\r\n        canRetry: true,\r\n        retryAfter: Math.min(timeoutMs * 0.5, 5000), // Половина от таймаута, но не более 5 сек\r\n        maxRetries: 3,\r\n        fallbackAvailable: true,\r\n        suggestedActions: [\r\n          'Увеличьте таймаут в настройках',\r\n          'Проверьте размер обрабатываемых данных',\r\n          'Попробуйте разбить операцию на части'\r\n        ]\r\n      }\r\n    );\r\n\r\n    this.name = 'TimeoutError';\r\n    this.timeoutMs = timeoutMs;\r\n    this.operation = operation;\r\n\r\n    Object.setPrototypeOf(this, TimeoutError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки работы с кэшем\r\n */\r\nexport class CacheError extends EmbeddingError {\r\n  /** Тип операции с кэшем */\r\n  public readonly cacheOperation: CacheOperation;\r\n\r\n  /** Ключ кэша */\r\n  public readonly cacheKey?: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    cacheOperation: CacheOperation,\r\n    cacheKey?: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'CACHE_ERROR',\r\n      'cache',\r\n      { ...context, cacheOperation, cacheKey },\r\n      {\r\n        canRetry: cacheOperation !== 'write', // Записи обычно не повторяем\r\n        retryAfter: 1000,\r\n        maxRetries: 2,\r\n        fallbackAvailable: true // Можно работать без кэша\r\n      }\r\n    );\r\n\r\n    this.name = 'CacheError';\r\n    this.cacheOperation = cacheOperation;\r\n    this.cacheKey = cacheKey;\r\n\r\n    Object.setPrototypeOf(this, CacheError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки работы с воркерами\r\n */\r\nexport class WorkerError extends EmbeddingError {\r\n  /** Идентификатор воркера */\r\n  public readonly workerId?: string;\r\n\r\n  /** Тип операции воркера */\r\n  public readonly workerOperation: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    workerOperation: string,\r\n    workerId?: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'WORKER_ERROR',\r\n      'worker',\r\n      { ...context, workerOperation, workerId },\r\n      {\r\n        canRetry: true,\r\n        retryAfter: 2000,\r\n        maxRetries: 3,\r\n        fallbackAvailable: false,\r\n        suggestedActions: [\r\n          'Перезагрузите страницу',\r\n          'Проверьте поддержку Web Workers в браузере'\r\n        ]\r\n      }\r\n    );\r\n\r\n    this.name = 'WorkerError';\r\n    this.workerId = workerId;\r\n    this.workerOperation = workerOperation;\r\n\r\n    Object.setPrototypeOf(this, WorkerError.prototype);\r\n  }\r\n}\r\n\r\n// Типы для категоризации ошибок\r\n\r\nexport type ErrorCategory =\r\n  | 'provider'        // Ошибки провайдера эмбеддингов\r\n  | 'network'         // Сетевые ошибки\r\n  | 'authentication' // Ошибки аутентификации\r\n  | 'configuration'  // Ошибки конфигурации\r\n  | 'validation'     // Ошибки валидации данных\r\n  | 'quota'          // Превышение лимитов\r\n  | 'timeout'        // Ошибки тайм-аута\r\n  | 'cache'          // Ошибки кэширования\r\n  | 'worker'         // Ошибки воркеров\r\n  | 'unknown';       // Неизвестные ошибки\r\n\r\nexport type NetworkErrorType =\r\n  | 'connection'     // Ошибки подключения\r\n  | 'timeout'        // Таймауты сети\r\n  | 'rate_limit'     // Превышение rate limit\r\n  | 'server_error'   // Ошибки сервера (5xx)\r\n  | 'client_error'   // Ошибки клиента (4xx)\r\n  | 'dns'           // Ошибки DNS\r\n  | 'ssl';          // Ошибки SSL/TLS\r\n\r\nexport type AuthErrorType =\r\n  | 'invalid_key'               // Неверный API ключ\r\n  | 'expired_key'               // Истекший ключ\r\n  | 'insufficient_permissions'  // Недостаточно прав\r\n  | 'quota_exceeded';           // Превышена квота\r\n\r\nexport type QuotaType =\r\n  | 'api_calls'           // Лимит API вызовов\r\n  | 'tokens'              // Лимит токенов\r\n  | 'memory'              // Лимит памяти\r\n  | 'concurrent_requests' // Лимит одновременных запросов\r\n  | 'storage';            // Лимит хранилища\r\n\r\nexport type CacheOperation =\r\n  | 'read'    // Чтение из кэша\r\n  | 'write'   // Запись в кэш\r\n  | 'delete'  // Удаление из кэша\r\n  | 'clear'   // Очистка кэша\r\n  | 'init'    // Инициализация кэша\r\n  | 'SET_FAILED'      // Ошибка записи\r\n  | 'INVALIDATION_FAILED'; // Ошибка инвалидации\r\n\r\n// Интерфейсы для дополнительной информации\r\n\r\nexport interface ErrorRecoveryInfo {\r\n  /** Можно ли автоматически повторить операцию */\r\n  canRetry: boolean;\r\n\r\n  /** Задержка перед повтором в миллисекундах */\r\n  retryAfter: number;\r\n\r\n  /** Максимальное количество попыток */\r\n  maxRetries: number;\r\n\r\n  /** Доступен ли fallback механизм */\r\n  fallbackAvailable: boolean;\r\n\r\n  /** Требуется ли действие пользователя */\r\n  userActionRequired?: boolean;\r\n\r\n  /** Предлагаемые действия для исправления */\r\n  suggestedActions?: string[];\r\n}\r\n\r\nexport interface ErrorJSON {\r\n  name: string;\r\n  message: string;\r\n  code: string;\r\n  category: ErrorCategory;\r\n  context?: Record<string, any>;\r\n  recoveryInfo?: ErrorRecoveryInfo;\r\n  timestamp: string;\r\n  stack?: string;\r\n}\r\n\r\n/**\r\n * Утилитарные функции для работы с ошибками\r\n */\r\nexport class ErrorUtils {\r\n  /**\r\n   * Проверяет, является ли ошибка ошибкой эмбеддингов\r\n   */\r\n  static isEmbeddingError(error: any): error is EmbeddingError {\r\n    return error instanceof EmbeddingError;\r\n  }\r\n\r\n  /**\r\n   * Проверяет, можно ли повторить операцию после ошибки\r\n   */\r\n  static canRetry(error: Error): boolean {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error.recoveryInfo?.canRetry ?? false;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Получает задержку перед повтором\r\n   */\r\n  static getRetryDelay(error: Error): number {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error.recoveryInfo?.retryAfter ?? 1000;\r\n    }\r\n    return 1000;\r\n  }\r\n\r\n  /**\r\n   * Получает максимальное количество повторов\r\n   */\r\n  static getMaxRetries(error: Error): number {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error.recoveryInfo?.maxRetries ?? 3;\r\n    }\r\n    return 3;\r\n  }\r\n\r\n  /**\r\n   * Создает пользовательски-дружественное сообщение об ошибке\r\n   */\r\n  static getUserMessage(error: Error): string {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error.getUserMessage();\r\n    }\r\n    return error.message;\r\n  }\r\n\r\n  /**\r\n   * Получает предлагаемые действия для исправления ошибки\r\n   */\r\n  static getSuggestedActions(error: Error): string[] {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error.recoveryInfo?.suggestedActions ?? [];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Конвертирует любую ошибку в EmbeddingError\r\n   */\r\n  static toEmbeddingError(error: any, defaultMessage: string = 'Unknown error'): EmbeddingError {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error;\r\n    }\r\n\r\n    if (error instanceof Error) {\r\n      return new EmbeddingError(\r\n        error.message || defaultMessage,\r\n        'UNKNOWN_ERROR',\r\n        'unknown',\r\n        { originalError: error.name, stack: error.stack }\r\n      );\r\n    }\r\n\r\n    return new EmbeddingError(\r\n      typeof error === 'string' ? error : defaultMessage,\r\n      'UNKNOWN_ERROR',\r\n      'unknown',\r\n      { originalError: error }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Логирует ошибку с соответствующим уровнем\r\n   */\r\n  static logError(error: Error, logger?: Console): void {\r\n    const log = logger || console;\r\n\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      const level = ErrorUtils.getLogLevel(error.category);\r\n      const logMethod = log[level] || log.error;\r\n      logMethod(`[${error.category.toUpperCase()}] ${error.name}: ${error.message}`, error.toJSON());\r\n    } else {\r\n      log.error('Unknown error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Определяет уровень логирования для категории ошибки\r\n   */\r\n  private static getLogLevel(category: ErrorCategory): 'error' | 'warn' | 'info' {\r\n    switch (category) {\r\n      case 'provider':\r\n      case 'network':\r\n      case 'authentication':\r\n      case 'worker':\r\n        return 'error';\r\n      case 'quota':\r\n      case 'timeout':\r\n        return 'warn';\r\n      case 'cache':\r\n      case 'validation':\r\n      case 'configuration':\r\n        return 'info';\r\n      default:\r\n        return 'error';\r\n    }\r\n  }\r\n}","/**\r\n * Базовый интерфейс и типы для провайдеров эмбеддингов\r\n *\r\n * Данный модуль определяет основной интерфейс EmbeddingProvider, который должны\r\n * реализовывать все провайдеры эмбеддингов (локальные и внешние).\r\n *\r\n * Ключевые принципы:\r\n * - Фиксированная размерность на экземпляр провайдера\r\n * - Конфигурация на уровне коллекций\r\n * - Неблокирующая архитектура для UI\r\n */\r\n\r\nimport type { EmbeddingConfig, CollectionEmbeddingConfig } from '../types.js';\r\nimport { EmbeddingError, ProviderError } from '../errors.js';\r\n\r\n/**\r\n * Базовый интерфейс провайдера эмбеддингов\r\n *\r\n * Каждый экземпляр провайдера имеет фиксированную размерность,\r\n * которая устанавливается при создании и не может быть изменена.\r\n */\r\nexport interface EmbeddingProvider {\r\n  /** Уникальное имя провайдера (например: 'transformers', 'openai', 'cohere') */\r\n  readonly name: string;\r\n\r\n  /** Размерность векторов, которые генерирует данный экземпляр провайдера */\r\n  readonly dimensions: number;\r\n\r\n  /** Максимальный размер батча для пакетной обработки */\r\n  readonly maxBatchSize: number;\r\n\r\n  /** Максимальная длина текста в токенах для данного провайдера */\r\n  readonly maxTextLength: number;\r\n\r\n  /** Флаг готовности провайдера к работе */\r\n  readonly isReady: boolean;\r\n\r\n  /**\r\n   * Инициализация провайдера с заданной конфигурацией\r\n   *\r\n   * @param config - Конфигурация эмбеддингов\r\n   * @throws {ProviderError} При ошибках загрузки модели или аутентификации\r\n   */\r\n  initialize(config: EmbeddingConfig): Promise<void>;\r\n\r\n  /**\r\n   * Генерация эмбеддинга для одного текста\r\n   *\r\n   * @param text - Текст для генерации эмбеддинга\r\n   * @returns Вектор размерности this.dimensions\r\n   * @throws {EmbeddingError} При ошибках генерации\r\n   */\r\n  generateEmbedding(text: string): Promise<Float32Array>;\r\n\r\n  /**\r\n   * Пакетная генерация эмбеддингов\r\n   *\r\n   * Рекомендуется для обработки больших объемов данных.\r\n   * Размер батча не должен превышать maxBatchSize.\r\n   *\r\n   * @param texts - Массив текстов для обработки\r\n   * @returns Массив векторов в том же порядке, что и входные тексты\r\n   * @throws {EmbeddingError} При ошибках генерации\r\n   */\r\n  generateBatch(texts: string[]): Promise<Float32Array[]>;\r\n\r\n  /**\r\n   * Очистка ресурсов и завершение работы провайдера\r\n   *\r\n   * Должна вызываться при завершении работы с провайдером\r\n   * для освобождения памяти и других ресурсов.\r\n   */\r\n  cleanup(): Promise<void>;\r\n\r\n  /**\r\n   * Проверка здоровья провайдера\r\n   *\r\n   * @returns Информация о состоянии провайдера\r\n   */\r\n  healthCheck(): Promise<ProviderHealthStatus>;\r\n\r\n  /**\r\n   * Получение статистики работы провайдера\r\n   *\r\n   * @returns Метрики производительности\r\n   */\r\n  getMetrics(): ProviderMetrics;\r\n}\r\n\r\n/**\r\n * Статус здоровья провайдера\r\n */\r\nexport interface ProviderHealthStatus {\r\n  /** Готов ли провайдер к работе */\r\n  isHealthy: boolean;\r\n\r\n  /** Время последней успешной операции */\r\n  lastSuccessfulOperation?: Date;\r\n\r\n  /** Описание текущего состояния */\r\n  status: 'ready' | 'initializing' | 'error' | 'degraded';\r\n\r\n  /** Дополнительная информация о состоянии */\r\n  details?: string;\r\n\r\n  /** Доступная память (для локальных провайдеров) */\r\n  availableMemory?: number;\r\n\r\n  /** Состояние подключения (для внешних API) */\r\n  connectionStatus?: 'connected' | 'disconnected' | 'limited';\r\n}\r\n\r\n/**\r\n * Метрики производительности провайдера\r\n */\r\nexport interface ProviderMetrics {\r\n  /** Общее количество сгенерированных эмбеддингов */\r\n  totalEmbeddings: number;\r\n\r\n  /** Среднее время генерации одного эмбеддинга (мс) */\r\n  averageGenerationTime: number;\r\n\r\n  /** Количество ошибок */\r\n  errorCount: number;\r\n\r\n  /** Время последнего сброса метрик */\r\n  metricsResetTime: Date;\r\n\r\n  /** Использование памяти (байты) */\r\n  memoryUsage?: number;\r\n\r\n  /** Количество запросов к внешнему API */\r\n  apiRequestCount?: number;\r\n\r\n  /** Скорость ограничений (requests per minute) */\r\n  rateLimitStatus?: {\r\n    remaining: number;\r\n    resetTime: Date;\r\n  };\r\n}\r\n\r\n/**\r\n * Результат валидации конфигурации провайдера\r\n */\r\nexport interface ProviderConfigValidation {\r\n  /** Валидна ли конфигурация */\r\n  isValid: boolean;\r\n\r\n  /** Ошибки валидации */\r\n  errors: string[];\r\n\r\n  /** Предупреждения */\r\n  warnings: string[];\r\n\r\n  /** Рекомендуемые исправления */\r\n  suggestions: string[];\r\n}\r\n\r\n/**\r\n * Абстрактный базовый класс для провайдеров эмбеддингов\r\n *\r\n * Предоставляет общую функциональность и валидацию для всех провайдеров.\r\n */\r\nexport abstract class BaseEmbeddingProvider implements EmbeddingProvider {\r\n  public readonly name: string;\r\n  public readonly dimensions: number;\r\n  public readonly maxBatchSize: number;\r\n  public readonly maxTextLength: number;\r\n\r\n  protected _isReady = false;\r\n  protected metrics: ProviderMetrics;\r\n  protected config?: EmbeddingConfig;\r\n\r\n  constructor(\r\n    name: string,\r\n    dimensions: number,\r\n    maxBatchSize: number = 32,\r\n    maxTextLength: number = 512\r\n  ) {\r\n    this.name = name;\r\n    this.dimensions = dimensions;\r\n    this.maxBatchSize = maxBatchSize;\r\n    this.maxTextLength = maxTextLength;\r\n\r\n    this.metrics = {\r\n      totalEmbeddings: 0,\r\n      averageGenerationTime: 0,\r\n      errorCount: 0,\r\n      metricsResetTime: new Date()\r\n    };\r\n  }\r\n\r\n  public get isReady(): boolean {\r\n    return this._isReady;\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации провайдера\r\n   *\r\n   * @param config - Конфигурация для валидации\r\n   * @returns Результат валидации\r\n   */\r\n  public validateConfig(config: EmbeddingConfig): ProviderConfigValidation {\r\n    const errors: string[] = [];\r\n    const warnings: string[] = [];\r\n    const suggestions: string[] = [];\r\n\r\n    // Базовая валидация\r\n    if (!config.provider && !config.defaultProvider) {\r\n      errors.push('Provider type is required');\r\n    }\r\n\r\n    if (config.timeout && config.timeout < 1000) {\r\n      warnings.push('Timeout less than 1 second may cause frequent timeouts');\r\n      suggestions.push('Consider increasing timeout to at least 5000ms');\r\n    }\r\n\r\n    if (config.batchSize && config.batchSize > this.maxBatchSize) {\r\n      errors.push(`Batch size ${config.batchSize} exceeds maximum ${this.maxBatchSize}`);\r\n      suggestions.push(`Set batch size to ${this.maxBatchSize} or less`);\r\n    }\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n      suggestions\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Валидация входного текста\r\n   *\r\n   * @param text - Текст для валидации\r\n   * @throws {EmbeddingError} При невалидном тексте\r\n   */\r\n  protected validateText(text: string): void {\r\n    if (!text || typeof text !== 'string') {\r\n      throw new EmbeddingError('Input text must be a non-empty string');\r\n    }\r\n\r\n    if (text.trim().length === 0) {\r\n      throw new EmbeddingError('Input text cannot be empty or whitespace only');\r\n    }\r\n\r\n    // Проверка длины (примерная оценка токенов)\r\n    const estimatedTokens = text.length / 4; // Примерно 4 символа на токен\r\n    if (estimatedTokens > this.maxTextLength) {\r\n      throw new EmbeddingError(\r\n        `Text too long: ~${Math.round(estimatedTokens)} tokens, max: ${this.maxTextLength}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Валидация массива текстов для пакетной обработки\r\n   *\r\n   * @param texts - Массив текстов для валидации\r\n   * @throws {EmbeddingError} При невалидных данных\r\n   */\r\n  protected validateBatch(texts: string[]): void {\r\n    if (!Array.isArray(texts)) {\r\n      throw new EmbeddingError('Input must be an array of strings');\r\n    }\r\n\r\n    if (texts.length === 0) {\r\n      throw new EmbeddingError('Batch cannot be empty');\r\n    }\r\n\r\n    if (texts.length > this.maxBatchSize) {\r\n      throw new EmbeddingError(\r\n        `Batch size ${texts.length} exceeds maximum ${this.maxBatchSize}`\r\n      );\r\n    }\r\n\r\n    // Валидация каждого текста\r\n    texts.forEach((text, index) => {\r\n      try {\r\n        this.validateText(text);\r\n      } catch (error) {\r\n        throw new EmbeddingError(\r\n          `Invalid text at index ${index}: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Обновление метрик производительности\r\n   *\r\n   * @param generationTime - Время генерации в миллисекундах\r\n   * @param embeddingCount - Количество сгенерированных эмбеддингов\r\n   * @param isError - Была ли ошибка\r\n   */\r\n  protected updateMetrics(generationTime: number, embeddingCount: number = 1, isError: boolean = false): void {\r\n    if (isError) {\r\n      this.metrics.errorCount += 1;\r\n      return;\r\n    }\r\n\r\n    const totalTime = this.metrics.averageGenerationTime * this.metrics.totalEmbeddings;\r\n    this.metrics.totalEmbeddings += embeddingCount;\r\n    this.metrics.averageGenerationTime = (totalTime + generationTime) / this.metrics.totalEmbeddings;\r\n  }\r\n\r\n  /**\r\n   * Сброс метрик производительности\r\n   */\r\n  public resetMetrics(): void {\r\n    this.metrics = {\r\n      totalEmbeddings: 0,\r\n      averageGenerationTime: 0,\r\n      errorCount: 0,\r\n      metricsResetTime: new Date()\r\n    };\r\n  }\r\n\r\n  public getMetrics(): ProviderMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  // Абстрактные методы, которые должны быть реализованы в дочерних классах\r\n  public abstract initialize(config: EmbeddingConfig): Promise<void>;\r\n  public abstract generateEmbedding(text: string): Promise<Float32Array>;\r\n  public abstract generateBatch(texts: string[]): Promise<Float32Array[]>;\r\n  public abstract cleanup(): Promise<void>;\r\n  public abstract healthCheck(): Promise<ProviderHealthStatus>;\r\n}\r\n\r\n/**\r\n * Фабрика для создания провайдеров эмбеддингов\r\n */\r\nexport interface EmbeddingProviderFactory {\r\n  /**\r\n   * Создание экземпляра провайдера\r\n   *\r\n   * @param config - Конфигурация коллекции\r\n   * @returns Экземпляр провайдера с фиксированной размерностью\r\n   */\r\n  createProvider(config: CollectionEmbeddingConfig): Promise<EmbeddingProvider>;\r\n\r\n  /**\r\n   * Проверка поддержки конфигурации\r\n   *\r\n   * @param config - Конфигурация для проверки\r\n   * @returns true, если конфигурация поддерживается\r\n   */\r\n  supportsConfig(config: CollectionEmbeddingConfig): boolean;\r\n\r\n  /**\r\n   * Получение доступных моделей для провайдера\r\n   *\r\n   * @returns Список доступных моделей с их характеристиками\r\n   */\r\n  getAvailableModels(): Promise<ModelInfo[]>;\r\n}\r\n\r\n/**\r\n * Информация о доступной модели\r\n */\r\nexport interface ModelInfo {\r\n  /** Идентификатор модели */\r\n  id: string;\r\n\r\n  /** Отображаемое название */\r\n  name: string;\r\n\r\n  /** Описание модели */\r\n  description: string;\r\n\r\n  /** Размерность векторов */\r\n  dimensions: number;\r\n\r\n  /** Максимальная длина входного текста */\r\n  maxInputLength: number;\r\n\r\n  /** Поддерживаемые языки */\r\n  languages: string[];\r\n\r\n  /** Рекомендуемые случаи использования */\r\n  useCases: string[];\r\n\r\n  /** Размер модели (для локальных моделей) */\r\n  modelSize?: number;\r\n\r\n  /** Стоимость за токен (для API) */\r\n  costPerToken?: number;\r\n}\r\n\r\n/**\r\n * Вспомогательные функции для работы с провайдерами\r\n */\r\nexport class ProviderUtils {\r\n  /**\r\n   * Нормализация вектора эмбеддинга\r\n   *\r\n   * @param embedding - Вектор для нормализации\r\n   * @returns Нормализованный вектор\r\n   */\r\n  static normalizeEmbedding(embedding: Float32Array): Float32Array {\r\n    let norm = 0;\r\n    for (let i = 0; i < embedding.length; i++) {\r\n      norm += embedding[i] * embedding[i];\r\n    }\r\n    norm = Math.sqrt(norm);\r\n\r\n    if (norm === 0) {\r\n      throw new EmbeddingError('Cannot normalize zero vector');\r\n    }\r\n\r\n    const normalized = new Float32Array(embedding.length);\r\n    for (let i = 0; i < embedding.length; i++) {\r\n      normalized[i] = embedding[i] / norm;\r\n    }\r\n\r\n    return normalized;\r\n  }\r\n\r\n  /**\r\n   * Вычисление косинусного расстояния между векторами\r\n   *\r\n   * @param a - Первый вектор\r\n   * @param b - Второй вектор\r\n   * @returns Косинусное расстояние (0 = идентичные, 2 = противоположные)\r\n   */\r\n  static cosineDistance(a: Float32Array, b: Float32Array): number {\r\n    if (a.length !== b.length) {\r\n      throw new EmbeddingError('Vectors must have the same dimensions');\r\n    }\r\n\r\n    let dotProduct = 0;\r\n    let normA = 0;\r\n    let normB = 0;\r\n\r\n    for (let i = 0; i < a.length; i++) {\r\n      dotProduct += a[i] * b[i];\r\n      normA += a[i] * a[i];\r\n      normB += b[i] * b[i];\r\n    }\r\n\r\n    normA = Math.sqrt(normA);\r\n    normB = Math.sqrt(normB);\r\n\r\n    if (normA === 0 || normB === 0) {\r\n      return 2; // Максимальное расстояние для нулевых векторов\r\n    }\r\n\r\n    const cosineSimilarity = dotProduct / (normA * normB);\r\n    return 1 - cosineSimilarity; // Конвертация в расстояние\r\n  }\r\n\r\n  /**\r\n   * Создание случайного вектора (для тестирования)\r\n   *\r\n   * @param dimensions - Размерность вектора\r\n   * @param normalize - Нормализовать ли вектор\r\n   * @returns Случайный вектор\r\n   */\r\n  static createRandomEmbedding(dimensions: number, normalize: boolean = true): Float32Array {\r\n    const embedding = new Float32Array(dimensions);\r\n    for (let i = 0; i < dimensions; i++) {\r\n      embedding[i] = Math.random() * 2 - 1; // Значения от -1 до 1\r\n    }\r\n\r\n    return normalize ? this.normalizeEmbedding(embedding) : embedding;\r\n  }\r\n}","/**\r\n * Базовый класс для внешних провайдеров эмбеддингов (API)\r\n *\r\n * Данный модуль предоставляет общую функциональность для всех провайдеров,\r\n * которые используют внешние API для генерации эмбеддингов.\r\n *\r\n * Ключевые возможности:\r\n * - Управление API ключами\r\n * - Rate limiting с exponential backoff\r\n * - Retry логика\r\n * - Метрики API запросов\r\n * - Обработка сетевых ошибок\r\n */\r\n\r\nimport { BaseEmbeddingProvider, ProviderHealthStatus, ProviderMetrics } from './BaseProvider.js';\r\nimport type { EmbeddingConfig } from '../types.js';\r\nimport {\r\n  EmbeddingError,\r\n  ProviderError,\r\n  NetworkError,\r\n  AuthenticationError,\r\n  QuotaExceededError,\r\n  TimeoutError\r\n} from '../errors.js';\r\n\r\n/**\r\n * Конфигурация для внешних API провайдеров\r\n */\r\nexport interface ExternalProviderConfig {\r\n  /** API ключ (обязателен для внешних провайдеров) */\r\n  apiKey: string;\r\n\r\n  /** Базовый URL для API (опционально) */\r\n  baseUrl?: string;\r\n\r\n  /** Таймаут запросов в миллисекундах */\r\n  timeout?: number;\r\n\r\n  /** Максимальное количество попыток */\r\n  maxRetries?: number;\r\n\r\n  /** Включить ли rate limiting */\r\n  enableRateLimit?: boolean;\r\n\r\n  /** Лимит запросов в минуту */\r\n  requestsPerMinute?: number;\r\n\r\n  /** Дополнительные заголовки */\r\n  headers?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Информация о rate limiting\r\n */\r\ninterface RateLimitInfo {\r\n  /** Количество оставшихся запросов */\r\n  remaining: number;\r\n\r\n  /** Время сброса лимита */\r\n  resetTime: Date;\r\n\r\n  /** Максимальное количество запросов в периоде */\r\n  limit: number;\r\n}\r\n\r\n/**\r\n * Состояние retry попыток\r\n */\r\ninterface RetryState {\r\n  /** Текущая попытка */\r\n  attempt: number;\r\n\r\n  /** Время последней попытки */\r\n  lastAttempt: Date;\r\n\r\n  /** Задержка перед следующей попытками */\r\n  nextDelay: number;\r\n}\r\n\r\n/**\r\n * Абстрактный базовый класс для внешних API провайдеров\r\n */\r\nexport abstract class ExternalProvider extends BaseEmbeddingProvider {\r\n  protected config?: EmbeddingConfig & ExternalProviderConfig;\r\n  protected rateLimitInfo?: RateLimitInfo;\r\n  protected requestQueue: Array<() => void> = [];\r\n  protected isProcessingQueue = false;\r\n  protected lastRequestTime = 0;\r\n  protected retryStates = new Map<string, RetryState>();\r\n\r\n  // Конфигурация по умолчанию для внешних провайдеров\r\n  private static readonly DEFAULT_CONFIG = {\r\n    timeout: 30000,\r\n    maxRetries: 3,\r\n    enableRateLimit: true,\r\n    requestsPerMinute: 60\r\n  };\r\n\r\n  constructor(\r\n    name: string,\r\n    dimensions: number,\r\n    maxBatchSize: number = 16, // Меньший размер батча для API\r\n    maxTextLength: number = 8192 // Больше символов для API\r\n  ) {\r\n    super(name, dimensions, maxBatchSize, maxTextLength);\r\n  }\r\n\r\n  /**\r\n   * Инициализация внешнего провайдера\r\n   */\r\n  public async initialize(config: EmbeddingConfig): Promise<void> {\r\n    // Валидация конфигурации\r\n    const validation = this.validateConfig(config);\r\n    if (!validation.isValid) {\r\n      throw new ProviderError(\r\n        `Configuration validation failed: ${validation.errors.join(', ')}`,\r\n        this.name,\r\n        'CONFIG_VALIDATION_ERROR'\r\n      );\r\n    }\r\n\r\n    // Проверка обязательного API ключа\r\n    if (!config.apiKey) {\r\n      throw new AuthenticationError(\r\n        'API key is required for external providers',\r\n        'invalid_key',\r\n        { provider: this.name }\r\n      );\r\n    }\r\n\r\n    // Настройка конфигурации провайдера\r\n    this.config = {\r\n      ...ExternalProvider.DEFAULT_CONFIG,\r\n      ...config,\r\n      apiKey: config.apiKey,\r\n      baseUrl: (config as any).providerOptions?.baseUrl,\r\n      timeout: (config as any).timeout || ExternalProvider.DEFAULT_CONFIG.timeout,\r\n      maxRetries: (config as any).maxRetries || ExternalProvider.DEFAULT_CONFIG.maxRetries,\r\n      enableRateLimit: (config as any).providerOptions?.enableRateLimit ?? ExternalProvider.DEFAULT_CONFIG.enableRateLimit,\r\n      requestsPerMinute: (config as any).providerOptions?.requestsPerMinute || ExternalProvider.DEFAULT_CONFIG.requestsPerMinute,\r\n      headers: (config as any).providerOptions?.headers || {}\r\n    } as any;\r\n\r\n    // Инициализация rate limiting\r\n    if (this.config?.enableRateLimit) {\r\n      this.initializeRateLimit();\r\n    }\r\n\r\n    // Выполнение специфичной для провайдера инициализации\r\n    await this.initializeProvider(this.config!);\r\n\r\n    // Проверка здоровья после инициализации\r\n    const health = await this.healthCheck();\r\n    if (!health.isHealthy) {\r\n      throw new ProviderError(\r\n        `Provider health check failed: ${health.details}`,\r\n        this.name,\r\n        'HEALTH_CHECK_FAILED'\r\n      );\r\n    }\r\n\r\n    this._isReady = true;\r\n  }\r\n\r\n  /**\r\n   * Генерация одного эмбеддинга с retry логикой\r\n   */\r\n  public async generateEmbedding(text: string): Promise<Float32Array> {\r\n    this.validateText(text);\r\n\r\n    const startTime = Date.now();\r\n    let lastError: Error | null = null;\r\n\r\n    const maxRetries = this.config?.maxRetries || 3;\r\n\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        // Ожидание rate limit если необходимо\r\n        await this.waitForRateLimit();\r\n\r\n        // Выполнение запроса\r\n        const embedding = await this.executeEmbeddingRequest([text]);\r\n\r\n        // Обновление метрик\r\n        const generationTime = Date.now() - startTime;\r\n        this.updateMetrics(generationTime, 1, false);\r\n        this.updateApiMetrics(1, true);\r\n\r\n        return embedding[0];\r\n\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n\r\n        // Проверяем, можно ли повторить запрос\r\n        if (attempt < maxRetries && this.shouldRetry(error as Error)) {\r\n          const delay = this.calculateRetryDelay(attempt, error as Error);\r\n          await this.sleep(delay);\r\n          continue;\r\n        }\r\n\r\n        // Если все попытки исчерпаны или ошибка не подлежит повтору\r\n        this.updateMetrics(Date.now() - startTime, 0, true);\r\n        this.updateApiMetrics(1, false);\r\n        throw this.wrapError(error as Error);\r\n      }\r\n    }\r\n\r\n    // Этот код не должен выполняться, но добавляем для типизации\r\n    throw this.wrapError(lastError || new Error('Unknown error during embedding generation'));\r\n  }\r\n\r\n  /**\r\n   * Пакетная генерация эмбеддингов\r\n   */\r\n  public async generateBatch(texts: string[]): Promise<Float32Array[]> {\r\n    this.validateBatch(texts);\r\n\r\n    const startTime = Date.now();\r\n    let lastError: Error | null = null;\r\n\r\n    const maxRetries = this.config?.maxRetries || 3;\r\n\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        // Ожидание rate limit если необходимо\r\n        await this.waitForRateLimit();\r\n\r\n        // Выполнение запроса\r\n        const embeddings = await this.executeEmbeddingRequest(texts);\r\n\r\n        // Обновление метрик\r\n        const generationTime = Date.now() - startTime;\r\n        this.updateMetrics(generationTime, texts.length, false);\r\n        this.updateApiMetrics(1, true);\r\n\r\n        return embeddings;\r\n\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n\r\n        // Проверяем, можно ли повторить запрос\r\n        if (attempt < maxRetries && this.shouldRetry(error as Error)) {\r\n          const delay = this.calculateRetryDelay(attempt, error as Error);\r\n          await this.sleep(delay);\r\n          continue;\r\n        }\r\n\r\n        // Если все попытки исчерпаны или ошибка не подлежит повтору\r\n        this.updateMetrics(Date.now() - startTime, 0, true);\r\n        this.updateApiMetrics(1, false);\r\n        throw this.wrapError(error as Error);\r\n      }\r\n    }\r\n\r\n    // Этот код не должен выполняться, но добавляем для типизации\r\n    throw this.wrapError(lastError || new Error('Unknown error during batch embedding generation'));\r\n  }\r\n\r\n  /**\r\n   * Проверка здоровья провайдера\r\n   */\r\n  public async healthCheck(): Promise<ProviderHealthStatus> {\r\n    try {\r\n      // Проверяем наличие конфигурации (не проверяем _isReady во время инициализации)\r\n      if (!this.config) {\r\n        return {\r\n          isHealthy: false,\r\n          status: 'error',\r\n          details: 'Provider not initialized',\r\n          connectionStatus: 'disconnected'\r\n        };\r\n      }\r\n\r\n      // Выполняем специфичную для провайдера проверку\r\n      const isHealthy = await this.checkProviderHealth();\r\n\r\n      return {\r\n        isHealthy,\r\n        status: isHealthy ? 'ready' : 'error',\r\n        lastSuccessfulOperation: this.getLastSuccessfulOperation(),\r\n        connectionStatus: isHealthy ? 'connected' : 'disconnected',\r\n        details: isHealthy ? 'Provider is healthy' : 'Provider health check failed'\r\n      };\r\n\r\n    } catch (error) {\r\n      return {\r\n        isHealthy: false,\r\n        status: 'error',\r\n        details: error instanceof Error ? error.message : 'Unknown health check error',\r\n        connectionStatus: 'disconnected'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение метрик с информацией об API\r\n   */\r\n  public getMetrics(): ProviderMetrics {\r\n    const baseMetrics = super.getMetrics();\r\n\r\n    return {\r\n      ...baseMetrics,\r\n      apiRequestCount: this.getApiRequestCount(),\r\n      rateLimitStatus: this.rateLimitInfo ? {\r\n        remaining: this.rateLimitInfo.remaining,\r\n        resetTime: this.rateLimitInfo.resetTime\r\n      } : undefined\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Очистка ресурсов\r\n   */\r\n  public async cleanup(): Promise<void> {\r\n    // Очищаем очередь запросов\r\n    this.requestQueue = [];\r\n    this.isProcessingQueue = false;\r\n\r\n    // Очищаем состояния retry\r\n    this.retryStates.clear();\r\n\r\n    // Сбрасываем готовность\r\n    this._isReady = false;\r\n\r\n    // Выполняем специфичную для провайдера очистку\r\n    await this.cleanupProvider();\r\n  }\r\n\r\n  // Абстрактные методы для реализации в дочерних классах\r\n\r\n  /**\r\n   * Инициализация специфичная для провайдера\r\n   */\r\n  protected abstract initializeProvider(config: ExternalProviderConfig): Promise<void>;\r\n\r\n  /**\r\n   * Выполнение запроса к API для генерации эмбеддингов\r\n   */\r\n  protected abstract executeEmbeddingRequest(texts: string[]): Promise<Float32Array[]>;\r\n\r\n  /**\r\n   * Проверка здоровья специфичная для провайдера\r\n   */\r\n  protected abstract checkProviderHealth(): Promise<boolean>;\r\n\r\n  /**\r\n   * Очистка ресурсов специфичная для провайдера\r\n   */\r\n  protected abstract cleanupProvider(): Promise<void>;\r\n\r\n  // Приватные методы для управления rate limiting и retry логикой\r\n\r\n  /**\r\n   * Инициализация rate limiting\r\n   */\r\n  private initializeRateLimit(): void {\r\n    const requestsPerMinute = this.config?.requestsPerMinute || 60;\r\n    this.rateLimitInfo = {\r\n      remaining: requestsPerMinute,\r\n      resetTime: new Date(Date.now() + 60000), // Сброс через минуту\r\n      limit: requestsPerMinute\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Ожидание rate limit\r\n   */\r\n  private async waitForRateLimit(): Promise<void> {\r\n    if (!this.config?.enableRateLimit || !this.rateLimitInfo) {\r\n      return;\r\n    }\r\n\r\n    // Проверяем, нужно ли сбросить счетчик\r\n    if (Date.now() >= this.rateLimitInfo.resetTime.getTime()) {\r\n      this.rateLimitInfo.remaining = this.rateLimitInfo.limit;\r\n      this.rateLimitInfo.resetTime = new Date(Date.now() + 60000);\r\n    }\r\n\r\n    // Если нет оставшихся запросов, ждем до сброса\r\n    if (this.rateLimitInfo.remaining <= 0) {\r\n      const waitTime = this.rateLimitInfo.resetTime.getTime() - Date.now();\r\n      if (waitTime > 0) {\r\n        await this.sleep(waitTime);\r\n        // После ожидания сбрасываем счетчик\r\n        this.rateLimitInfo.remaining = this.rateLimitInfo.limit;\r\n        this.rateLimitInfo.resetTime = new Date(Date.now() + 60000);\r\n      }\r\n    }\r\n\r\n    // Уменьшаем счетчик оставшихся запросов\r\n    this.rateLimitInfo.remaining--;\r\n  }\r\n\r\n  /**\r\n   * Проверка, можно ли повторить запрос после ошибки\r\n   */\r\n  private shouldRetry(error: Error): boolean {\r\n    // Не повторяем при ошибках аутентификации\r\n    if (error instanceof AuthenticationError) {\r\n      return false;\r\n    }\r\n\r\n    // Не повторяем при ошибках конфигурации\r\n    if (error instanceof EmbeddingError && error.category === 'configuration') {\r\n      return false;\r\n    }\r\n\r\n    // Повторяем при сетевых ошибках\r\n    if (error instanceof NetworkError) {\r\n      return error.recoveryInfo?.canRetry ?? false;\r\n    }\r\n\r\n    // Повторяем при превышении квот (rate limit)\r\n    if (error instanceof QuotaExceededError) {\r\n      return true;\r\n    }\r\n\r\n    // Повторяем при таймаутах\r\n    if (error instanceof TimeoutError) {\r\n      return true;\r\n    }\r\n\r\n    // По умолчанию не повторяем\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Вычисление задержки для retry с exponential backoff\r\n   */\r\n  private calculateRetryDelay(attempt: number, error: Error): number {\r\n    // Базовая задержка\r\n    let baseDelay = 1000;\r\n\r\n    // Увеличиваем задержку для разных типов ошибок\r\n    if (error instanceof QuotaExceededError && error.resetTime) {\r\n      // Для rate limit ждем до сброса\r\n      return Math.max(error.resetTime.getTime() - Date.now(), 0);\r\n    }\r\n\r\n    if (error instanceof NetworkError) {\r\n      baseDelay = error.recoveryInfo?.retryAfter || 2000;\r\n    }\r\n\r\n    if (error instanceof TimeoutError) {\r\n      baseDelay = Math.min(error.timeoutMs * 0.5, 5000);\r\n    }\r\n\r\n    // Exponential backoff: 2^attempt * baseDelay + jitter\r\n    const exponentialDelay = Math.pow(2, attempt - 1) * baseDelay;\r\n    const jitter = Math.random() * 1000; // Добавляем случайность\r\n\r\n    return Math.min(exponentialDelay + jitter, 30000); // Максимум 30 секунд\r\n  }\r\n\r\n  /**\r\n   * Обертывание ошибок в специфичные типы\r\n   */\r\n  private wrapError(error: Error): EmbeddingError {\r\n    if (error instanceof EmbeddingError) {\r\n      return error;\r\n    }\r\n\r\n    // Обработка стандартных HTTP ошибок\r\n    if (error.message.includes('401') || error.message.includes('Unauthorized')) {\r\n      return new AuthenticationError(\r\n        'Invalid API key or unauthorized access',\r\n        'invalid_key',\r\n        { provider: this.name, originalError: error.message }\r\n      );\r\n    }\r\n\r\n    if (error.message.includes('429') || error.message.includes('rate limit')) {\r\n      return new QuotaExceededError(\r\n        'API rate limit exceeded',\r\n        'api_calls',\r\n        0,\r\n        this.rateLimitInfo?.limit || 0,\r\n        this.rateLimitInfo?.resetTime,\r\n        { provider: this.name, originalError: error.message }\r\n      );\r\n    }\r\n\r\n    if (error.message.includes('timeout') || error.name === 'TimeoutError') {\r\n      return new TimeoutError(\r\n        'Request timeout',\r\n        this.config?.timeout || 30000,\r\n        'embedding_generation',\r\n        { provider: this.name, originalError: error.message }\r\n      );\r\n    }\r\n\r\n    // Сетевые ошибки\r\n    if (error.message.includes('fetch') || error.message.includes('network')) {\r\n      return new NetworkError(\r\n        error.message,\r\n        'connection',\r\n        undefined,\r\n        undefined,\r\n        { provider: this.name }\r\n      );\r\n    }\r\n\r\n    // Общая ошибка провайдера\r\n    return new ProviderError(\r\n      error.message,\r\n      this.name,\r\n      'UNKNOWN_PROVIDER_ERROR',\r\n      undefined,\r\n      { originalError: error.message, stack: error.stack }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Обновление метрик API запросов\r\n   */\r\n  private updateApiMetrics(requestCount: number, success: boolean): void {\r\n    if (!this.metrics.apiRequestCount) {\r\n      this.metrics.apiRequestCount = 0;\r\n    }\r\n    this.metrics.apiRequestCount += requestCount;\r\n\r\n    if (success) {\r\n      (this.metrics as any).lastSuccessfulOperation = new Date();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение количества API запросов\r\n   */\r\n  private getApiRequestCount(): number {\r\n    return this.metrics.apiRequestCount || 0;\r\n  }\r\n\r\n  /**\r\n   * Получение времени последней успешной операции\r\n   */\r\n  private getLastSuccessfulOperation(): Date | undefined {\r\n    return (this.metrics as any).lastSuccessfulOperation;\r\n  }\r\n\r\n  /**\r\n   * Утилита для задержки\r\n   */\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n}","/**\r\n * OpenAI провайдер эмбеддингов для LocalRetrieve\r\n *\r\n * Данный модуль реализует провайдер эмбеддингов для OpenAI Embeddings API,\r\n * поддерживающий модель text-embedding-3-small с конфигурируемыми размерностями.\r\n *\r\n * Поддерживаемые возможности:\r\n * - text-embedding-3-small модель\r\n * - Конфигурируемые размерности: 384, 768, 1536\r\n * - Автоматический retry с exponential backoff\r\n * - Rate limiting и quota management\r\n * - Пакетная обработка запросов\r\n * - Secure API key handling (только в памяти)\r\n */\r\n\r\nimport { ExternalProvider, ExternalProviderConfig } from './ExternalProvider.js';\r\nimport type { EmbeddingConfig } from '../types.js';\r\nimport {\r\n  ProviderError,\r\n  NetworkError,\r\n  AuthenticationError,\r\n  QuotaExceededError,\r\n  ValidationError,\r\n  ConfigurationError\r\n} from '../errors.js';\r\n\r\n/**\r\n * Конфигурация OpenAI провайдера\r\n */\r\ninterface OpenAIConfig extends ExternalProviderConfig {\r\n  /** Модель для использования (по умолчанию text-embedding-3-small) */\r\n  model?: string;\r\n\r\n  /** Размерность выходных векторов */\r\n  dimensions: number;\r\n\r\n  /** Организация OpenAI (опционально) */\r\n  organization?: string;\r\n\r\n  /** Пользователь для отслеживания использования */\r\n  user?: string;\r\n}\r\n\r\n/**\r\n * Поддерживаемые модели OpenAI\r\n */\r\nconst OPENAI_MODELS = {\r\n  'text-embedding-3-small': {\r\n    name: 'text-embedding-3-small',\r\n    maxInputTokens: 8191,\r\n    defaultDimensions: 1536,\r\n    supportedDimensions: [384, 768, 1536],\r\n    costPer1MTokens: 0.02 // USD\r\n  },\r\n  'text-embedding-3-large': {\r\n    name: 'text-embedding-3-large',\r\n    maxInputTokens: 8191,\r\n    defaultDimensions: 3072,\r\n    supportedDimensions: [256, 512, 1024, 3072],\r\n    costPer1MTokens: 0.13 // USD\r\n  },\r\n  'text-embedding-ada-002': {\r\n    name: 'text-embedding-ada-002',\r\n    maxInputTokens: 8191,\r\n    defaultDimensions: 1536,\r\n    supportedDimensions: [1536],\r\n    costPer1MTokens: 0.10 // USD\r\n  }\r\n} as const;\r\n\r\n/**\r\n * Структура запроса к OpenAI API\r\n */\r\ninterface OpenAIEmbeddingRequest {\r\n  /** Модель для использования */\r\n  model: string;\r\n\r\n  /** Входной текст или массив текстов */\r\n  input: string | string[];\r\n\r\n  /** Размерность выходных векторов (опционально) */\r\n  dimensions?: number;\r\n\r\n  /** Пользователь для отслеживания */\r\n  user?: string;\r\n\r\n  /** Кодировка (всегда float для нашего случая) */\r\n  encoding_format?: 'float' | 'base64';\r\n}\r\n\r\n/**\r\n * Структура ответа от OpenAI API\r\n */\r\ninterface OpenAIEmbeddingResponse {\r\n  /** Тип объекта */\r\n  object: 'list';\r\n\r\n  /** Данные эмбеддингов */\r\n  data: Array<{\r\n    object: 'embedding';\r\n    index: number;\r\n    embedding: number[];\r\n  }>;\r\n\r\n  /** Модель, которая была использована */\r\n  model: string;\r\n\r\n  /** Информация об использовании токенов */\r\n  usage: {\r\n    prompt_tokens: number;\r\n    total_tokens: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Структура ошибки OpenAI API\r\n */\r\ninterface OpenAIErrorResponse {\r\n  error: {\r\n    message: string;\r\n    type: string;\r\n    param?: string;\r\n    code?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * OpenAI провайдер эмбеддингов\r\n */\r\nexport class OpenAIProvider extends ExternalProvider {\r\n  private openaiConfig?: OpenAIConfig;\r\n  private model: string;\r\n  private supportedDimensions: number[];\r\n  private maxInputTokens: number;\r\n\r\n  /**\r\n   * Создание экземпляра OpenAI провайдера\r\n   *\r\n   * @param dimensions - Размерность векторов эмбеддингов\r\n   * @param model - Модель OpenAI (по умолчанию text-embedding-3-small)\r\n   */\r\n  constructor(\r\n    dimensions: number,\r\n    model: string = 'text-embedding-3-small'\r\n  ) {\r\n    // Валидация модели\r\n    if (!(model in OPENAI_MODELS)) {\r\n      throw new ConfigurationError(\r\n        `Unsupported OpenAI model: ${model}`,\r\n        'model',\r\n        `One of: ${Object.keys(OPENAI_MODELS).join(', ')}`,\r\n        model\r\n      );\r\n    }\r\n\r\n    const modelInfo = OPENAI_MODELS[model as keyof typeof OPENAI_MODELS];\r\n\r\n    // Валидация размерности для выбранной модели\r\n    if (!(modelInfo.supportedDimensions as readonly number[]).includes(dimensions)) {\r\n      throw new ConfigurationError(\r\n        `Unsupported dimensions ${dimensions} for model ${model}`,\r\n        'dimensions',\r\n        `One of: ${modelInfo.supportedDimensions.join(', ')}`,\r\n        dimensions\r\n      );\r\n    }\r\n\r\n    super(\r\n      'openai',\r\n      dimensions,\r\n      100, // OpenAI поддерживает большие батчи\r\n      modelInfo.maxInputTokens * 4 // Приблизительно 4 символа на токен\r\n    );\r\n\r\n    this.model = model;\r\n    this.supportedDimensions = [...modelInfo.supportedDimensions];\r\n    this.maxInputTokens = modelInfo.maxInputTokens;\r\n  }\r\n\r\n  /**\r\n   * Инициализация OpenAI провайдера\r\n   */\r\n  protected async initializeProvider(config: ExternalProviderConfig): Promise<void> {\r\n    // Создание конфигурации OpenAI\r\n    this.openaiConfig = {\r\n      ...config,\r\n      model: this.model,\r\n      dimensions: this.dimensions,\r\n      baseUrl: config.baseUrl || 'https://api.openai.com/v1',\r\n      organization: config.headers?.['OpenAI-Organization'],\r\n      user: config.headers?.['OpenAI-User']\r\n    };\r\n\r\n    // Валидация API ключа\r\n    if (!this.openaiConfig.apiKey.startsWith('sk-')) {\r\n      throw new AuthenticationError(\r\n        'Invalid OpenAI API key format. Must start with \"sk-\"',\r\n        'invalid_key',\r\n        { provider: this.name }\r\n      );\r\n    }\r\n\r\n    // Выполнение тестового запроса для проверки аутентификации\r\n    try {\r\n      await this.executeEmbeddingRequest(['test']);\r\n    } catch (error) {\r\n      // Если это ошибка аутентификации, пробрасываем её\r\n      if (error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      // Для других ошибок продолжаем инициализацию\r\n      console.warn(`OpenAI provider test request failed: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Выполнение запроса к OpenAI API для генерации эмбеддингов\r\n   */\r\n  protected async executeEmbeddingRequest(texts: string[]): Promise<Float32Array[]> {\r\n    if (!this.openaiConfig) {\r\n      throw new ProviderError(\r\n        'Provider not initialized',\r\n        this.name,\r\n        'PROVIDER_NOT_INITIALIZED'\r\n      );\r\n    }\r\n\r\n    // Подготовка запроса\r\n    const requestBody: OpenAIEmbeddingRequest = {\r\n      model: this.openaiConfig.model || this.model,\r\n      input: texts,\r\n      encoding_format: 'float'\r\n    };\r\n\r\n    // Добавляем размерность только если она отличается от дефолтной\r\n    const modelInfo = OPENAI_MODELS[this.model as keyof typeof OPENAI_MODELS];\r\n    if (this.dimensions !== modelInfo.defaultDimensions) {\r\n      requestBody.dimensions = this.dimensions;\r\n    }\r\n\r\n    // Добавляем пользователя если указан\r\n    if (this.openaiConfig.user) {\r\n      requestBody.user = this.openaiConfig.user;\r\n    }\r\n\r\n    // Подготовка заголовков\r\n    const headers: Record<string, string> = {\r\n      'Content-Type': 'application/json',\r\n      'Authorization': `Bearer ${this.openaiConfig.apiKey}`,\r\n      'User-Agent': 'LocalRetrieve/1.0.0'\r\n    };\r\n\r\n    // Добавляем организацию если указана\r\n    if (this.openaiConfig.organization) {\r\n      headers['OpenAI-Organization'] = this.openaiConfig.organization;\r\n    }\r\n\r\n    // Дополнительные заголовки\r\n    if (this.openaiConfig.headers) {\r\n      Object.assign(headers, this.openaiConfig.headers);\r\n    }\r\n\r\n    const url = `${this.openaiConfig.baseUrl}/embeddings`;\r\n\r\n    try {\r\n      // Создание контроллера для отмены запроса по таймауту\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => {\r\n        controller.abort();\r\n      }, this.openaiConfig.timeout);\r\n\r\n      // Выполнение запроса\r\n      const response = await fetch(url, {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(requestBody),\r\n        signal: controller.signal\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      // Обработка ответа\r\n      const responseData = await response.json();\r\n\r\n      if (!response.ok) {\r\n        throw this.createErrorFromResponse(response.status, responseData as OpenAIErrorResponse);\r\n      }\r\n\r\n      // Обработка успешного ответа\r\n      return this.processSuccessfulResponse(responseData as OpenAIEmbeddingResponse);\r\n\r\n    } catch (error: unknown) {\r\n      // Обработка ошибок запроса\r\n      if (error instanceof Error && error.name === 'AbortError') {\r\n        throw new NetworkError(\r\n          `Request timeout after ${this.openaiConfig.timeout}ms`,\r\n          'timeout',\r\n          undefined,\r\n          url\r\n        );\r\n      }\r\n\r\n      if (error instanceof TypeError && error.message.includes('fetch')) {\r\n        throw new NetworkError(\r\n          'Network connection failed',\r\n          'connection',\r\n          undefined,\r\n          url\r\n        );\r\n      }\r\n\r\n      // Пробрасываем уже обработанные ошибки\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка здоровья OpenAI провайдера\r\n   */\r\n  protected async checkProviderHealth(): Promise<boolean> {\r\n    try {\r\n      // Выполняем минимальный запрос для проверки доступности API\r\n      await this.executeEmbeddingRequest(['health check']);\r\n      return true;\r\n    } catch (error) {\r\n      console.warn(`OpenAI provider health check failed: ${error}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Очистка ресурсов OpenAI провайдера\r\n   */\r\n  protected async cleanupProvider(): Promise<void> {\r\n    // Очищаем конфигурацию (включая API ключ)\r\n    this.openaiConfig = undefined;\r\n  }\r\n\r\n  /**\r\n   * Получение информации о поддерживаемых моделях\r\n   */\r\n  public static getAvailableModels() {\r\n    return Object.entries(OPENAI_MODELS).map(([id, info]) => ({\r\n      id,\r\n      name: info.name,\r\n      description: `OpenAI ${info.name} embedding model`,\r\n      dimensions: info.defaultDimensions,\r\n      supportedDimensions: info.supportedDimensions,\r\n      maxInputLength: info.maxInputTokens,\r\n      languages: ['en', 'es', 'fr', 'de', 'it', 'pt', 'ru', 'ja', 'ko', 'zh'],\r\n      useCases: ['semantic search', 'classification', 'clustering', 'similarity'],\r\n      costPerToken: info.costPer1MTokens / 1000000\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Создание специфичной ошибки на основе ответа API\r\n   */\r\n  private createErrorFromResponse(status: number, errorData: OpenAIErrorResponse): Error {\r\n    const errorMessage = errorData.error?.message || 'Unknown OpenAI API error';\r\n    const errorType = errorData.error?.type || 'unknown';\r\n    const errorCode = errorData.error?.code || 'unknown';\r\n\r\n    switch (status) {\r\n      case 401:\r\n        return new AuthenticationError(\r\n          `OpenAI API authentication failed: ${errorMessage}`,\r\n          'invalid_key',\r\n          { provider: this.name, errorType, errorCode }\r\n        );\r\n\r\n      case 429:\r\n        // Определяем тип превышения лимита\r\n        if (errorMessage.includes('quota') || errorMessage.includes('billing')) {\r\n          return new QuotaExceededError(\r\n            `OpenAI API quota exceeded: ${errorMessage}`,\r\n            'api_calls',\r\n            0,\r\n            0,\r\n            undefined,\r\n            { provider: this.name, errorType, errorCode }\r\n          );\r\n        } else {\r\n          return new QuotaExceededError(\r\n            `OpenAI API rate limit exceeded: ${errorMessage}`,\r\n            'api_calls',\r\n            0,\r\n            0,\r\n            new Date(Date.now() + 60000), // Retry after 1 minute\r\n            { provider: this.name, errorType, errorCode }\r\n          );\r\n        }\r\n\r\n      case 400:\r\n        if (errorMessage.includes('dimensions') || errorMessage.includes('model')) {\r\n          return new ConfigurationError(\r\n            `OpenAI API configuration error: ${errorMessage}`,\r\n            errorData.error?.param || 'unknown',\r\n            undefined,\r\n            undefined,\r\n            { provider: this.name, errorType, errorCode }\r\n          );\r\n        } else {\r\n          return new ValidationError(\r\n            `OpenAI API validation error: ${errorMessage}`,\r\n            errorData.error?.param || 'input',\r\n            'OpenAI API validation',\r\n            { provider: this.name, errorType, errorCode }\r\n          );\r\n        }\r\n\r\n      case 500:\r\n      case 502:\r\n      case 503:\r\n      case 504:\r\n        return new NetworkError(\r\n          `OpenAI API server error: ${errorMessage}`,\r\n          'server_error',\r\n          status,\r\n          undefined,\r\n          { provider: this.name, errorType, errorCode }\r\n        );\r\n\r\n      default:\r\n        return new ProviderError(\r\n          `OpenAI API error (${status}): ${errorMessage}`,\r\n          this.name,\r\n          'OPENAI_API_ERROR',\r\n          undefined,\r\n          { status, errorType, errorCode }\r\n        );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обработка успешного ответа от OpenAI API\r\n   */\r\n  private processSuccessfulResponse(response: OpenAIEmbeddingResponse): Float32Array[] {\r\n    if (!response.data || !Array.isArray(response.data)) {\r\n      throw new ProviderError(\r\n        'Invalid response format from OpenAI API',\r\n        this.name,\r\n        'INVALID_RESPONSE_FORMAT'\r\n      );\r\n    }\r\n\r\n    // Сортируем по индексу для сохранения порядка\r\n    const sortedData = response.data.sort((a, b) => a.index - b.index);\r\n\r\n    return sortedData.map((item, index) => {\r\n      if (!item.embedding || !Array.isArray(item.embedding)) {\r\n        throw new ProviderError(\r\n          `Invalid embedding format at index ${index}`,\r\n          this.name,\r\n          'INVALID_EMBEDDING_FORMAT'\r\n        );\r\n      }\r\n\r\n      // Проверяем размерность\r\n      if (item.embedding.length !== this.dimensions) {\r\n        throw new ProviderError(\r\n          `Embedding dimension mismatch: expected ${this.dimensions}, got ${item.embedding.length}`,\r\n          this.name,\r\n          'DIMENSION_MISMATCH'\r\n        );\r\n      }\r\n\r\n      // Конвертируем в Float32Array\r\n      return new Float32Array(item.embedding);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации для OpenAI провайдера\r\n   */\r\n  public validateConfig(config: EmbeddingConfig) {\r\n    const baseValidation = super.validateConfig(config);\r\n\r\n    // Дополнительная валидация для OpenAI\r\n    const errors = [...baseValidation.errors];\r\n    const warnings = [...baseValidation.warnings];\r\n    const suggestions = [...baseValidation.suggestions];\r\n\r\n    // Проверка API ключа\r\n    if (!config.apiKey) {\r\n      errors.push('OpenAI API key is required');\r\n      suggestions.push('Set apiKey in configuration');\r\n    } else if (!config.apiKey.startsWith('sk-')) {\r\n      warnings.push('OpenAI API key should start with \"sk-\"');\r\n      suggestions.push('Verify API key format');\r\n    }\r\n\r\n    // Проверка модели и размерности\r\n    const modelName = (config as any).providerOptions?.model || this.model;\r\n    if (modelName in OPENAI_MODELS) {\r\n      const modelInfo = OPENAI_MODELS[modelName as keyof typeof OPENAI_MODELS];\r\n      if (!(modelInfo.supportedDimensions as readonly number[]).includes(this.dimensions)) {\r\n        errors.push(`Model ${modelName} does not support ${this.dimensions} dimensions`);\r\n        suggestions.push(`Use one of: ${modelInfo.supportedDimensions.join(', ')}`);\r\n      }\r\n    }\r\n\r\n    // Проверка размера батча\r\n    if (config.batchSize && config.batchSize > this.maxBatchSize) {\r\n      warnings.push(`Batch size ${config.batchSize} may be inefficient for OpenAI API`);\r\n      suggestions.push(`Consider using batch size of ${Math.min(this.maxBatchSize, 50)} or less`);\r\n    }\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n      suggestions\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Фабричная функция для создания OpenAI провайдера\r\n */\r\nexport function createOpenAIProvider(\r\n  dimensions: number,\r\n  model: string = 'text-embedding-3-small'\r\n): OpenAIProvider {\r\n  return new OpenAIProvider(dimensions, model);\r\n}\r\n\r\n/**\r\n * Проверка поддерживается ли комбинация модели и размерности\r\n */\r\nexport function isValidModelDimensionCombo(model: string, dimensions: number): boolean {\r\n  if (!(model in OPENAI_MODELS)) {\r\n    return false;\r\n  }\r\n\r\n  const modelInfo = OPENAI_MODELS[model as keyof typeof OPENAI_MODELS];\r\n  return (modelInfo.supportedDimensions as readonly number[]).includes(dimensions);\r\n}\r\n\r\n/**\r\n * Получение рекомендуемой конфигурации для заданных требований\r\n */\r\nexport function getRecommendedConfig(\r\n  requirements: {\r\n    dimensions?: number;\r\n    budget?: 'low' | 'medium' | 'high';\r\n    performance?: 'fast' | 'balanced' | 'accurate';\r\n  }\r\n): {\r\n  model: string;\r\n  dimensions: number;\r\n  description: string;\r\n} {\r\n  const { dimensions = 384, budget = 'medium', performance = 'balanced' } = requirements;\r\n\r\n  // Рекомендации на основе бюджета и производительности\r\n  if (budget === 'low' || performance === 'fast') {\r\n    return {\r\n      model: 'text-embedding-3-small',\r\n      dimensions: Math.min(dimensions, 384),\r\n      description: 'Cost-effective option with good performance for most use cases'\r\n    };\r\n  }\r\n\r\n  if (budget === 'high' || performance === 'accurate') {\r\n    if (dimensions <= 1024) {\r\n      return {\r\n        model: 'text-embedding-3-large',\r\n        dimensions: dimensions <= 256 ? 256 : dimensions <= 512 ? 512 : 1024,\r\n        description: 'High-accuracy model for demanding applications'\r\n      };\r\n    }\r\n  }\r\n\r\n  // Сбалансированный выбор\r\n  return {\r\n    model: 'text-embedding-3-small',\r\n    dimensions: dimensions <= 384 ? 384 : dimensions <= 768 ? 768 : 1536,\r\n    description: 'Balanced option providing good accuracy and reasonable cost'\r\n  };\r\n}","/**\r\n * Провайдер эмбеддингов на основе Transformers.js\r\n *\r\n * Реализует локальную генерацию эмбеддингов с использованием модели all-MiniLM-L6-v2\r\n * через Web Worker для неблокирующей производительности.\r\n *\r\n * Ключевые особенности:\r\n * - Фиксированная размерность 384 для модели all-MiniLM-L6-v2\r\n * - Ленивая загрузка модели (только при первом запросе)\r\n * - Работа в Web Worker для изоляции\r\n * - Базовая оптимизация производительности\r\n * - Управление памятью и очистка ресурсов\r\n */\r\n\r\nimport type { EmbeddingConfig } from '../types.js';\r\nimport { BaseEmbeddingProvider, type ProviderHealthStatus, type ProviderMetrics } from './BaseProvider.js';\r\nimport { ProviderError, ProviderInitializationError, ModelLoadError, TimeoutError, WorkerError } from '../errors.js';\r\n\r\n/**\r\n * Конфигурация для Transformers.js провайдера\r\n */\r\nexport interface TransformersProviderConfig extends EmbeddingConfig {\r\n  /** Путь к скрипту воркера */\r\n  workerScript?: string;\r\n\r\n  /** Максимальное время загрузки модели в миллисекундах */\r\n  modelLoadTimeout?: number;\r\n\r\n  /** Максимальное время ожидания операции в миллисекундах */\r\n  operationTimeout?: number;\r\n\r\n  /** Путь к модели (по умолчанию 'Xenova/all-MiniLM-L6-v2') */\r\n  modelPath?: string;\r\n\r\n  /** Кэширование модели в localStorage */\r\n  enableModelCache?: boolean;\r\n\r\n  /** Включить ли детальное логирование */\r\n  enableLogging?: boolean;\r\n}\r\n\r\n/**\r\n * Сообщения для взаимодействия с Web Worker\r\n */\r\ninterface WorkerMessage {\r\n  id: string;\r\n  type: 'initialize' | 'generateEmbedding' | 'generateBatch' | 'cleanup' | 'healthCheck';\r\n  data?: any;\r\n}\r\n\r\ninterface WorkerResponse {\r\n  id: string;\r\n  success: boolean;\r\n  data?: any;\r\n  error?: string;\r\n  metadata?: {\r\n    generationTime: number;\r\n    modelSize?: number;\r\n    memoryUsage?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Провайдер эмбеддингов на основе Transformers.js\r\n *\r\n * Использует модель all-MiniLM-L6-v2 для генерации 384-мерных эмбеддингов.\r\n * Все операции выполняются в Web Worker для неблокирующей производительности.\r\n */\r\nexport class TransformersProvider extends BaseEmbeddingProvider {\r\n  /** Экземпляр Web Worker */\r\n  private worker?: Worker;\r\n\r\n  /** Конфигурация провайдера */\r\n  protected config: TransformersProviderConfig;\r\n\r\n  /** Очередь ожидающих запросов */\r\n  private pendingRequests = new Map<string, {\r\n    resolve: (value: any) => void;\r\n    reject: (error: Error) => void;\r\n    timestamp: number;\r\n    timeout?: NodeJS.Timeout;\r\n  }>();\r\n\r\n  /** Счетчик для уникальных идентификаторов сообщений */\r\n  private messageCounter = 0;\r\n\r\n  /** Статус инициализации */\r\n  private initializationPromise?: Promise<void>;\r\n\r\n  /** Метрики производительности */\r\n  private performanceMetrics = {\r\n    modelLoadTime: 0,\r\n    averageBatchSize: 0,\r\n    totalBatches: 0,\r\n    memoryPeak: 0,\r\n    lastCleanup: new Date()\r\n  };\r\n\r\n  constructor(config: TransformersProviderConfig = {\r\n    defaultProvider: 'transformers',\r\n    defaultDimensions: 384\r\n  }) {\r\n    super(\r\n      'transformers',\r\n      384, // Фиксированная размерность для all-MiniLM-L6-v2\r\n      config.batchSize || 16, // Оптимальный размер батча для локальной модели\r\n      512 // Максимальная длина текста в токенах\r\n    );\r\n\r\n    this.config = {\r\n      workerScript: '/src/embedding/workers/transformers-worker.js',\r\n      modelLoadTimeout: 30000, // 30 секунд на загрузку модели\r\n      operationTimeout: 10000,  // 10 секунд на операцию\r\n      batchSize: 16,\r\n      enableLogging: false,\r\n      modelPath: 'Xenova/all-MiniLM-L6-v2',\r\n      enableModelCache: true,\r\n      ...config\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Инициализация провайдера и загрузка модели\r\n   */\r\n  public async initialize(config: EmbeddingConfig): Promise<void> {\r\n    if (this.initializationPromise) {\r\n      return this.initializationPromise;\r\n    }\r\n\r\n    this.initializationPromise = this._initialize(config);\r\n    return this.initializationPromise;\r\n  }\r\n\r\n  private async _initialize(config: EmbeddingConfig): Promise<void> {\r\n    try {\r\n      this.config = { ...this.config, ...config };\r\n\r\n      // Проверяем поддержку Web Workers\r\n      if (!window.Worker) {\r\n        throw new ProviderInitializationError(\r\n          'Web Workers не поддерживаются в данном браузере',\r\n          this.name,\r\n          undefined,\r\n          { userAgent: navigator.userAgent }\r\n        );\r\n      }\r\n\r\n      // Создаем Web Worker\r\n      await this.createWorker();\r\n\r\n      // Инициализируем модель в воркере\r\n      const startTime = Date.now();\r\n      await this.sendMessage('initialize', {\r\n        modelPath: this.config.modelPath,\r\n        enableCache: this.config.enableModelCache,\r\n        enableLogging: this.config.enableLogging\r\n      }, this.config.modelLoadTimeout);\r\n\r\n      this.performanceMetrics.modelLoadTime = Date.now() - startTime;\r\n      this._isReady = true;\r\n\r\n      if (this.config.enableLogging) {\r\n        console.log(`[TransformersProvider] Модель загружена за ${this.performanceMetrics.modelLoadTime}ms`);\r\n      }\r\n\r\n    } catch (error) {\r\n      this._isReady = false;\r\n\r\n      if (error instanceof Error) {\r\n        throw new ProviderInitializationError(\r\n          `Ошибка инициализации Transformers.js провайдера: ${error.message}`,\r\n          this.name,\r\n          error,\r\n          { config: this.config }\r\n        );\r\n      }\r\n\r\n      throw new ProviderInitializationError(\r\n        'Неизвестная ошибка при инициализации провайдера',\r\n        this.name,\r\n        undefined,\r\n        { config: this.config }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Создание и настройка Web Worker\r\n   */\r\n  private async createWorker(): Promise<void> {\r\n    try {\r\n      // Для разработки используем полный путь, для продакшна - относительный\r\n      const workerUrl = this.config.workerScript?.startsWith('/')\r\n        ? this.config.workerScript\r\n        : `/src/embedding/workers/transformers-worker.js`;\r\n\r\n      this.worker = new Worker(workerUrl, {\r\n        type: 'module',\r\n        name: 'TransformersEmbeddingWorker'\r\n      });\r\n\r\n      // Настраиваем обработчик сообщений\r\n      this.worker.onmessage = (event: MessageEvent<WorkerResponse>) => {\r\n        this.handleWorkerMessage(event.data);\r\n      };\r\n\r\n      // Обработчик ошибок воркера\r\n      this.worker.onerror = (error) => {\r\n        console.error('[TransformersProvider] Worker error:', error);\r\n        this.handleWorkerError(new Error(`Worker error: ${error.message}`));\r\n      };\r\n\r\n      // Обработчик неожиданного завершения воркера\r\n      this.worker.onmessageerror = (error) => {\r\n        console.error('[TransformersProvider] Worker message error:', error);\r\n        this.handleWorkerError(new Error('Worker message parsing error'));\r\n      };\r\n\r\n    } catch (error) {\r\n      throw new WorkerError(\r\n        `Не удалось создать Web Worker: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        'create',\r\n        undefined,\r\n        { workerScript: this.config.workerScript }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Генерация эмбеддинга для одного текста\r\n   */\r\n  public async generateEmbedding(text: string): Promise<Float32Array> {\r\n    this.validateText(text);\r\n\r\n    if (!this._isReady) {\r\n      throw new ProviderError(\r\n        'Провайдер не инициализирован. Вызовите initialize() перед использованием.',\r\n        this.name,\r\n        'NOT_INITIALIZED'\r\n      );\r\n    }\r\n\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const response = await this.sendMessage('generateEmbedding', {\r\n        text: text.trim()\r\n      }, this.config.operationTimeout);\r\n\r\n      const generationTime = Date.now() - startTime;\r\n      this.updateMetrics(generationTime, 1, false);\r\n\r\n      // Убеждаемся, что получили Float32Array правильной размерности\r\n      const embedding = new Float32Array(response.embedding);\r\n      if (embedding.length !== this.dimensions) {\r\n        throw new ProviderError(\r\n          `Неверная размерность эмбеддинга: получено ${embedding.length}, ожидалось ${this.dimensions}`,\r\n          this.name,\r\n          'INVALID_DIMENSIONS'\r\n        );\r\n      }\r\n\r\n      return embedding;\r\n\r\n    } catch (error) {\r\n      const generationTime = Date.now() - startTime;\r\n      this.updateMetrics(generationTime, 1, true);\r\n\r\n      if (error instanceof Error) {\r\n        throw error;\r\n      }\r\n\r\n      throw new ProviderError(\r\n        `Ошибка генерации эмбеддинга: ${error}`,\r\n        this.name,\r\n        'GENERATION_ERROR',\r\n        undefined,\r\n        { text: text.substring(0, 100) + '...' }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Пакетная генерация эмбеддингов\r\n   */\r\n  public async generateBatch(texts: string[]): Promise<Float32Array[]> {\r\n    this.validateBatch(texts);\r\n\r\n    if (!this._isReady) {\r\n      throw new ProviderError(\r\n        'Провайдер не инициализирован. Вызовите initialize() перед использованием.',\r\n        this.name,\r\n        'NOT_INITIALIZED'\r\n      );\r\n    }\r\n\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Для больших батчей разбиваем на части\r\n      const results: Float32Array[] = [];\r\n      const chunkSize = this.maxBatchSize;\r\n\r\n      for (let i = 0; i < texts.length; i += chunkSize) {\r\n        const chunk = texts.slice(i, i + chunkSize);\r\n        const chunkResults = await this.processBatchChunk(chunk);\r\n        results.push(...chunkResults);\r\n      }\r\n\r\n      const generationTime = Date.now() - startTime;\r\n      this.updateMetrics(generationTime, texts.length, false);\r\n\r\n      // Обновляем метрики батчевой обработки\r\n      this.performanceMetrics.totalBatches += 1;\r\n      this.performanceMetrics.averageBatchSize =\r\n        (this.performanceMetrics.averageBatchSize * (this.performanceMetrics.totalBatches - 1) + texts.length)\r\n        / this.performanceMetrics.totalBatches;\r\n\r\n      return results;\r\n\r\n    } catch (error) {\r\n      const generationTime = Date.now() - startTime;\r\n      this.updateMetrics(generationTime, texts.length, true);\r\n\r\n      if (error instanceof Error) {\r\n        throw error;\r\n      }\r\n\r\n      throw new ProviderError(\r\n        `Ошибка пакетной генерации эмбеддингов: ${error}`,\r\n        this.name,\r\n        'BATCH_GENERATION_ERROR',\r\n        undefined,\r\n        { batchSize: texts.length }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обработка части батча\r\n   */\r\n  private async processBatchChunk(texts: string[]): Promise<Float32Array[]> {\r\n    const response = await this.sendMessage('generateBatch', {\r\n      texts: texts.map(t => t.trim())\r\n    }, this.config.operationTimeout! * Math.ceil(texts.length / 4)); // Увеличиваем таймаут для батчей\r\n\r\n    return response.embeddings.map((embData: number[] | Float32Array) => {\r\n      const embedding = new Float32Array(embData);\r\n      if (embedding.length !== this.dimensions) {\r\n        throw new ProviderError(\r\n          `Неверная размерность эмбеддинга: получено ${embedding.length}, ожидалось ${this.dimensions}`,\r\n          this.name,\r\n          'INVALID_DIMENSIONS'\r\n        );\r\n      }\r\n      return embedding;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Очистка ресурсов и завершение работы провайдера\r\n   */\r\n  public async cleanup(): Promise<void> {\r\n    try {\r\n      // Отменяем все ожидающие запросы\r\n      for (const [id, request] of this.pendingRequests) {\r\n        if (request.timeout) {\r\n          clearTimeout(request.timeout);\r\n        }\r\n        request.reject(new Error('Provider cleanup - request cancelled'));\r\n      }\r\n      this.pendingRequests.clear();\r\n\r\n      // Очищаем ресурсы в воркере\r\n      if (this.worker && this._isReady) {\r\n        try {\r\n          await this.sendMessage('cleanup', {}, 5000);\r\n        } catch (error) {\r\n          // Игнорируем ошибки при очистке, продолжаем завершение\r\n          console.warn('[TransformersProvider] Cleanup warning:', error);\r\n        }\r\n      }\r\n\r\n      // Завершаем воркер\r\n      if (this.worker) {\r\n        this.worker.terminate();\r\n        this.worker = undefined;\r\n      }\r\n\r\n      this._isReady = false;\r\n      this.initializationPromise = undefined;\r\n      this.performanceMetrics.lastCleanup = new Date();\r\n\r\n      if (this.config.enableLogging) {\r\n        console.log('[TransformersProvider] Провайдер очищен');\r\n      }\r\n\r\n    } catch (error) {\r\n      throw new ProviderError(\r\n        `Ошибка при очистке провайдера: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        this.name,\r\n        'CLEANUP_ERROR'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка здоровья провайдера\r\n   */\r\n  public async healthCheck(): Promise<ProviderHealthStatus> {\r\n    try {\r\n      if (!this.worker || !this._isReady) {\r\n        return {\r\n          isHealthy: false,\r\n          status: 'error',\r\n          details: 'Провайдер не инициализирован или воркер недоступен',\r\n          connectionStatus: 'disconnected'\r\n        };\r\n      }\r\n\r\n      // Проверяем отзывчивость воркера\r\n      const startTime = Date.now();\r\n      const response = await this.sendMessage('healthCheck', {}, 5000);\r\n      const responseTime = Date.now() - startTime;\r\n\r\n      return {\r\n        isHealthy: true,\r\n        lastSuccessfulOperation: new Date(),\r\n        status: 'ready',\r\n        details: `Воркер отвечает за ${responseTime}ms`,\r\n        availableMemory: response.memoryInfo?.availableMemory,\r\n        connectionStatus: 'connected'\r\n      };\r\n\r\n    } catch (error) {\r\n      return {\r\n        isHealthy: false,\r\n        status: 'degraded',\r\n        details: `Ошибка проверки здоровья: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        connectionStatus: 'limited'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение расширенных метрик производительности\r\n   */\r\n  public getMetrics(): ProviderMetrics {\r\n    const baseMetrics = super.getMetrics();\r\n\r\n    return {\r\n      ...baseMetrics,\r\n      memoryUsage: this.performanceMetrics.memoryPeak,\r\n      apiRequestCount: undefined, // Не применимо для локального провайдера\r\n      rateLimitStatus: undefined  // Не применимо для локального провайдера\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Получение специфичных для Transformers.js метрик\r\n   */\r\n  public getTransformersMetrics() {\r\n    return {\r\n      ...this.performanceMetrics,\r\n      isModelLoaded: this._isReady,\r\n      workerActive: !!this.worker,\r\n      pendingRequests: this.pendingRequests.size\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Отправка сообщения воркеру с обработкой таймаутов\r\n   */\r\n  private async sendMessage(type: WorkerMessage['type'], data: any, timeoutMs?: number): Promise<any> {\r\n    if (!this.worker) {\r\n      throw new WorkerError('Web Worker не создан', type);\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const id = `${type}_${++this.messageCounter}_${Date.now()}`;\r\n      const timeout = timeoutMs || this.config.operationTimeout || 10000;\r\n\r\n      // Настраиваем таймаут\r\n      const timeoutHandle = setTimeout(() => {\r\n        this.pendingRequests.delete(id);\r\n        reject(new TimeoutError(\r\n          `Операция ${type} превысила таймаут ${timeout}ms`,\r\n          timeout,\r\n          type\r\n        ));\r\n      }, timeout);\r\n\r\n      // Сохраняем запрос\r\n      this.pendingRequests.set(id, {\r\n        resolve,\r\n        reject,\r\n        timestamp: Date.now(),\r\n        timeout: timeoutHandle\r\n      });\r\n\r\n      // Отправляем сообщение\r\n      const message: WorkerMessage = { id, type, data };\r\n      this.worker!.postMessage(message);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Обработка сообщений от воркера\r\n   */\r\n  private handleWorkerMessage(response: WorkerResponse): void {\r\n    const request = this.pendingRequests.get(response.id);\r\n    if (!request) {\r\n      console.warn(`[TransformersProvider] Получен ответ для неизвестного запроса: ${response.id}`);\r\n      return;\r\n    }\r\n\r\n    // Очищаем таймаут и удаляем запрос\r\n    if (request.timeout) {\r\n      clearTimeout(request.timeout);\r\n    }\r\n    this.pendingRequests.delete(response.id);\r\n\r\n    // Обновляем метрики памяти\r\n    if (response.metadata?.memoryUsage) {\r\n      this.performanceMetrics.memoryPeak = Math.max(\r\n        this.performanceMetrics.memoryPeak,\r\n        response.metadata.memoryUsage\r\n      );\r\n    }\r\n\r\n    // Обрабатываем ответ\r\n    if (response.success) {\r\n      request.resolve(response.data);\r\n    } else {\r\n      const error = new ProviderError(\r\n        response.error || 'Неизвестная ошибка воркера',\r\n        this.name,\r\n        'WORKER_ERROR'\r\n      );\r\n      request.reject(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обработка ошибок воркера\r\n   */\r\n  private handleWorkerError(error: Error): void {\r\n    // Отклоняем все ожидающие запросы\r\n    for (const [id, request] of this.pendingRequests) {\r\n      if (request.timeout) {\r\n        clearTimeout(request.timeout);\r\n      }\r\n      request.reject(new WorkerError(\r\n        `Worker error: ${error.message}`,\r\n        'worker_error',\r\n        undefined,\r\n        { originalError: error.message }\r\n      ));\r\n    }\r\n    this.pendingRequests.clear();\r\n\r\n    this._isReady = false;\r\n  }\r\n}\r\n\r\n/**\r\n * Фабричная функция для создания TransformersProvider\r\n */\r\nexport function createTransformersProvider(config?: TransformersProviderConfig): TransformersProvider {\r\n  return new TransformersProvider(config);\r\n}\r\n\r\n/**\r\n * Проверка поддержки Transformers.js в текущей среде\r\n */\r\nexport function isTransformersSupported(): boolean {\r\n  return (\r\n    typeof window !== 'undefined' &&\r\n    typeof Worker !== 'undefined' &&\r\n    typeof SharedArrayBuffer !== 'undefined' &&\r\n    typeof WebAssembly !== 'undefined'\r\n  );\r\n}\r\n\r\n/**\r\n * Получение информации о модели all-MiniLM-L6-v2\r\n */\r\nexport function getModelInfo() {\r\n  return {\r\n    id: 'Xenova/all-MiniLM-L6-v2',\r\n    name: 'all-MiniLM-L6-v2',\r\n    description: 'Sentence-BERT model for generating 384-dimensional embeddings',\r\n    dimensions: 384,\r\n    maxInputLength: 512,\r\n    languages: ['en', 'multilingual'],\r\n    useCases: ['sentence similarity', 'semantic search', 'clustering'],\r\n    modelSize: 23_000_000, // ~23MB\r\n    provider: 'transformers'\r\n  };\r\n}","/**\r\n * Фабрика провайдеров эмбеддингов для LocalRetrieve\r\n *\r\n * Данный модуль реализует фабрику для создания экземпляров провайдеров эмбеддингов\r\n * на основе конфигурации коллекции. Поддерживает локальные и внешние провайдеры\r\n * с валидацией конфигурации и управлением моделями.\r\n *\r\n * Поддерживаемые провайдеры:\r\n * - Transformers.js: Локальные модели с фиксированной размерностью 384\r\n * - OpenAI: API модели с конфигурируемыми размерностями (384, 768, 1536)\r\n *\r\n * Основные функции:\r\n * - Создание провайдеров на основе конфигурации коллекции\r\n * - Валидация параметров провайдера\r\n * - Получение информации о доступных моделях\r\n * - Рекомендации по конфигурации\r\n */\r\n\r\nimport type {\r\n  EmbeddingProvider,\r\n  EmbeddingProviderFactory,\r\n  ModelInfo,\r\n  ProviderConfigValidation\r\n} from './providers/BaseProvider.js';\r\nimport type { CollectionEmbeddingConfig, EmbeddingProviderType } from './types.js';\r\nimport { TransformersProvider, getModelInfo as getTransformersModelInfo, isTransformersSupported } from './providers/TransformersProvider.js';\r\nimport { OpenAIProvider, getRecommendedConfig, isValidModelDimensionCombo } from './providers/OpenAIProvider.js';\r\nimport {\r\n  ProviderError,\r\n  ConfigurationError,\r\n  ProviderInitializationError,\r\n  ValidationError\r\n} from './errors.js';\r\n\r\n/**\r\n * Результат проверки поддержки провайдера\r\n */\r\nexport interface ProviderSupportInfo {\r\n  /** Поддерживается ли провайдер в текущей среде */\r\n  isSupported: boolean;\r\n\r\n  /** Причина отсутствия поддержки */\r\n  unsupportedReason?: string;\r\n\r\n  /** Рекомендуемые альтернативы */\r\n  alternatives?: EmbeddingProviderType[];\r\n\r\n  /** Требования для поддержки */\r\n  requirements?: string[];\r\n}\r\n\r\n/**\r\n * Информация о конфигурации провайдера\r\n */\r\nexport interface ProviderConfigInfo {\r\n  /** Тип провайдера */\r\n  type: EmbeddingProviderType;\r\n\r\n  /** Название для отображения */\r\n  displayName: string;\r\n\r\n  /** Описание провайдера */\r\n  description: string;\r\n\r\n  /** Поддерживаемые размерности */\r\n  supportedDimensions: number[];\r\n\r\n  /** Размерность по умолчанию */\r\n  defaultDimensions: number;\r\n\r\n  /** Требуется ли API ключ */\r\n  requiresApiKey: boolean;\r\n\r\n  /** Работает ли провайдер локально */\r\n  isLocal: boolean;\r\n\r\n  /** Доступные модели */\r\n  availableModels: ModelInfo[];\r\n\r\n  /** Рекомендуемые случаи использования */\r\n  recommendedUseCases: string[];\r\n\r\n  /** Требования к окружению */\r\n  environmentRequirements: string[];\r\n}\r\n\r\n/**\r\n * Рекомендации по выбору провайдера\r\n */\r\nexport interface ProviderRecommendation {\r\n  /** Рекомендуемый тип провайдера */\r\n  provider: EmbeddingProviderType;\r\n\r\n  /** Рекомендуемая модель */\r\n  model?: string;\r\n\r\n  /** Рекомендуемая размерность */\r\n  dimensions: number;\r\n\r\n  /** Причина рекомендации */\r\n  reason: string;\r\n\r\n  /** Приоритет рекомендации (1-10, 10 - наивысший) */\r\n  priority: number;\r\n\r\n  /** Альтернативные варианты */\r\n  alternatives: Array<{\r\n    provider: EmbeddingProviderType;\r\n    model?: string;\r\n    dimensions: number;\r\n    reason: string;\r\n  }>;\r\n}\r\n\r\n/**\r\n * Основная фабрика провайдеров эмбеддингов\r\n */\r\nexport class EmbeddingProviderFactoryImpl implements EmbeddingProviderFactory {\r\n  /** Регистр доступных провайдеров */\r\n  private readonly providerRegistry = new Map<EmbeddingProviderType, ProviderConfigInfo>();\r\n\r\n  constructor() {\r\n    this.initializeProviderRegistry();\r\n  }\r\n\r\n  /**\r\n   * Создание экземпляра провайдера на основе конфигурации коллекции\r\n   */\r\n  public async createProvider(config: CollectionEmbeddingConfig): Promise<EmbeddingProvider> {\r\n    try {\r\n      // Валидация базовой конфигурации\r\n      const validation = this.validateConfiguration(config);\r\n      if (!validation.isValid) {\r\n        throw new ConfigurationError(\r\n          `Invalid provider configuration: ${validation.errors.join(', ')}`,\r\n          'provider',\r\n          validation.suggestions.join('; '),\r\n          config.provider,\r\n          {\r\n            validation,\r\n            config: { ...config, apiKey: config.apiKey ? '[REDACTED]' : undefined }\r\n          }\r\n        );\r\n      }\r\n\r\n      // Проверка поддержки провайдера\r\n      const supportInfo = this.checkProviderSupport(config.provider);\r\n      if (!supportInfo.isSupported) {\r\n        throw new ProviderInitializationError(\r\n          `Provider ${config.provider} is not supported: ${supportInfo.unsupportedReason}`,\r\n          config.provider,\r\n          undefined,\r\n          {\r\n            supportInfo,\r\n            alternatives: supportInfo.alternatives\r\n          }\r\n        );\r\n      }\r\n\r\n      // Создание экземпляра провайдера\r\n      let provider: EmbeddingProvider;\r\n\r\n      switch (config.provider) {\r\n        case 'transformers':\r\n          provider = await this.createTransformersProvider(config);\r\n          break;\r\n\r\n        case 'openai':\r\n          provider = await this.createOpenAIProvider(config);\r\n          break;\r\n\r\n        default:\r\n          throw new ConfigurationError(\r\n            `Unsupported provider type: ${config.provider}`,\r\n            'provider',\r\n            'One of: transformers, openai',\r\n            config.provider\r\n          );\r\n      }\r\n\r\n      // Инициализация провайдера\r\n      await provider.initialize({\r\n        defaultProvider: config.provider,\r\n        defaultDimensions: config.dimensions,\r\n        apiKey: config.apiKey,\r\n        batchSize: config.batchSize,\r\n        timeout: config.timeout,\r\n        enabled: config.autoGenerate,\r\n        provider: config.provider\r\n      });\r\n\r\n      return provider;\r\n\r\n    } catch (error) {\r\n      if (error instanceof Error && (error.name.includes('Error'))) {\r\n        throw error; // Пробрасываем уже обработанные ошибки\r\n      }\r\n\r\n      throw new ProviderInitializationError(\r\n        `Failed to create provider ${config.provider}: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        config.provider,\r\n        error instanceof Error ? error : undefined,\r\n        { config: { ...config, apiKey: config.apiKey ? '[REDACTED]' : undefined } }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки конфигурации\r\n   */\r\n  public supportsConfig(config: CollectionEmbeddingConfig): boolean {\r\n    const validation = this.validateConfiguration(config);\r\n    const supportInfo = this.checkProviderSupport(config.provider);\r\n\r\n    return validation.isValid && supportInfo.isSupported;\r\n  }\r\n\r\n  /**\r\n   * Получение доступных моделей для всех провайдеров\r\n   */\r\n  public async getAvailableModels(): Promise<ModelInfo[]> {\r\n    const models: ModelInfo[] = [];\r\n\r\n    // Transformers.js модели\r\n    if (isTransformersSupported()) {\r\n      models.push(getTransformersModelInfo());\r\n    }\r\n\r\n    // OpenAI модели\r\n    models.push(...OpenAIProvider.getAvailableModels());\r\n\r\n    return models;\r\n  }\r\n\r\n  /**\r\n   * Получение моделей для конкретного провайдера\r\n   */\r\n  public async getModelsForProvider(providerType: EmbeddingProviderType): Promise<ModelInfo[]> {\r\n    switch (providerType) {\r\n      case 'transformers':\r\n        return isTransformersSupported() ? [getTransformersModelInfo()] : [];\r\n\r\n      case 'openai':\r\n        return OpenAIProvider.getAvailableModels();\r\n\r\n      default:\r\n        return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации провайдера\r\n   */\r\n  public validateConfiguration(config: CollectionEmbeddingConfig): ProviderConfigValidation {\r\n    const errors: string[] = [];\r\n    const warnings: string[] = [];\r\n    const suggestions: string[] = [];\r\n\r\n    // Базовая валидация\r\n    if (!config.provider) {\r\n      errors.push('Provider type is required');\r\n      suggestions.push('Specify provider type (transformers, openai)');\r\n    }\r\n\r\n    if (!config.dimensions || config.dimensions <= 0) {\r\n      errors.push('Valid dimensions value is required');\r\n      suggestions.push('Set dimensions to a positive integer');\r\n    }\r\n\r\n    // Валидация для конкретного провайдера\r\n    switch (config.provider) {\r\n      case 'transformers':\r\n        this.validateTransformersConfig(config, errors, warnings, suggestions);\r\n        break;\r\n\r\n      case 'openai':\r\n        this.validateOpenAIConfig(config, errors, warnings, suggestions);\r\n        break;\r\n\r\n      default:\r\n        if (config.provider) {\r\n          errors.push(`Unsupported provider: ${config.provider}`);\r\n          suggestions.push('Use one of: transformers, openai');\r\n        }\r\n    }\r\n\r\n    // Общие рекомендации\r\n    if (config.batchSize && config.batchSize > 100) {\r\n      warnings.push('Large batch sizes may impact performance');\r\n      suggestions.push('Consider reducing batch size to 50 or less');\r\n    }\r\n\r\n    if (config.timeout && config.timeout < 5000) {\r\n      warnings.push('Short timeout may cause frequent failures');\r\n      suggestions.push('Consider increasing timeout to at least 10 seconds');\r\n    }\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n      suggestions\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки провайдера в текущей среде\r\n   */\r\n  public checkProviderSupport(providerType: EmbeddingProviderType): ProviderSupportInfo {\r\n    switch (providerType) {\r\n      case 'transformers':\r\n        return this.checkTransformersSupport();\r\n\r\n      case 'openai':\r\n        return this.checkOpenAISupport();\r\n\r\n      default:\r\n        return {\r\n          isSupported: false,\r\n          unsupportedReason: `Unknown provider type: ${providerType}`,\r\n          alternatives: ['transformers', 'openai'],\r\n          requirements: ['Valid provider type']\r\n        };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение информации о провайдере\r\n   */\r\n  public getProviderInfo(providerType: EmbeddingProviderType): ProviderConfigInfo | undefined {\r\n    return this.providerRegistry.get(providerType);\r\n  }\r\n\r\n  /**\r\n   * Получение всех доступных провайдеров\r\n   */\r\n  public getAvailableProviders(): ProviderConfigInfo[] {\r\n    return Array.from(this.providerRegistry.values());\r\n  }\r\n\r\n  /**\r\n   * Получение рекомендаций по выбору провайдера\r\n   */\r\n  public getProviderRecommendations(requirements: {\r\n    dimensions?: number;\r\n    budget?: 'low' | 'medium' | 'high';\r\n    performance?: 'fast' | 'balanced' | 'accurate';\r\n    privacy?: 'local' | 'cloud' | 'any';\r\n    useCase?: string;\r\n  }): ProviderRecommendation[] {\r\n    const recommendations: ProviderRecommendation[] = [];\r\n    const { dimensions = 384, budget = 'medium', performance = 'balanced', privacy = 'any' } = requirements;\r\n\r\n    // Локальные провайдеры для приватности\r\n    if (privacy === 'local' || privacy === 'any') {\r\n      if (isTransformersSupported() && dimensions === 384) {\r\n        recommendations.push({\r\n          provider: 'transformers',\r\n          dimensions: 384,\r\n          reason: 'Local processing for privacy, no API costs, works offline',\r\n          priority: privacy === 'local' ? 10 : 7,\r\n          alternatives: []\r\n        });\r\n      }\r\n    }\r\n\r\n    // Внешние API для гибкости\r\n    if (privacy === 'cloud' || privacy === 'any') {\r\n      if (budget === 'low' || performance === 'fast') {\r\n        recommendations.push({\r\n          provider: 'openai',\r\n          model: 'text-embedding-3-small',\r\n          dimensions: Math.min(dimensions, 384),\r\n          reason: 'Cost-effective with good performance and flexible dimensions',\r\n          priority: 8,\r\n          alternatives: [\r\n            {\r\n              provider: 'openai',\r\n              model: 'text-embedding-3-small',\r\n              dimensions: 768,\r\n              reason: 'Better accuracy with moderate cost increase'\r\n            }\r\n          ]\r\n        });\r\n      }\r\n\r\n      if (budget === 'high' || performance === 'accurate') {\r\n        recommendations.push({\r\n          provider: 'openai',\r\n          model: 'text-embedding-3-large',\r\n          dimensions: Math.min(dimensions, 1024),\r\n          reason: 'Highest accuracy for demanding applications',\r\n          priority: 9,\r\n          alternatives: [\r\n            {\r\n              provider: 'openai',\r\n              model: 'text-embedding-3-small',\r\n              dimensions: 1536,\r\n              reason: 'Lower cost alternative with good accuracy'\r\n            }\r\n          ]\r\n        });\r\n      }\r\n\r\n      // Сбалансированный выбор\r\n      if (performance === 'balanced') {\r\n        const openaiConfig = getRecommendedConfig({ dimensions, budget, performance });\r\n        recommendations.push({\r\n          provider: 'openai',\r\n          model: openaiConfig.model,\r\n          dimensions: openaiConfig.dimensions,\r\n          reason: openaiConfig.description,\r\n          priority: 6,\r\n          alternatives: []\r\n        });\r\n      }\r\n    }\r\n\r\n    // Сортируем по приоритету\r\n    return recommendations.sort((a, b) => b.priority - a.priority);\r\n  }\r\n\r\n  /**\r\n   * Создание Transformers.js провайдера\r\n   */\r\n  private async createTransformersProvider(config: CollectionEmbeddingConfig): Promise<TransformersProvider> {\r\n    if (config.dimensions !== 384) {\r\n      throw new ConfigurationError(\r\n        'Transformers.js provider only supports 384 dimensions',\r\n        'dimensions',\r\n        '384',\r\n        config.dimensions\r\n      );\r\n    }\r\n\r\n    return new TransformersProvider({\r\n      defaultProvider: 'transformers',\r\n      defaultDimensions: 384,\r\n      batchSize: config.batchSize || 16,\r\n      enableLogging: false,\r\n      modelLoadTimeout: config.timeout || 30000,\r\n      operationTimeout: config.timeout || 10000,\r\n      enableModelCache: config.cacheEnabled !== false,\r\n      ...config.providerOptions\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Создание OpenAI провайдера\r\n   */\r\n  private async createOpenAIProvider(config: CollectionEmbeddingConfig): Promise<OpenAIProvider> {\r\n    if (!config.apiKey) {\r\n      throw new ConfigurationError(\r\n        'OpenAI provider requires API key',\r\n        'apiKey',\r\n        'Valid OpenAI API key starting with sk-',\r\n        undefined\r\n      );\r\n    }\r\n\r\n    const model = config.model || 'text-embedding-3-small';\r\n\r\n    // Проверяем совместимость модели и размерности\r\n    if (!isValidModelDimensionCombo(model, config.dimensions)) {\r\n      throw new ConfigurationError(\r\n        `Model ${model} does not support ${config.dimensions} dimensions`,\r\n        'dimensions',\r\n        'Valid dimensions for the selected model',\r\n        config.dimensions,\r\n        { model, provider: 'openai' }\r\n      );\r\n    }\r\n\r\n    return new OpenAIProvider(config.dimensions, model);\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации Transformers.js\r\n   */\r\n  private validateTransformersConfig(\r\n    config: CollectionEmbeddingConfig,\r\n    errors: string[],\r\n    warnings: string[],\r\n    suggestions: string[]\r\n  ): void {\r\n    if (config.dimensions !== 384) {\r\n      errors.push('Transformers.js provider only supports 384 dimensions');\r\n      suggestions.push('Set dimensions to 384 for Transformers.js provider');\r\n    }\r\n\r\n    if (config.apiKey) {\r\n      warnings.push('API key is not needed for Transformers.js provider');\r\n      suggestions.push('Remove apiKey from configuration for local provider');\r\n    }\r\n\r\n    if (config.model && config.model !== 'all-MiniLM-L6-v2') {\r\n      warnings.push(`Model ${config.model} is not supported by Transformers.js provider`);\r\n      suggestions.push('Use default model or remove model specification');\r\n    }\r\n\r\n    if (!isTransformersSupported()) {\r\n      errors.push('Transformers.js is not supported in current environment');\r\n      suggestions.push('Use a browser with Web Workers and SharedArrayBuffer support');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации OpenAI\r\n   */\r\n  private validateOpenAIConfig(\r\n    config: CollectionEmbeddingConfig,\r\n    errors: string[],\r\n    warnings: string[],\r\n    suggestions: string[]\r\n  ): void {\r\n    if (!config.apiKey) {\r\n      errors.push('OpenAI provider requires API key');\r\n      suggestions.push('Set apiKey in configuration');\r\n    } else if (!config.apiKey.startsWith('sk-')) {\r\n      warnings.push('OpenAI API key should start with \"sk-\"');\r\n      suggestions.push('Verify API key format');\r\n    }\r\n\r\n    const model = config.model || 'text-embedding-3-small';\r\n    if (!isValidModelDimensionCombo(model, config.dimensions)) {\r\n      errors.push(`Model ${model} does not support ${config.dimensions} dimensions`);\r\n      suggestions.push('Check supported dimensions for the selected model');\r\n    }\r\n\r\n    if (config.batchSize && config.batchSize > 100) {\r\n      warnings.push('Large batch sizes may be inefficient for OpenAI API');\r\n      suggestions.push('Consider using batch size of 50 or less');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки Transformers.js\r\n   */\r\n  private checkTransformersSupport(): ProviderSupportInfo {\r\n    if (!isTransformersSupported()) {\r\n      return {\r\n        isSupported: false,\r\n        unsupportedReason: 'Browser does not support required features',\r\n        alternatives: ['openai'],\r\n        requirements: [\r\n          'Web Workers support',\r\n          'SharedArrayBuffer support',\r\n          'WebAssembly support',\r\n          'Modern browser (Chrome 86+, Firefox 79+, Safari 15+)'\r\n        ]\r\n      };\r\n    }\r\n\r\n    return {\r\n      isSupported: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки OpenAI\r\n   */\r\n  private checkOpenAISupport(): ProviderSupportInfo {\r\n    // OpenAI API доступен во всех современных браузерах с fetch\r\n    if (typeof fetch === 'undefined') {\r\n      return {\r\n        isSupported: false,\r\n        unsupportedReason: 'Fetch API is not available',\r\n        alternatives: ['transformers'],\r\n        requirements: ['Modern browser with fetch API support']\r\n      };\r\n    }\r\n\r\n    return {\r\n      isSupported: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Инициализация реестра провайдеров\r\n   */\r\n  private initializeProviderRegistry(): void {\r\n    // Transformers.js провайдер\r\n    this.providerRegistry.set('transformers', {\r\n      type: 'transformers',\r\n      displayName: 'Transformers.js (Local)',\r\n      description: 'Local embedding generation using all-MiniLM-L6-v2 model. Runs entirely in browser with no external API calls.',\r\n      supportedDimensions: [384],\r\n      defaultDimensions: 384,\r\n      requiresApiKey: false,\r\n      isLocal: true,\r\n      availableModels: isTransformersSupported() ? [getTransformersModelInfo()] : [],\r\n      recommendedUseCases: [\r\n        'Privacy-sensitive applications',\r\n        'Offline functionality',\r\n        'No API cost constraints',\r\n        'Real-time processing',\r\n        'Development and prototyping'\r\n      ],\r\n      environmentRequirements: [\r\n        'Web Workers support',\r\n        'SharedArrayBuffer support',\r\n        'WebAssembly support',\r\n        'Modern browser'\r\n      ]\r\n    });\r\n\r\n    // OpenAI провайдер\r\n    this.providerRegistry.set('openai', {\r\n      type: 'openai',\r\n      displayName: 'OpenAI Embeddings API',\r\n      description: 'Cloud-based embedding generation using OpenAI models. Supports multiple models and configurable dimensions.',\r\n      supportedDimensions: [256, 384, 512, 768, 1024, 1536, 3072],\r\n      defaultDimensions: 1536,\r\n      requiresApiKey: true,\r\n      isLocal: false,\r\n      availableModels: OpenAIProvider.getAvailableModels(),\r\n      recommendedUseCases: [\r\n        'Production applications',\r\n        'High accuracy requirements',\r\n        'Multiple language support',\r\n        'Flexible dimensions',\r\n        'Large-scale processing'\r\n      ],\r\n      environmentRequirements: [\r\n        'Internet connection',\r\n        'Valid OpenAI API key',\r\n        'fetch API support'\r\n      ]\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Singleton instance of the provider factory\r\n */\r\nexport const providerFactory = new EmbeddingProviderFactoryImpl();\r\n\r\n/**\r\n * Convenience function to create a provider\r\n */\r\nexport async function createEmbeddingProvider(config: CollectionEmbeddingConfig): Promise<EmbeddingProvider> {\r\n  return providerFactory.createProvider(config);\r\n}\r\n\r\n/**\r\n * Convenience function to validate provider configuration\r\n */\r\nexport function validateProviderConfig(config: CollectionEmbeddingConfig): ProviderConfigValidation {\r\n  return providerFactory.validateConfiguration(config);\r\n}\r\n\r\n/**\r\n * Convenience function to check provider support\r\n */\r\nexport function checkProviderSupport(providerType: EmbeddingProviderType): ProviderSupportInfo {\r\n  return providerFactory.checkProviderSupport(providerType);\r\n}\r\n\r\n/**\r\n * Convenience function to get provider recommendations\r\n */\r\nexport function getProviderRecommendations(requirements: {\r\n  dimensions?: number;\r\n  budget?: 'low' | 'medium' | 'high';\r\n  performance?: 'fast' | 'balanced' | 'accurate';\r\n  privacy?: 'local' | 'cloud' | 'any';\r\n  useCase?: string;\r\n}): ProviderRecommendation[] {\r\n  return providerFactory.getProviderRecommendations(requirements);\r\n}\r\n\r\n/**\r\n * Convenience function to get all available providers\r\n */\r\nexport function getAvailableProviders(): ProviderConfigInfo[] {\r\n  return providerFactory.getAvailableProviders();\r\n}\r\n\r\n/**\r\n * Convenience function to get available models\r\n */\r\nexport async function getAvailableModels(): Promise<ModelInfo[]> {\r\n  return providerFactory.getAvailableModels();\r\n}\r\n\r\n// Note: EmbeddingProviderFactoryImpl is already exported above"],"names":["message","code","details","DatabaseError","WorkerError","sqliteCode","VectorError","OPFSError","DEFAULT_CONFIG","WorkerRPC","worker","config","event","response","level","error","pending","duration","method","params","resolve","reject","id","startTime","timeout","args","levels","configLevel","result","name","collection","options","avgLatency","WorkerRPCHandler","handler","postError","errorResponse","finalError","createWorkerRPC","workerUrl","EmbeddingError","category","context","recoveryInfo","ProviderError","providerName","modelVersion","ProviderInitializationError","cause","ModelLoadError","modelName","modelSize","NetworkError","networkType","statusCode","url","retryAfter","AuthenticationError","authType","ConfigurationError","parameterName","expectedValue","actualValue","ValidationError","fieldName","validationRule","QuotaExceededError","quotaType","currentValue","maxValue","resetTime","actions","TimeoutError","timeoutMs","operation","CacheError","cacheOperation","cacheKey","workerOperation","workerId","BaseEmbeddingProvider","dimensions","maxBatchSize","maxTextLength","errors","warnings","suggestions","text","estimatedTokens","texts","index","generationTime","embeddingCount","isError","totalTime","ProviderUtils","embedding","norm","normalized","a","b","dotProduct","normA","normB","i","normalize","ExternalProvider","validation","health","lastError","maxRetries","attempt","delay","embeddings","isHealthy","requestsPerMinute","waitTime","baseDelay","exponentialDelay","jitter","requestCount","success","ms","OPENAI_MODELS","OpenAIProvider","model","modelInfo","requestBody","headers","controller","timeoutId","responseData","info","status","errorData","errorMessage","errorType","errorCode","item","baseValidation","createOpenAIProvider","isValidModelDimensionCombo","getRecommendedConfig","requirements","budget","performance","TransformersProvider","results","chunkSize","chunk","chunkResults","t","embData","request","responseTime","type","data","timeoutHandle","createTransformersProvider","isTransformersSupported","getModelInfo","EmbeddingProviderFactoryImpl","supportInfo","provider","models","getTransformersModelInfo","providerType","recommendations","privacy","openaiConfig","providerFactory","createEmbeddingProvider","validateProviderConfig","checkProviderSupport","getProviderRecommendations","getAvailableProviders","getAvailableModels"],"mappings":"QA+eO,cAA0B,MAAM;AAAA,EACrC,YACEA,GACOC,GACAC,GACP;AACA,UAAMF,CAAO,GAHN,KAAA,OAAAC,GACA,KAAA,UAAAC,GAGP,KAAK,OAAO;AAAA,EACd;AACF;AAEO,MAAMC,UAAsBC,EAAY;AAAA,EAC7C,YAAYJ,GAAwBK,GAAqB;AACvD,UAAML,GAAS,gBAAgB,GADG,KAAA,aAAAK,GAElC,KAAK,OAAO;AAAA,EACd;AACF;AAEO,MAAMC,UAAoBF,EAAY;AAAA,EAC3C,YAAYJ,GAAiB;AAC3B,UAAMA,GAAS,cAAc,GAC7B,KAAK,OAAO;AAAA,EACd;AACF;AAEO,MAAMO,UAAkBH,EAAY;AAAA,EACzC,YAAYJ,GAAiB;AAC3B,UAAMA,GAAS,YAAY,GAC3B,KAAK,OAAO;AAAA,EACd;AACF;ACzfA,MAAMQ,IAAyC;AAAA,EAC7C,yBAAyB;AAAA,EACzB,kBAAkB;AAAA;AAAA,EAClB,6BAA6B;AAAA,EAC7B,UAAU;AACZ;AAKO,MAAMC,EAAiC;AAAA,EAiB5C,YAAYC,GAAgBC,IAAgC,IAAI;AAdhE,SAAQ,mCAAmB,IAAA,GAM3B,KAAQ,cAAc,GACtB,KAAQ,qBAAqB;AAAA,MAC3B,YAAY;AAAA,MACZ,WAAW;AAAA,MACX,QAAQ;AAAA,MACR,UAAU;AAAA,IAAA,GAIV,KAAK,SAASD,GACd,KAAK,SAAS,EAAE,GAAGF,GAAgB,GAAGG,EAAA,GACtC,KAAK,qBAAA;AAAA,EACP;AAAA,EAEQ,uBAA6B;AACnC,SAAK,OAAO,YAAY,CAACC,MAA8C;AACrE,YAAMC,IAAWD,EAAM;AAGvB,UAAIC,EAAS,SAAS,OAAO;AAC3B,cAAMC,IAAQD,EAAS;AAEvB,SADe,QAAQC,CAAK,KAAK,QAAQ,KACnCD,EAAS,SAAS,GAAIA,EAAS,QAAQ,CAAA,CAAG;AAChD;AAAA,MACF;AAEA,WAAK,qBAAqBA,CAAQ;AAAA,IACpC,GAEA,KAAK,OAAO,UAAU,CAACE,MAAsB;AAC3C,WAAK,IAAI,SAAS,iBAAiBA,EAAM,OAAO,GAChD,KAAK,iBAAiB,IAAIX,EAAY,mBAAmBW,EAAM,SAAS,cAAc,CAAC;AAAA,IACzF,GAEA,KAAK,OAAO,iBAAiB,CAACH,MAAwB;AACpD,WAAK,IAAI,SAAS,yBAAyBA,CAAK,GAChD,KAAK,iBAAiB,IAAIR,EAAY,wBAAwB,eAAe,CAAC;AAAA,IAChF;AAAA,EACF;AAAA,EAEQ,qBAAqBS,GAAgC;AAC3D,UAAMG,IAAU,KAAK,aAAa,IAAIH,EAAS,EAAE;AACjD,QAAI,CAACG,GAAS;AACZ,WAAK,IAAI,QAAQ,0CAA0CH,EAAS,EAAE;AACtE;AAAA,IACF;AAMA,QAJA,KAAK,aAAa,OAAOA,EAAS,EAAE,GACpC,aAAaG,EAAQ,OAAO,GAGxB,KAAK,OAAO,6BAA6B;AAC3C,YAAMC,IAAW,KAAK,IAAA,IAAQD,EAAQ;AACtC,WAAK,mBAAmB,cACxB,KAAK,mBAAmB,aAAaC;AAAA,IACvC;AAEA,QAAIJ,EAAS,OAAO;AAClB,WAAK,mBAAmB;AACxB,YAAME,IAAQ,IAAIX;AAAAA,QAChBS,EAAS,MAAM;AAAA,QACfA,EAAS,MAAM;AAAA,MAAA;AAEjB,MAAIA,EAAS,MAAM,UACjBE,EAAM,QAAQF,EAAS,MAAM,QAE/BG,EAAQ,OAAOD,CAAK;AAAA,IACtB;AACE,MAAAC,EAAQ,QAAQH,EAAS,MAAM;AAAA,EAEnC;AAAA,EAEQ,iBAAyB;AAC/B,WAAO,OAAO,EAAE,KAAK,WAAW,IAAI,KAAK,KAAK;AAAA,EAChD;AAAA,EAEQ,KAAcK,GAA0BC,GAA0B;AACxE,WAAO,IAAI,QAAQ,CAACC,GAASC,MAAW;AAEtC,UAAI,KAAK,aAAa,QAAQ,KAAK,OAAO,yBAAyB;AACjE,aAAK,IAAI,SAAS,2BAA2BH,CAAM,KAAK,KAAK,aAAa,IAAI,IAAI,KAAK,OAAO,uBAAuB,EAAE,GACvHG,EAAO,IAAIjB;AAAAA,UACT,wCAAwC,KAAK,OAAO,uBAAuB;AAAA,UAC3E;AAAA,QAAA,CACD;AACD;AAAA,MACF;AAEA,YAAMkB,IAAK,KAAK,eAAA,GACVC,IAAY,KAAK,IAAA,GAGjBC,IAAU,WAAW,MAAM;AAC/B,aAAK,IAAI,SAAS,yBAAyBN,CAAM,UAAU,KAAK,OAAO,gBAAgB,IAAI,GAC3F,KAAK,aAAa,OAAOI,CAAE,GAC3B,KAAK,mBAAmB,YACxBD,EAAO,IAAIjB;AAAAA,UACT,2BAA2B,KAAK,OAAO,gBAAgB;AAAA,UACvD;AAAA,QAAA,CACD;AAAA,MACH,GAAG,KAAK,OAAO,gBAAgB;AAG/B,WAAK,aAAa,IAAIkB,GAAI;AAAA,QACxB,SAAAF;AAAA,QACA,QAAAC;AAAA,QACA,SAAAG;AAAA,QACA,WAAAD;AAAA,MAAA,CACD;AAGD,YAAMvB,IAAyB;AAAA,QAC7B,IAAAsB;AAAA,QACA,QAAAJ;AAAA,QACA,QAAAC;AAAA,MAAA;AAGF,UAAI;AACF,aAAK,OAAO,YAAYnB,CAAO;AAAA,MACjC,SAASe,GAAO;AACd,aAAK,IAAI,SAAS,kCAAkCG,CAAM,KAAKH,CAAK,GACpE,KAAK,aAAa,OAAOO,CAAE,GAC3B,aAAaE,CAAO,GACpBH,EAAO,IAAIjB;AAAAA,UACT,2BAA2BW,aAAiB,QAAQA,EAAM,UAAU,OAAOA,CAAK,CAAC;AAAA,UACjF;AAAA,QAAA,CACD;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,iBAAiBA,GAAoB;AAC3C,eAAW,CAACO,GAAIN,CAAO,KAAK,KAAK;AAC/B,mBAAaA,EAAQ,OAAO,GAC5BA,EAAQ,OAAOD,CAAK;AAEtB,SAAK,aAAa,MAAA;AAAA,EACpB;AAAA,EAEQ,IAAID,GAA4Cd,MAAoByB,GAAmB;AAC7F,UAAMC,IAAS,EAAE,OAAO,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,EAAA,GAC9CC,IAAcD,EAAO,KAAK,OAAO,QAAQ;AAG/C,IAFqBA,EAAOZ,CAAK,KAEba,KAClB,QAAQb,CAAK,EAAE,eAAed,CAAO,IAAI,GAAGyB,CAAI;AAAA,EAEpD;AAAA;AAAA,EAGA,MAAM,KAAKN,GAA2D;AACpE,WAAO,KAAK,KAAK,QAAQA,CAAM;AAAA,EACjC;AAAA,EAEA,MAAM,QAAuB;AAC3B,UAAMS,IAAS,MAAM,KAAK,KAAK,OAAO;AAEtC,gBAAK,iBAAiB,IAAIxB,EAAY,iBAAiB,eAAe,CAAC,GAChEwB;AAAA,EACT;AAAA,EAEA,MAAM,KAAKT,GAA2D;AACpE,WAAO,KAAK,KAAK,QAAQA,CAAM;AAAA,EACjC;AAAA,EAEA,MAAM,OAAOA,GAA8C;AACzD,WAAO,KAAK,KAAK,UAAUA,CAAM;AAAA,EACnC;AAAA,EAEA,MAAM,WAAWA,GAAiE;AAChF,WAAO,KAAK,KAAK,cAAcA,CAAM;AAAA,EACvC;AAAA,EAEA,MAAM,mBAAkC;AACtC,WAAO,KAAK,KAAK,kBAAkB;AAAA,EACrC;AAAA,EAEA,MAAM,mBAAkC;AACtC,WAAO,KAAK,KAAK,kBAAkB;AAAA,EACrC;AAAA,EAEA,MAAM,kBAAkBU,GAAc;AACpC,WAAO,KAAK,KAAK,qBAAqBA,CAAI;AAAA,EAC5C;AAAA,EAEA,MAAM,OAAOV,GAA8C;AACzD,WAAO,KAAK,KAAK,UAAUA,CAAM;AAAA,EACnC;AAAA,EAEA,MAAM,OAAOA,GAAoE;AAC/E,WAAO,KAAK,KAAK,UAAUA,CAAM;AAAA,EACnC;AAAA,EAEA,MAAM,OAAOA,GAA6D;AACxE,WAAO,KAAK,KAAK,UAAUA,CAAM;AAAA,EACnC;AAAA,EAEA,MAAM,QAAuB;AAC3B,WAAO,KAAK,KAAK,OAAO;AAAA,EAC1B;AAAA,EAEA,MAAM,aAAa;AACjB,WAAO,KAAK,KAAK,YAAY;AAAA,EAC/B;AAAA,EAEA,MAAM,WAAW;AACf,WAAO,KAAK,KAAK,UAAU;AAAA,EAC7B;AAAA;AAAA,EAGA,MAAM,iBAAiBA,GAAuE;AAC5F,WAAO,KAAK,KAAK,oBAAoBA,CAAM;AAAA,EAC7C;AAAA,EAEA,MAAM,6BAA6BW,GAAoB;AACrD,WAAO,KAAK,KAAK,gCAAgCA,CAAU;AAAA,EAC7D;AAAA;AAAA,EAGA,MAAM,4BAA4BX,GAAmE;AACnG,WAAO,KAAK,KAAK,+BAA+BA,CAAM;AAAA,EACxD;AAAA;AAAA,EAGA,MAAM,eAAeA,GAAsD;AACzE,WAAO,KAAK,KAAK,kBAAkBA,CAAM;AAAA,EAC3C;AAAA;AAAA,EAGA,MAAM,WAAWA,GAAkD;AACjE,WAAO,KAAK,KAAK,cAAcA,CAAM;AAAA,EACvC;AAAA,EAEA,MAAM,eAAeA,GAAsD;AACzE,WAAO,KAAK,KAAK,kBAAkBA,CAAM;AAAA,EAC3C;AAAA,EAEA,MAAM,aAAaA,GAAoD;AACrE,WAAO,KAAK,KAAK,gBAAgBA,CAAM;AAAA,EACzC;AAAA;AAAA,EAGA,MAAM,kBAAkBA,GAAyD;AAC/E,WAAO,KAAK,KAAK,qBAAqBA,CAAM;AAAA,EAC9C;AAAA,EAEA,MAAM,wBAAwBA,GAA+D;AAC3F,WAAO,KAAK,KAAK,2BAA2BA,CAAM;AAAA,EACpD;AAAA,EAEA,MAAM,+BAA+BW,GAAoBC,GAAwE;AAC/H,WAAO,KAAK,KAAK,kCAAkC,EAAE,YAAAD,GAAY,SAAAC,GAAS;AAAA,EAC5E;AAAA;AAAA,EAGA,MAAM,iBAAiBZ,GAAyE;AAC9F,WAAO,KAAK,KAAK,oBAAoBA,CAAM;AAAA,EAC7C;AAAA,EAEA,MAAM,sBAAsBA,GAA8D;AACxF,WAAO,KAAK,KAAK,yBAAyBA,CAAM;AAAA,EAClD;AAAA,EAEA,MAAM,eAAeW,GAAqB;AACxC,WAAO,KAAK,KAAK,kBAAkBA,CAAU;AAAA,EAC/C;AAAA,EAEA,MAAM,oBAAoBX,GAA6E;AACrG,WAAO,KAAK,KAAK,uBAAuBA,CAAM;AAAA,EAChD;AAAA;AAAA,EAGA,MAAM,aAAaA,GAAoD;AACrE,WAAO,KAAK,KAAK,gBAAgBA,CAAM;AAAA,EACzC;AAAA,EAEA,MAAM,iBAAiBA,GAAwD;AAC7E,WAAO,KAAK,KAAK,oBAAoBA,CAAM;AAAA,EAC7C;AAAA,EAEA,MAAM,cAAcA,GAAqD;AACvE,WAAO,KAAK,KAAK,iBAAiBA,CAAM;AAAA,EAC1C;AAAA,EAEA,MAAM,QAAQA,GAA+C;AAC3D,WAAO,KAAK,KAAK,WAAWA,CAAM;AAAA,EACpC;AAAA;AAAA,EAGA,MAAM,uBAAuBA,GAA8D;AACzF,WAAO,KAAK,KAAK,0BAA0BA,CAAM;AAAA,EACnD;AAAA,EAEA,MAAM,6BAA6BA,GAAoE;AACrG,WAAO,KAAK,KAAK,gCAAgCA,CAAM;AAAA,EACzD;AAAA,EAEA,MAAM,mBAAmBA,GAA0D;AACjF,WAAO,KAAK,KAAK,sBAAsBA,CAAM;AAAA,EAC/C;AAAA,EAEA,MAAM,oBAAoBA,GAA4D;AACpF,WAAO,KAAK,KAAK,uBAAuBA,CAAM;AAAA,EAChD;AAAA,EAEA,MAAM,mBAAmB;AACvB,WAAO,KAAK,KAAK,kBAAkB;AAAA,EACrC;AAAA,EAEA,MAAM,iBAAiB;AACrB,WAAO,KAAK,KAAK,gBAAgB;AAAA,EACnC;AAAA,EAEA,MAAM,cAAcA,GAAqD;AACvE,WAAO,KAAK,KAAK,iBAAiBA,CAAM;AAAA,EAC1C;AAAA,EAEA,MAAM,oBAAoBA,GAA4D;AACpF,WAAO,KAAK,KAAK,uBAAuBA,CAAM;AAAA,EAChD;AAAA;AAAA,EAGA,wBAAwB;AACtB,UAAMa,IAAa,KAAK,mBAAmB,aAAa,IACpD,KAAK,mBAAmB,YAAY,KAAK,mBAAmB,aAC5D;AAEJ,WAAO;AAAA,MACL,GAAG,KAAK;AAAA,MACR,gBAAgBA;AAAA,MAChB,mBAAmB,KAAK,aAAa;AAAA,MACrC,aAAa,KAAK,mBAAmB,aAAa,KAC7C,KAAK,mBAAmB,aAAa,KAAK,mBAAmB,UAAU,KAAK,mBAAmB,aAChG;AAAA,IAAA;AAAA,EAER;AAAA,EAEA,YAAkB;AAChB,SAAK,iBAAiB,IAAI5B,EAAY,qBAAqB,YAAY,CAAC,GACxE,KAAK,OAAO,UAAA;AAAA,EACd;AACF;AAKO,MAAM6B,EAAiB;AAAA,EAI5B,YAAYtB,IAAgC,IAAI;AAHhD,SAAQ,+BAAe,IAAA,GAIrB,KAAK,SAAS,EAAE,GAAGH,GAAgB,GAAGG,EAAA,GACtC,KAAK,oBAAA;AAAA,EACP;AAAA,EAEQ,sBAA4B;AAClC,SAAK,YAAY,OAAOC,MAAuC;AAC7D,YAAMZ,IAAUY,EAAM;AACtB,YAAM,KAAK,cAAcZ,CAAO;AAAA,IAClC;AAAA,EACF;AAAA,EAEA,MAAc,cAAcA,GAAuC;AAEjE,QAAIa;AAEJ,QAAI;AAEF,YAAMqB,IAAU,KAAK,SAAS,IAAIlC,EAAQ,MAAM;AAChD,UAAI,CAACkC;AACH,cAAM,IAAI9B,EAAY,mBAAmBJ,EAAQ,MAAM,IAAI,gBAAgB;AAG7E,YAAM4B,IAAS,MAAMM,EAAQlC,EAAQ,MAAM;AAE3C,MAAAa,IAAW;AAAA,QACT,IAAIb,EAAQ;AAAA,QACZ,QAAA4B;AAAA,MAAA;AAAA,IAEJ,SAASb,GAAO;AACd,WAAK,IAAI,SAAS,UAAUf,EAAQ,MAAM,YAAYe,CAAK,GAE3DF,IAAW;AAAA,QACT,IAAIb,EAAQ;AAAA,QACZ,OAAO;AAAA,UACL,SAASe,aAAiB,QAAQA,EAAM,UAAU,OAAOA,CAAK;AAAA,UAC9D,MAAMA,aAAiBX,IAAcW,EAAM,OAAO;AAAA,UAClD,OAAOA,aAAiB,QAAQA,EAAM,QAAQ;AAAA,QAAA;AAAA,MAChD;AAAA,IAEJ;AAEA,QAAI;AACF,WAAK,YAAYF,CAAQ;AAAA,IAC3B,SAASsB,GAAW;AAClB,WAAK,IAAI,SAAS,4BAA4BA,CAAS;AAGvD,YAAMC,IAAgC;AAAA,QACpC,IAAIpC,EAAQ;AAAA,QACZ,OAAO;AAAA,UACL,SAAS;AAAA,UACT,MAAM;AAAA,QAAA;AAAA,MACR;AAGF,UAAI;AACF,aAAK,YAAYoC,CAAa;AAAA,MAChC,SAASC,GAAY;AACnB,aAAK,IAAI,SAAS,kCAAkCA,CAAU;AAAA,MAChE;AAAA,IACF;AAAA,EACF;AAAA,EAEA,SAASnB,GAAgBgB,GAA8C;AACrE,SAAK,SAAS,IAAIhB,GAAQgB,CAAO,GACjC,KAAK,IAAI,SAAS,kCAAkChB,CAAM,EAAE;AAAA,EAC9D;AAAA,EAEA,WAAWA,GAAsB;AAC/B,SAAK,SAAS,OAAOA,CAAM,GAC3B,KAAK,IAAI,SAAS,oCAAoCA,CAAM,EAAE;AAAA,EAChE;AAAA,EAEQ,IAAIJ,GAA4Cd,MAAoByB,GAAmB;AAC7F,UAAMC,IAAS,EAAE,OAAO,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,EAAA,GAC9CC,IAAcD,EAAO,KAAK,OAAO,QAAQ;AAG/C,IAFqBA,EAAOZ,CAAK,KAEba,KAClB,QAAQb,CAAK,EAAE,sBAAsBd,CAAO,IAAI,GAAGyB,CAAI;AAAA,EAE3D;AACF;AAKO,SAASa,EACdC,GACA5B,GACW;AACX,QAAMD,IAAS,IAAI,OAAO6B,GAAW,EAAE,MAAM,UAAU;AACvD,SAAO,IAAI9B,EAAUC,GAAQC,CAAM;AACrC;ACzdO,MAAM6B,UAAuB,MAAM;AAAA,EAgBxC,YACExC,GACAC,IAAe,mBACfwC,IAA0B,WAC1BC,GACAC,GACA;AACA,UAAM3C,CAAO,GACb,KAAK,OAAO,kBACZ,KAAK,OAAOC,GACZ,KAAK,WAAWwC,GAChB,KAAK,UAAUC,GACf,KAAK,eAAeC,GACpB,KAAK,gCAAgB,KAAA,GAGrB,OAAO,eAAe,MAAMH,EAAe,SAAS;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA,EAKA,SAAoB;AAClB,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,SAAS,KAAK;AAAA,MACd,MAAM,KAAK;AAAA,MACX,UAAU,KAAK;AAAA,MACf,SAAS,KAAK;AAAA,MACd,cAAc,KAAK;AAAA,MACnB,WAAW,KAAK,UAAU,YAAA;AAAA,MAC1B,OAAO,KAAK;AAAA,IAAA;AAAA,EAEhB;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAyB;AACvB,YAAQ,KAAK,UAAA;AAAA,MACX,KAAK;AACH,eAAO,kCAAkC,KAAK,OAAO;AAAA,MACvD,KAAK;AACH,eAAO,oCAAoC,KAAK,OAAO;AAAA,MACzD,KAAK;AACH,eAAO,wBAAwB,KAAK,OAAO;AAAA,MAC7C,KAAK;AACH,eAAO,oBAAoB,KAAK,OAAO;AAAA,MACzC,KAAK;AACH,eAAO,mBAAmB,KAAK,OAAO;AAAA,MACxC,KAAK;AACH,eAAO,6BAA6B,KAAK,OAAO;AAAA,MAClD;AACE,eAAO,KAAK;AAAA,IAAA;AAAA,EAElB;AACF;AAKO,MAAMI,UAAsBJ,EAAe;AAAA,EAOhD,YACExC,GACA6C,GACA5C,IAAe,kBACf6C,GACAJ,GACA;AACA;AAAA,MACE1C;AAAA,MACAC;AAAA,MACA;AAAA,MACA,EAAE,GAAGyC,GAAS,cAAAG,GAAc,cAAAC,EAAA;AAAA,MAC5B;AAAA,QACE,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,mBAAmB;AAAA,MAAA;AAAA,IACrB,GAEF,KAAK,OAAO,iBACZ,KAAK,eAAeD,GACpB,KAAK,eAAeC,GAEpB,OAAO,eAAe,MAAMF,EAAc,SAAS;AAAA,EACrD;AACF;AAKO,MAAMG,UAAoCH,EAAc;AAAA,EAC7D,YACE5C,GACA6C,GACAG,GACAN,GACA;AACA;AAAA,MACE1C;AAAA,MACA6C;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE,GAAGH,GAAS,OAAOM,GAAO,QAAA;AAAA,IAAQ,GAEtC,KAAK,OAAO,+BAGX,KAAa,eAAe;AAAA,MAC3B,UAAU;AAAA,MACV,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ,mBAAmB;AAAA,MACnB,oBAAoB;AAAA,MACpB,kBAAkB;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,IACF,GAGF,OAAO,eAAe,MAAMD,EAA4B,SAAS;AAAA,EACnE;AACF;AAKO,MAAME,UAAuBL,EAAc;AAAA,EAOhD,YACE5C,GACA6C,GACAK,GACAC,GACAT,GACA;AACA;AAAA,MACE1C;AAAA,MACA6C;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE,GAAGH,GAAS,WAAAQ,GAAW,WAAAC,EAAA;AAAA,IAAU,GAErC,KAAK,OAAO,kBACZ,KAAK,YAAYD,GACjB,KAAK,YAAYC,GAEjB,OAAO,eAAe,MAAMF,EAAe,SAAS;AAAA,EACtD;AACF;AAKO,MAAMG,UAAqBZ,EAAe;AAAA,EAU/C,YACExC,GACAqD,GACAC,GACAC,GACAb,GACA;AACA,UAAMzC,IAAO,WAAWoD,EAAY,YAAA,CAAa,UAC3CG,IAAaJ,EAAa,cAAcE,GAAYD,CAAW;AAErE;AAAA,MACErD;AAAA,MACAC;AAAA,MACA;AAAA,MACA,EAAE,GAAGyC,GAAS,YAAAY,GAAY,KAAAC,GAAK,aAAAF,EAAA;AAAA,MAC/B;AAAA,QACE,UAAUD,EAAa,YAAYE,GAAYD,CAAW;AAAA,QAC1D,YAAAG;AAAA,QACA,YAAY;AAAA,QACZ,mBAAmB;AAAA,MAAA;AAAA,IACrB,GAGF,KAAK,OAAO,gBACZ,KAAK,aAAaF,GAClB,KAAK,MAAMC,GACX,KAAK,cAAcF,GAEnB,OAAO,eAAe,MAAMD,EAAa,SAAS;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAe,YAAYE,GAAqBD,GAAyC;AACvF,WAAIA,MAAgB,aAAaA,MAAgB,eACxC,KAGLC,IAEKA,KAAc,OAAOA,MAAe,OAAOA,MAAe,MAG5D;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAe,cAAcA,GAAqBD,GAAwC;AACxF,WAAIC,MAAe,MAAY,MAC3BD,MAAgB,YAAkB,MAClCC,KAAcA,KAAc,MAAY,MACrC;AAAA,EACT;AACF;AAKO,MAAMG,UAA4BjB,EAAe;AAAA,EAItD,YACExC,GACA0D,GACAhB,GACA;AACA;AAAA,MACE1C;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE,GAAG0C,GAAS,UAAAgB,EAAA;AAAA,MACd;AAAA,QACE,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,mBAAmB;AAAA,QACnB,oBAAoB;AAAA,QACpB,kBAAkBD,EAAoB,oBAAoBC,CAAQ;AAAA,MAAA;AAAA,IACpE,GAGF,KAAK,OAAO,uBACZ,KAAK,WAAWA,GAEhB,OAAO,eAAe,MAAMD,EAAoB,SAAS;AAAA,EAC3D;AAAA,EAEA,OAAe,oBAAoBC,GAAmC;AACpE,YAAQA,GAAA;AAAA,MACN,KAAK;AACH,eAAO,CAAC,oCAAoC,8BAA8B;AAAA,MAC5E,KAAK;AACH,eAAO,CAAC,qBAAqB,mCAAmC;AAAA,MAClE,KAAK;AACH,eAAO,CAAC,2BAA2B,6BAA6B;AAAA,MAClE,KAAK;AACH,eAAO,CAAC,kCAAkC,wBAAwB;AAAA,MACpE;AACE,eAAO,CAAC,oCAAoC;AAAA,IAAA;AAAA,EAElD;AACF;AAKO,MAAMC,UAA2BnB,EAAe;AAAA,EAUrD,YACExC,GACA4D,GACAC,GACAC,GACApB,GACA;AACA;AAAA,MACE1C;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE,GAAG0C,GAAS,eAAAkB,GAAe,eAAAC,GAAe,aAAAC,EAAA;AAAA,MAC5C;AAAA,QACE,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,mBAAmB;AAAA,QACnB,oBAAoB;AAAA,QACpB,kBAAkB;AAAA,UAChB,uBAAuBF,CAAa;AAAA,UACpCC,IAAgB,cAAcA,CAAa,KAAK;AAAA,QAAA;AAAA,MAClD;AAAA,IACF,GAGF,KAAK,OAAO,sBACZ,KAAK,gBAAgBD,GACrB,KAAK,gBAAgBC,GACrB,KAAK,cAAcC,GAEnB,OAAO,eAAe,MAAMH,EAAmB,SAAS;AAAA,EAC1D;AACF;AAKO,MAAMI,UAAwBvB,EAAe;AAAA,EAOlD,YACExC,GACAgE,GACAC,GACAvB,GACA;AACA;AAAA,MACE1C;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE,GAAG0C,GAAS,WAAAsB,GAAW,gBAAAC,EAAA;AAAA,MACzB;AAAA,QACE,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,mBAAmB;AAAA,QACnB,oBAAoB;AAAA,QACpB,kBAAkB,CAAC,mBAAmBD,CAAS,uBAAuBC,CAAc,EAAE;AAAA,MAAA;AAAA,IACxF,GAGF,KAAK,OAAO,mBACZ,KAAK,YAAYD,GACjB,KAAK,iBAAiBC,GAEtB,OAAO,eAAe,MAAMF,EAAgB,SAAS;AAAA,EACvD;AACF;AAKO,MAAMG,UAA2B1B,EAAe;AAAA,EAarD,YACExC,GACAmE,GACAC,GACAC,GACAC,GACA5B,GACA;AACA,UAAMc,IAAac,IAAYA,EAAU,YAAY,KAAK,QAAQ;AAElE;AAAA,MACEtE;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE,GAAG0C,GAAS,WAAAyB,GAAW,cAAAC,GAAc,UAAAC,GAAU,WAAAC,EAAA;AAAA,MACjD;AAAA,QACE,UAAU;AAAA,QACV,YAAY,KAAK,IAAId,GAAY,CAAC;AAAA,QAClC,YAAY;AAAA,QACZ,mBAAmBW,MAAc;AAAA,QACjC,kBAAkBD,EAAmB,oBAAoBC,GAAWG,CAAS;AAAA,MAAA;AAAA,IAC/E,GAGF,KAAK,OAAO,sBACZ,KAAK,YAAYH,GACjB,KAAK,eAAeC,GACpB,KAAK,WAAWC,GAChB,KAAK,YAAYC,GAEjB,OAAO,eAAe,MAAMJ,EAAmB,SAAS;AAAA,EAC1D;AAAA,EAEA,OAAe,oBAAoBC,GAAsBG,GAA4B;AACnF,UAAMC,IAAU,CAAC,mBAAmBJ,CAAS,EAAE;AAM/C,YAJIG,KACFC,EAAQ,KAAK,wBAAwBD,EAAU,eAAA,CAAgB,EAAE,GAG3DH,GAAA;AAAA,MACN,KAAK;AACH,QAAAI,EAAQ,KAAK,+CAA+C;AAC5D;AAAA,MACF,KAAK;AACH,QAAAA,EAAQ,KAAK,+CAA+C;AAC5D;AAAA,MACF,KAAK;AACH,QAAAA,EAAQ,KAAK,6CAA6C;AAC1D;AAAA,MACF,KAAK;AACH,QAAAA,EAAQ,KAAK,uCAAuC;AACpD;AAAA,IAAA;AAGJ,WAAOA;AAAA,EACT;AACF;AAKO,MAAMC,UAAqBhC,EAAe;AAAA,EAO/C,YACExC,GACAyE,GACAC,GACAhC,GACA;AACA;AAAA,MACE1C;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE,GAAG0C,GAAS,WAAA+B,GAAW,WAAAC,EAAA;AAAA,MACzB;AAAA,QACE,UAAU;AAAA,QACV,YAAY,KAAK,IAAID,IAAY,KAAK,GAAI;AAAA;AAAA,QAC1C,YAAY;AAAA,QACZ,mBAAmB;AAAA,QACnB,kBAAkB;AAAA,UAChB;AAAA,UACA;AAAA,UACA;AAAA,QAAA;AAAA,MACF;AAAA,IACF,GAGF,KAAK,OAAO,gBACZ,KAAK,YAAYA,GACjB,KAAK,YAAYC,GAEjB,OAAO,eAAe,MAAMF,EAAa,SAAS;AAAA,EACpD;AACF;AAKO,MAAMG,UAAmBnC,EAAe;AAAA,EAO7C,YACExC,GACA4E,GACAC,GACAnC,GACA;AACA;AAAA,MACE1C;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE,GAAG0C,GAAS,gBAAAkC,GAAgB,UAAAC,EAAA;AAAA,MAC9B;AAAA,QACE,UAAUD,MAAmB;AAAA;AAAA,QAC7B,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,mBAAmB;AAAA;AAAA,MAAA;AAAA,IACrB,GAGF,KAAK,OAAO,cACZ,KAAK,iBAAiBA,GACtB,KAAK,WAAWC,GAEhB,OAAO,eAAe,MAAMF,EAAW,SAAS;AAAA,EAClD;AACF;AAKO,MAAMvE,UAAoBoC,EAAe;AAAA,EAO9C,YACExC,GACA8E,GACAC,GACArC,GACA;AACA;AAAA,MACE1C;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE,GAAG0C,GAAS,iBAAAoC,GAAiB,UAAAC,EAAA;AAAA,MAC/B;AAAA,QACE,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,mBAAmB;AAAA,QACnB,kBAAkB;AAAA,UAChB;AAAA,UACA;AAAA,QAAA;AAAA,MACF;AAAA,IACF,GAGF,KAAK,OAAO,eACZ,KAAK,WAAWA,GAChB,KAAK,kBAAkBD,GAEvB,OAAO,eAAe,MAAM1E,EAAY,SAAS;AAAA,EACnD;AACF;AC1aO,MAAe4E,EAAmD;AAAA,EAUvE,YACEnD,GACAoD,GACAC,IAAuB,IACvBC,IAAwB,KACxB;AATF,SAAU,WAAW,IAUnB,KAAK,OAAOtD,GACZ,KAAK,aAAaoD,GAClB,KAAK,eAAeC,GACpB,KAAK,gBAAgBC,GAErB,KAAK,UAAU;AAAA,MACb,iBAAiB;AAAA,MACjB,uBAAuB;AAAA,MACvB,YAAY;AAAA,MACZ,sCAAsB,KAAA;AAAA,IAAK;AAAA,EAE/B;AAAA,EAEA,IAAW,UAAmB;AAC5B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,eAAexE,GAAmD;AACvE,UAAMyE,IAAmB,CAAA,GACnBC,IAAqB,CAAA,GACrBC,IAAwB,CAAA;AAG9B,WAAI,CAAC3E,EAAO,YAAY,CAACA,EAAO,mBAC9ByE,EAAO,KAAK,2BAA2B,GAGrCzE,EAAO,WAAWA,EAAO,UAAU,QACrC0E,EAAS,KAAK,wDAAwD,GACtEC,EAAY,KAAK,gDAAgD,IAG/D3E,EAAO,aAAaA,EAAO,YAAY,KAAK,iBAC9CyE,EAAO,KAAK,cAAczE,EAAO,SAAS,oBAAoB,KAAK,YAAY,EAAE,GACjF2E,EAAY,KAAK,qBAAqB,KAAK,YAAY,UAAU,IAG5D;AAAA,MACL,SAASF,EAAO,WAAW;AAAA,MAC3B,QAAAA;AAAA,MACA,UAAAC;AAAA,MACA,aAAAC;AAAA,IAAA;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,aAAaC,GAAoB;AACzC,QAAI,CAACA,KAAQ,OAAOA,KAAS;AAC3B,YAAM,IAAI/C,EAAe,uCAAuC;AAGlE,QAAI+C,EAAK,OAAO,WAAW;AACzB,YAAM,IAAI/C,EAAe,+CAA+C;AAI1E,UAAMgD,IAAkBD,EAAK,SAAS;AACtC,QAAIC,IAAkB,KAAK;AACzB,YAAM,IAAIhD;AAAA,QACR,mBAAmB,KAAK,MAAMgD,CAAe,CAAC,iBAAiB,KAAK,aAAa;AAAA,MAAA;AAAA,EAGvF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,cAAcC,GAAuB;AAC7C,QAAI,CAAC,MAAM,QAAQA,CAAK;AACtB,YAAM,IAAIjD,EAAe,mCAAmC;AAG9D,QAAIiD,EAAM,WAAW;AACnB,YAAM,IAAIjD,EAAe,uBAAuB;AAGlD,QAAIiD,EAAM,SAAS,KAAK;AACtB,YAAM,IAAIjD;AAAA,QACR,cAAciD,EAAM,MAAM,oBAAoB,KAAK,YAAY;AAAA,MAAA;AAKnE,IAAAA,EAAM,QAAQ,CAACF,GAAMG,MAAU;AAC7B,UAAI;AACF,aAAK,aAAaH,CAAI;AAAA,MACxB,SAASxE,GAAO;AACd,cAAM,IAAIyB;AAAA,UACR,yBAAyBkD,CAAK,KAAK3E,aAAiB,QAAQA,EAAM,UAAU,eAAe;AAAA,QAAA;AAAA,MAE/F;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASU,cAAc4E,GAAwBC,IAAyB,GAAGC,IAAmB,IAAa;AAC1G,QAAIA,GAAS;AACX,WAAK,QAAQ,cAAc;AAC3B;AAAA,IACF;AAEA,UAAMC,IAAY,KAAK,QAAQ,wBAAwB,KAAK,QAAQ;AACpE,SAAK,QAAQ,mBAAmBF,GAChC,KAAK,QAAQ,yBAAyBE,IAAYH,KAAkB,KAAK,QAAQ;AAAA,EACnF;AAAA;AAAA;AAAA;AAAA,EAKO,eAAqB;AAC1B,SAAK,UAAU;AAAA,MACb,iBAAiB;AAAA,MACjB,uBAAuB;AAAA,MACvB,YAAY;AAAA,MACZ,sCAAsB,KAAA;AAAA,IAAK;AAAA,EAE/B;AAAA,EAEO,aAA8B;AACnC,WAAO,EAAE,GAAG,KAAK,QAAA;AAAA,EACnB;AAQF;AAiEO,MAAMI,EAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOzB,OAAO,mBAAmBC,GAAuC;AAC/D,QAAIC,IAAO;AACX,aAAS,IAAI,GAAG,IAAID,EAAU,QAAQ;AACpC,MAAAC,KAAQD,EAAU,CAAC,IAAIA,EAAU,CAAC;AAIpC,QAFAC,IAAO,KAAK,KAAKA,CAAI,GAEjBA,MAAS;AACX,YAAM,IAAIzD,EAAe,8BAA8B;AAGzD,UAAM0D,IAAa,IAAI,aAAaF,EAAU,MAAM;AACpD,aAAS,IAAI,GAAG,IAAIA,EAAU,QAAQ;AACpC,MAAAE,EAAW,CAAC,IAAIF,EAAU,CAAC,IAAIC;AAGjC,WAAOC;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,eAAeC,GAAiBC,GAAyB;AAC9D,QAAID,EAAE,WAAWC,EAAE;AACjB,YAAM,IAAI5D,EAAe,uCAAuC;AAGlE,QAAI6D,IAAa,GACbC,IAAQ,GACRC,IAAQ;AAEZ,aAASC,IAAI,GAAGA,IAAIL,EAAE,QAAQK;AAC5B,MAAAH,KAAcF,EAAEK,CAAC,IAAIJ,EAAEI,CAAC,GACxBF,KAASH,EAAEK,CAAC,IAAIL,EAAEK,CAAC,GACnBD,KAASH,EAAEI,CAAC,IAAIJ,EAAEI,CAAC;AAMrB,WAHAF,IAAQ,KAAK,KAAKA,CAAK,GACvBC,IAAQ,KAAK,KAAKA,CAAK,GAEnBD,MAAU,KAAKC,MAAU,IACpB,IAIF,IADkBF,KAAcC,IAAQC;AAAA,EAEjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,sBAAsBtB,GAAoBwB,IAAqB,IAAoB;AACxF,UAAMT,IAAY,IAAI,aAAaf,CAAU;AAC7C,aAAS,IAAI,GAAG,IAAIA,GAAY;AAC9B,MAAAe,EAAU,CAAC,IAAI,KAAK,OAAA,IAAW,IAAI;AAGrC,WAAOS,IAAY,KAAK,mBAAmBT,CAAS,IAAIA;AAAA,EAC1D;AACF;AChYO,MAAeU,UAAyB1B,EAAsB;AAAA,EAgBnE,YACEnD,GACAoD,GACAC,IAAuB,IACvBC,IAAwB,MACxB;AACA,UAAMtD,GAAMoD,GAAYC,GAAcC,CAAa,GAnBrD,KAAU,eAAkC,CAAA,GAC5C,KAAU,oBAAoB,IAC9B,KAAU,kBAAkB,GAC5B,KAAU,kCAAkB,IAAA;AAAA,EAiB5B;AAAA,EAdA,OAAA;AAAA,SAAwB,iBAAiB;AAAA,MACvC,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,iBAAiB;AAAA,MACjB,mBAAmB;AAAA,IAAA;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAcA,MAAa,WAAWxE,GAAwC;AAE9D,UAAMgG,IAAa,KAAK,eAAehG,CAAM;AAC7C,QAAI,CAACgG,EAAW;AACd,YAAM,IAAI/D;AAAA,QACR,oCAAoC+D,EAAW,OAAO,KAAK,IAAI,CAAC;AAAA,QAChE,KAAK;AAAA,QACL;AAAA,MAAA;AAKJ,QAAI,CAAChG,EAAO;AACV,YAAM,IAAI8C;AAAA,QACR;AAAA,QACA;AAAA,QACA,EAAE,UAAU,KAAK,KAAA;AAAA,MAAK;AAK1B,SAAK,SAAS;AAAA,MACZ,GAAGiD,EAAiB;AAAA,MACpB,GAAG/F;AAAA,MACH,QAAQA,EAAO;AAAA,MACf,SAAUA,EAAe,iBAAiB;AAAA,MAC1C,SAAUA,EAAe,WAAW+F,EAAiB,eAAe;AAAA,MACpE,YAAa/F,EAAe,cAAc+F,EAAiB,eAAe;AAAA,MAC1E,iBAAkB/F,EAAe,iBAAiB,mBAAmB+F,EAAiB,eAAe;AAAA,MACrG,mBAAoB/F,EAAe,iBAAiB,qBAAqB+F,EAAiB,eAAe;AAAA,MACzG,SAAU/F,EAAe,iBAAiB,WAAW,CAAA;AAAA,IAAC,GAIpD,KAAK,QAAQ,mBACf,KAAK,oBAAA,GAIP,MAAM,KAAK,mBAAmB,KAAK,MAAO;AAG1C,UAAMiG,IAAS,MAAM,KAAK,YAAA;AAC1B,QAAI,CAACA,EAAO;AACV,YAAM,IAAIhE;AAAA,QACR,iCAAiCgE,EAAO,OAAO;AAAA,QAC/C,KAAK;AAAA,QACL;AAAA,MAAA;AAIJ,SAAK,WAAW;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,kBAAkBrB,GAAqC;AAClE,SAAK,aAAaA,CAAI;AAEtB,UAAMhE,IAAY,KAAK,IAAA;AACvB,QAAIsF,IAA0B;AAE9B,UAAMC,IAAa,KAAK,QAAQ,cAAc;AAE9C,aAASC,IAAU,GAAGA,KAAWD,GAAYC;AAC3C,UAAI;AAEF,cAAM,KAAK,iBAAA;AAGX,cAAMf,IAAY,MAAM,KAAK,wBAAwB,CAACT,CAAI,CAAC,GAGrDI,IAAiB,KAAK,IAAA,IAAQpE;AACpC,oBAAK,cAAcoE,GAAgB,GAAG,EAAK,GAC3C,KAAK,iBAAiB,GAAG,EAAI,GAEtBK,EAAU,CAAC;AAAA,MAEpB,SAASjF,GAAO;AAId,YAHA8F,IAAY9F,GAGRgG,IAAUD,KAAc,KAAK,YAAY/F,CAAc,GAAG;AAC5D,gBAAMiG,IAAQ,KAAK,oBAAoBD,GAAShG,CAAc;AAC9D,gBAAM,KAAK,MAAMiG,CAAK;AACtB;AAAA,QACF;AAGA,mBAAK,cAAc,KAAK,IAAA,IAAQzF,GAAW,GAAG,EAAI,GAClD,KAAK,iBAAiB,GAAG,EAAK,GACxB,KAAK,UAAUR,CAAc;AAAA,MACrC;AAIF,UAAM,KAAK,UAAU8F,KAAa,IAAI,MAAM,2CAA2C,CAAC;AAAA,EAC1F;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,cAAcpB,GAA0C;AACnE,SAAK,cAAcA,CAAK;AAExB,UAAMlE,IAAY,KAAK,IAAA;AACvB,QAAIsF,IAA0B;AAE9B,UAAMC,IAAa,KAAK,QAAQ,cAAc;AAE9C,aAASC,IAAU,GAAGA,KAAWD,GAAYC;AAC3C,UAAI;AAEF,cAAM,KAAK,iBAAA;AAGX,cAAME,IAAa,MAAM,KAAK,wBAAwBxB,CAAK,GAGrDE,IAAiB,KAAK,IAAA,IAAQpE;AACpC,oBAAK,cAAcoE,GAAgBF,EAAM,QAAQ,EAAK,GACtD,KAAK,iBAAiB,GAAG,EAAI,GAEtBwB;AAAA,MAET,SAASlG,GAAO;AAId,YAHA8F,IAAY9F,GAGRgG,IAAUD,KAAc,KAAK,YAAY/F,CAAc,GAAG;AAC5D,gBAAMiG,IAAQ,KAAK,oBAAoBD,GAAShG,CAAc;AAC9D,gBAAM,KAAK,MAAMiG,CAAK;AACtB;AAAA,QACF;AAGA,mBAAK,cAAc,KAAK,IAAA,IAAQzF,GAAW,GAAG,EAAI,GAClD,KAAK,iBAAiB,GAAG,EAAK,GACxB,KAAK,UAAUR,CAAc;AAAA,MACrC;AAIF,UAAM,KAAK,UAAU8F,KAAa,IAAI,MAAM,iDAAiD,CAAC;AAAA,EAChG;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,cAA6C;AACxD,QAAI;AAEF,UAAI,CAAC,KAAK;AACR,eAAO;AAAA,UACL,WAAW;AAAA,UACX,QAAQ;AAAA,UACR,SAAS;AAAA,UACT,kBAAkB;AAAA,QAAA;AAKtB,YAAMK,IAAY,MAAM,KAAK,oBAAA;AAE7B,aAAO;AAAA,QACL,WAAAA;AAAA,QACA,QAAQA,IAAY,UAAU;AAAA,QAC9B,yBAAyB,KAAK,2BAAA;AAAA,QAC9B,kBAAkBA,IAAY,cAAc;AAAA,QAC5C,SAASA,IAAY,wBAAwB;AAAA,MAAA;AAAA,IAGjD,SAASnG,GAAO;AACd,aAAO;AAAA,QACL,WAAW;AAAA,QACX,QAAQ;AAAA,QACR,SAASA,aAAiB,QAAQA,EAAM,UAAU;AAAA,QAClD,kBAAkB;AAAA,MAAA;AAAA,IAEtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,aAA8B;AAGnC,WAAO;AAAA,MACL,GAHkB,MAAM,WAAA;AAAA,MAIxB,iBAAiB,KAAK,mBAAA;AAAA,MACtB,iBAAiB,KAAK,gBAAgB;AAAA,QACpC,WAAW,KAAK,cAAc;AAAA,QAC9B,WAAW,KAAK,cAAc;AAAA,MAAA,IAC5B;AAAA,IAAA;AAAA,EAER;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,UAAyB;AAEpC,SAAK,eAAe,CAAA,GACpB,KAAK,oBAAoB,IAGzB,KAAK,YAAY,MAAA,GAGjB,KAAK,WAAW,IAGhB,MAAM,KAAK,gBAAA;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA,EA6BQ,sBAA4B;AAClC,UAAMoG,IAAoB,KAAK,QAAQ,qBAAqB;AAC5D,SAAK,gBAAgB;AAAA,MACnB,WAAWA;AAAA,MACX,WAAW,IAAI,KAAK,KAAK,IAAA,IAAQ,GAAK;AAAA;AAAA,MACtC,OAAOA;AAAA,IAAA;AAAA,EAEX;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,mBAAkC;AAC9C,QAAI,GAAC,KAAK,QAAQ,mBAAmB,CAAC,KAAK,gBAW3C;AAAA,UANI,KAAK,SAAS,KAAK,cAAc,UAAU,cAC7C,KAAK,cAAc,YAAY,KAAK,cAAc,OAClD,KAAK,cAAc,YAAY,IAAI,KAAK,KAAK,IAAA,IAAQ,GAAK,IAIxD,KAAK,cAAc,aAAa,GAAG;AACrC,cAAMC,IAAW,KAAK,cAAc,UAAU,QAAA,IAAY,KAAK,IAAA;AAC/D,QAAIA,IAAW,MACb,MAAM,KAAK,MAAMA,CAAQ,GAEzB,KAAK,cAAc,YAAY,KAAK,cAAc,OAClD,KAAK,cAAc,YAAY,IAAI,KAAK,KAAK,IAAA,IAAQ,GAAK;AAAA,MAE9D;AAGA,WAAK,cAAc;AAAA;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAYrG,GAAuB;AAOzC,WALIA,aAAiB0C,KAKjB1C,aAAiByB,KAAkBzB,EAAM,aAAa,kBACjD,KAILA,aAAiBqC,IACZrC,EAAM,cAAc,YAAY,KAIrCA,aAAiBmD,KAKjBnD,aAAiByD;AAAA,EAMvB;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoBuC,GAAiBhG,GAAsB;AAEjE,QAAIsG,IAAY;AAGhB,QAAItG,aAAiBmD,KAAsBnD,EAAM;AAE/C,aAAO,KAAK,IAAIA,EAAM,UAAU,YAAY,KAAK,IAAA,GAAO,CAAC;AAG3D,IAAIA,aAAiBqC,MACnBiE,IAAYtG,EAAM,cAAc,cAAc,MAG5CA,aAAiByD,MACnB6C,IAAY,KAAK,IAAItG,EAAM,YAAY,KAAK,GAAI;AAIlD,UAAMuG,IAAmB,KAAK,IAAI,GAAGP,IAAU,CAAC,IAAIM,GAC9CE,IAAS,KAAK,OAAA,IAAW;AAE/B,WAAO,KAAK,IAAID,IAAmBC,GAAQ,GAAK;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAKQ,UAAUxG,GAA8B;AAC9C,WAAIA,aAAiByB,IACZzB,IAILA,EAAM,QAAQ,SAAS,KAAK,KAAKA,EAAM,QAAQ,SAAS,cAAc,IACjE,IAAI0C;AAAA,MACT;AAAA,MACA;AAAA,MACA,EAAE,UAAU,KAAK,MAAM,eAAe1C,EAAM,QAAA;AAAA,IAAQ,IAIpDA,EAAM,QAAQ,SAAS,KAAK,KAAKA,EAAM,QAAQ,SAAS,YAAY,IAC/D,IAAImD;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK,eAAe,SAAS;AAAA,MAC7B,KAAK,eAAe;AAAA,MACpB,EAAE,UAAU,KAAK,MAAM,eAAenD,EAAM,QAAA;AAAA,IAAQ,IAIpDA,EAAM,QAAQ,SAAS,SAAS,KAAKA,EAAM,SAAS,iBAC/C,IAAIyD;AAAA,MACT;AAAA,MACA,KAAK,QAAQ,WAAW;AAAA,MACxB;AAAA,MACA,EAAE,UAAU,KAAK,MAAM,eAAezD,EAAM,QAAA;AAAA,IAAQ,IAKpDA,EAAM,QAAQ,SAAS,OAAO,KAAKA,EAAM,QAAQ,SAAS,SAAS,IAC9D,IAAIqC;AAAA,MACTrC,EAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE,UAAU,KAAK,KAAA;AAAA,IAAK,IAKnB,IAAI6B;AAAA,MACT7B,EAAM;AAAA,MACN,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA,EAAE,eAAeA,EAAM,SAAS,OAAOA,EAAM,MAAA;AAAA,IAAM;AAAA,EAEvD;AAAA;AAAA;AAAA;AAAA,EAKQ,iBAAiByG,GAAsBC,GAAwB;AACrE,IAAK,KAAK,QAAQ,oBAChB,KAAK,QAAQ,kBAAkB,IAEjC,KAAK,QAAQ,mBAAmBD,GAE5BC,MACD,KAAK,QAAgB,0BAA0B,oBAAI,KAAA;AAAA,EAExD;AAAA;AAAA;AAAA;AAAA,EAKQ,qBAA6B;AACnC,WAAO,KAAK,QAAQ,mBAAmB;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKQ,6BAA+C;AACrD,WAAQ,KAAK,QAAgB;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKQ,MAAMC,GAA2B;AACvC,WAAO,IAAI,QAAQ,CAAAtG,MAAW,WAAWA,GAASsG,CAAE,CAAC;AAAA,EACvD;AACF;ACpfA,MAAMC,IAAgB;AAAA,EACpB,0BAA0B;AAAA,IACxB,MAAM;AAAA,IACN,gBAAgB;AAAA,IAChB,mBAAmB;AAAA,IACnB,qBAAqB,CAAC,KAAK,KAAK,IAAI;AAAA,IACpC,iBAAiB;AAAA;AAAA,EAAA;AAAA,EAEnB,0BAA0B;AAAA,IACxB,MAAM;AAAA,IACN,gBAAgB;AAAA,IAChB,mBAAmB;AAAA,IACnB,qBAAqB,CAAC,KAAK,KAAK,MAAM,IAAI;AAAA,IAC1C,iBAAiB;AAAA;AAAA,EAAA;AAAA,EAEnB,0BAA0B;AAAA,IACxB,MAAM;AAAA,IACN,gBAAgB;AAAA,IAChB,mBAAmB;AAAA,IACnB,qBAAqB,CAAC,IAAI;AAAA,IAC1B,iBAAiB;AAAA;AAAA,EAAA;AAErB;AA6DO,MAAMC,UAAuBlB,EAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYnD,YACEzB,GACA4C,IAAgB,0BAChB;AAEA,QAAI,EAAEA,KAASF;AACb,YAAM,IAAIhE;AAAA,QACR,6BAA6BkE,CAAK;AAAA,QAClC;AAAA,QACA,WAAW,OAAO,KAAKF,CAAa,EAAE,KAAK,IAAI,CAAC;AAAA,QAChDE;AAAA,MAAA;AAIJ,UAAMC,IAAYH,EAAcE,CAAmC;AAGnE,QAAI,CAAEC,EAAU,oBAA0C,SAAS7C,CAAU;AAC3E,YAAM,IAAItB;AAAA,QACR,0BAA0BsB,CAAU,cAAc4C,CAAK;AAAA,QACvD;AAAA,QACA,WAAWC,EAAU,oBAAoB,KAAK,IAAI,CAAC;AAAA,QACnD7C;AAAA,MAAA;AAIJ;AAAA,MACE;AAAA,MACAA;AAAA,MACA;AAAA;AAAA,MACA6C,EAAU,iBAAiB;AAAA;AAAA,IAAA,GAG7B,KAAK,QAAQD,GACb,KAAK,sBAAsB,CAAC,GAAGC,EAAU,mBAAmB,GAC5D,KAAK,iBAAiBA,EAAU;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAgB,mBAAmBnH,GAA+C;AAYhF,QAVA,KAAK,eAAe;AAAA,MAClB,GAAGA;AAAA,MACH,OAAO,KAAK;AAAA,MACZ,YAAY,KAAK;AAAA,MACjB,SAASA,EAAO,WAAW;AAAA,MAC3B,cAAcA,EAAO,UAAU,qBAAqB;AAAA,MACpD,MAAMA,EAAO,UAAU,aAAa;AAAA,IAAA,GAIlC,CAAC,KAAK,aAAa,OAAO,WAAW,KAAK;AAC5C,YAAM,IAAI8C;AAAA,QACR;AAAA,QACA;AAAA,QACA,EAAE,UAAU,KAAK,KAAA;AAAA,MAAK;AAK1B,QAAI;AACF,YAAM,KAAK,wBAAwB,CAAC,MAAM,CAAC;AAAA,IAC7C,SAAS1C,GAAO;AAEd,UAAIA,aAAiB0C;AACnB,cAAM1C;AAGR,cAAQ,KAAK,wCAAwCA,CAAK,EAAE;AAAA,IAC9D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAgB,wBAAwB0E,GAA0C;AAChF,QAAI,CAAC,KAAK;AACR,YAAM,IAAI7C;AAAA,QACR;AAAA,QACA,KAAK;AAAA,QACL;AAAA,MAAA;AAKJ,UAAMmF,IAAsC;AAAA,MAC1C,OAAO,KAAK,aAAa,SAAS,KAAK;AAAA,MACvC,OAAOtC;AAAA,MACP,iBAAiB;AAAA,IAAA,GAIbqC,IAAYH,EAAc,KAAK,KAAmC;AACxE,IAAI,KAAK,eAAeG,EAAU,sBAChCC,EAAY,aAAa,KAAK,aAI5B,KAAK,aAAa,SACpBA,EAAY,OAAO,KAAK,aAAa;AAIvC,UAAMC,IAAkC;AAAA,MACtC,gBAAgB;AAAA,MAChB,eAAiB,UAAU,KAAK,aAAa,MAAM;AAAA,MACnD,cAAc;AAAA,IAAA;AAIhB,IAAI,KAAK,aAAa,iBACpBA,EAAQ,qBAAqB,IAAI,KAAK,aAAa,eAIjD,KAAK,aAAa,WACpB,OAAO,OAAOA,GAAS,KAAK,aAAa,OAAO;AAGlD,UAAMzE,IAAM,GAAG,KAAK,aAAa,OAAO;AAExC,QAAI;AAEF,YAAM0E,IAAa,IAAI,gBAAA,GACjBC,IAAY,WAAW,MAAM;AACjC,QAAAD,EAAW,MAAA;AAAA,MACb,GAAG,KAAK,aAAa,OAAO,GAGtBpH,IAAW,MAAM,MAAM0C,GAAK;AAAA,QAChC,QAAQ;AAAA,QACR,SAAAyE;AAAA,QACA,MAAM,KAAK,UAAUD,CAAW;AAAA,QAChC,QAAQE,EAAW;AAAA,MAAA,CACpB;AAED,mBAAaC,CAAS;AAGtB,YAAMC,IAAe,MAAMtH,EAAS,KAAA;AAEpC,UAAI,CAACA,EAAS;AACZ,cAAM,KAAK,wBAAwBA,EAAS,QAAQsH,CAAmC;AAIzF,aAAO,KAAK,0BAA0BA,CAAuC;AAAA,IAE/E,SAASpH,GAAgB;AAEvB,YAAIA,aAAiB,SAASA,EAAM,SAAS,eACrC,IAAIqC;AAAA,QACR,yBAAyB,KAAK,aAAa,OAAO;AAAA,QAClD;AAAA,QACA;AAAA,QACAG;AAAA,MAAA,IAIAxC,aAAiB,aAAaA,EAAM,QAAQ,SAAS,OAAO,IACxD,IAAIqC;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACAG;AAAA,MAAA,IAKExC;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAgB,sBAAwC;AACtD,QAAI;AAEF,mBAAM,KAAK,wBAAwB,CAAC,cAAc,CAAC,GAC5C;AAAA,IACT,SAASA,GAAO;AACd,qBAAQ,KAAK,wCAAwCA,CAAK,EAAE,GACrD;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAgB,kBAAiC;AAE/C,SAAK,eAAe;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,qBAAqB;AACjC,WAAO,OAAO,QAAQ4G,CAAa,EAAE,IAAI,CAAC,CAACrG,GAAI8G,CAAI,OAAO;AAAA,MACxD,IAAA9G;AAAA,MACA,MAAM8G,EAAK;AAAA,MACX,aAAa,UAAUA,EAAK,IAAI;AAAA,MAChC,YAAYA,EAAK;AAAA,MACjB,qBAAqBA,EAAK;AAAA,MAC1B,gBAAgBA,EAAK;AAAA,MACrB,WAAW,CAAC,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,IAAI;AAAA,MACtE,UAAU,CAAC,mBAAmB,kBAAkB,cAAc,YAAY;AAAA,MAC1E,cAAcA,EAAK,kBAAkB;AAAA,IAAA,EACrC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKQ,wBAAwBC,GAAgBC,GAAuC;AACrF,UAAMC,IAAeD,EAAU,OAAO,WAAW,4BAC3CE,IAAYF,EAAU,OAAO,QAAQ,WACrCG,IAAYH,EAAU,OAAO,QAAQ;AAE3C,YAAQD,GAAA;AAAA,MACN,KAAK;AACH,eAAO,IAAI5E;AAAA,UACT,qCAAqC8E,CAAY;AAAA,UACjD;AAAA,UACA,EAAE,UAAU,KAAK,MAAM,WAAAC,GAAW,WAAAC,EAAA;AAAA,QAAU;AAAA,MAGhD,KAAK;AAEH,eAAIF,EAAa,SAAS,OAAO,KAAKA,EAAa,SAAS,SAAS,IAC5D,IAAIrE;AAAA,UACT,8BAA8BqE,CAAY;AAAA,UAC1C;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,EAAE,UAAU,KAAK,MAAM,WAAAC,GAAW,WAAAC,EAAA;AAAA,QAAU,IAGvC,IAAIvE;AAAA,UACT,mCAAmCqE,CAAY;AAAA,UAC/C;AAAA,UACA;AAAA,UACA;AAAA,UACA,IAAI,KAAK,KAAK,IAAA,IAAQ,GAAK;AAAA;AAAA,UAC3B,EAAE,UAAU,KAAK,MAAM,WAAAC,GAAW,WAAAC,EAAA;AAAA,QAAU;AAAA,MAIlD,KAAK;AACH,eAAIF,EAAa,SAAS,YAAY,KAAKA,EAAa,SAAS,OAAO,IAC/D,IAAI5E;AAAA,UACT,mCAAmC4E,CAAY;AAAA,UAC/CD,EAAU,OAAO,SAAS;AAAA,UAC1B;AAAA,UACA;AAAA,UACA,EAAE,UAAU,KAAK,MAAM,WAAAE,GAAW,WAAAC,EAAA;AAAA,QAAU,IAGvC,IAAI1E;AAAA,UACT,gCAAgCwE,CAAY;AAAA,UAC5CD,EAAU,OAAO,SAAS;AAAA,UAC1B;AAAA,UACA,EAAE,UAAU,KAAK,MAAM,WAAAE,GAAW,WAAAC,EAAA;AAAA,QAAU;AAAA,MAIlD,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,eAAO,IAAIrF;AAAA,UACT,4BAA4BmF,CAAY;AAAA,UACxC;AAAA,UACAF;AAAA,UACA;AAAA,UACA,EAAE,UAAU,KAAK,MAAM,WAAAG,GAAW,WAAAC,EAAA;AAAA,QAAU;AAAA,MAGhD;AACE,eAAO,IAAI7F;AAAA,UACT,qBAAqByF,CAAM,MAAME,CAAY;AAAA,UAC7C,KAAK;AAAA,UACL;AAAA,UACA;AAAA,UACA,EAAE,QAAAF,GAAQ,WAAAG,GAAW,WAAAC,EAAA;AAAA,QAAU;AAAA,IACjC;AAAA,EAEN;AAAA;AAAA;AAAA;AAAA,EAKQ,0BAA0B5H,GAAmD;AACnF,QAAI,CAACA,EAAS,QAAQ,CAAC,MAAM,QAAQA,EAAS,IAAI;AAChD,YAAM,IAAI+B;AAAA,QACR;AAAA,QACA,KAAK;AAAA,QACL;AAAA,MAAA;AAOJ,WAFmB/B,EAAS,KAAK,KAAK,CAACsF,GAAGC,MAAMD,EAAE,QAAQC,EAAE,KAAK,EAE/C,IAAI,CAACsC,GAAMhD,MAAU;AACrC,UAAI,CAACgD,EAAK,aAAa,CAAC,MAAM,QAAQA,EAAK,SAAS;AAClD,cAAM,IAAI9F;AAAA,UACR,qCAAqC8C,CAAK;AAAA,UAC1C,KAAK;AAAA,UACL;AAAA,QAAA;AAKJ,UAAIgD,EAAK,UAAU,WAAW,KAAK;AACjC,cAAM,IAAI9F;AAAA,UACR,0CAA0C,KAAK,UAAU,SAAS8F,EAAK,UAAU,MAAM;AAAA,UACvF,KAAK;AAAA,UACL;AAAA,QAAA;AAKJ,aAAO,IAAI,aAAaA,EAAK,SAAS;AAAA,IACxC,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKO,eAAe/H,GAAyB;AAC7C,UAAMgI,IAAiB,MAAM,eAAehI,CAAM,GAG5CyE,IAAS,CAAC,GAAGuD,EAAe,MAAM,GAClCtD,IAAW,CAAC,GAAGsD,EAAe,QAAQ,GACtCrD,IAAc,CAAC,GAAGqD,EAAe,WAAW;AAGlD,IAAKhI,EAAO,SAGAA,EAAO,OAAO,WAAW,KAAK,MACxC0E,EAAS,KAAK,wCAAwC,GACtDC,EAAY,KAAK,uBAAuB,MAJxCF,EAAO,KAAK,4BAA4B,GACxCE,EAAY,KAAK,6BAA6B;AAOhD,UAAMpC,IAAavC,EAAe,iBAAiB,SAAS,KAAK;AACjE,QAAIuC,KAAayE,GAAe;AAC9B,YAAMG,IAAYH,EAAczE,CAAuC;AACvE,MAAM4E,EAAU,oBAA0C,SAAS,KAAK,UAAU,MAChF1C,EAAO,KAAK,SAASlC,CAAS,qBAAqB,KAAK,UAAU,aAAa,GAC/EoC,EAAY,KAAK,eAAewC,EAAU,oBAAoB,KAAK,IAAI,CAAC,EAAE;AAAA,IAE9E;AAGA,WAAInH,EAAO,aAAaA,EAAO,YAAY,KAAK,iBAC9C0E,EAAS,KAAK,cAAc1E,EAAO,SAAS,oCAAoC,GAChF2E,EAAY,KAAK,gCAAgC,KAAK,IAAI,KAAK,cAAc,EAAE,CAAC,UAAU,IAGrF;AAAA,MACL,SAASF,EAAO,WAAW;AAAA,MAC3B,QAAAA;AAAA,MACA,UAAAC;AAAA,MACA,aAAAC;AAAA,IAAA;AAAA,EAEJ;AACF;AAKO,SAASsD,EACd3D,GACA4C,IAAgB,0BACA;AAChB,SAAO,IAAID,EAAe3C,GAAY4C,CAAK;AAC7C;AAKO,SAASgB,EAA2BhB,GAAe5C,GAA6B;AACrF,SAAM4C,KAASF,IAIGA,EAAcE,CAAmC,EACjD,oBAA0C,SAAS5C,CAAU,IAJtE;AAKX;AAKO,SAAS6D,EACdC,GASA;AACA,QAAM,EAAE,YAAA9D,IAAa,KAAK,QAAA+D,IAAS,UAAU,aAAAC,IAAc,eAAeF;AAG1E,SAAIC,MAAW,SAASC,MAAgB,SAC/B;AAAA,IACL,OAAO;AAAA,IACP,YAAY,KAAK,IAAIhE,GAAY,GAAG;AAAA,IACpC,aAAa;AAAA,EAAA,KAIb+D,MAAW,UAAUC,MAAgB,eACnChE,KAAc,OACT;AAAA,IACL,OAAO;AAAA,IACP,YAAYA,KAAc,MAAM,MAAMA,KAAc,MAAM,MAAM;AAAA,IAChE,aAAa;AAAA,EAAA,IAMZ;AAAA,IACL,OAAO;AAAA,IACP,YAAYA,KAAc,MAAM,MAAMA,KAAc,MAAM,MAAM;AAAA,IAChE,aAAa;AAAA,EAAA;AAEjB;AChgBO,MAAMiE,UAA6BlE,EAAsB;AAAA,EA8B9D,YAAYrE,IAAqC;AAAA,IAC/C,iBAAiB;AAAA,IACjB,mBAAmB;AAAA,EAAA,GAClB;AACD;AAAA,MACE;AAAA,MACA;AAAA;AAAA,MACAA,EAAO,aAAa;AAAA;AAAA,MACpB;AAAA;AAAA,IAAA,GA9BJ,KAAQ,sCAAsB,IAAA,GAQ9B,KAAQ,iBAAiB,GAMzB,KAAQ,qBAAqB;AAAA,MAC3B,eAAe;AAAA,MACf,kBAAkB;AAAA,MAClB,cAAc;AAAA,MACd,YAAY;AAAA,MACZ,iCAAiB,KAAA;AAAA,IAAK,GActB,KAAK,SAAS;AAAA,MACZ,cAAc;AAAA,MACd,kBAAkB;AAAA;AAAA,MAClB,kBAAkB;AAAA;AAAA,MAClB,WAAW;AAAA,MACX,eAAe;AAAA,MACf,WAAW;AAAA,MACX,kBAAkB;AAAA,MAClB,GAAGA;AAAA,IAAA;AAAA,EAEP;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,WAAWA,GAAwC;AAC9D,WAAI,KAAK,wBACA,KAAK,yBAGd,KAAK,wBAAwB,KAAK,YAAYA,CAAM,GAC7C,KAAK;AAAA,EACd;AAAA,EAEA,MAAc,YAAYA,GAAwC;AAChE,QAAI;AAIF,UAHA,KAAK,SAAS,EAAE,GAAG,KAAK,QAAQ,GAAGA,EAAA,GAG/B,CAAC,OAAO;AACV,cAAM,IAAIoC;AAAA,UACR;AAAA,UACA,KAAK;AAAA,UACL;AAAA,UACA,EAAE,WAAW,UAAU,UAAA;AAAA,QAAU;AAKrC,YAAM,KAAK,aAAA;AAGX,YAAMxB,IAAY,KAAK,IAAA;AACvB,YAAM,KAAK,YAAY,cAAc;AAAA,QACnC,WAAW,KAAK,OAAO;AAAA,QACvB,aAAa,KAAK,OAAO;AAAA,QACzB,eAAe,KAAK,OAAO;AAAA,MAAA,GAC1B,KAAK,OAAO,gBAAgB,GAE/B,KAAK,mBAAmB,gBAAgB,KAAK,IAAA,IAAQA,GACrD,KAAK,WAAW,IAEZ,KAAK,OAAO,iBACd,QAAQ,IAAI,8CAA8C,KAAK,mBAAmB,aAAa,IAAI;AAAA,IAGvG,SAASR,GAAO;AAGd,YAFA,KAAK,WAAW,IAEZA,aAAiB,QACb,IAAIgC;AAAA,QACR,oDAAoDhC,EAAM,OAAO;AAAA,QACjE,KAAK;AAAA,QACLA;AAAA,QACA,EAAE,QAAQ,KAAK,OAAA;AAAA,MAAO,IAIpB,IAAIgC;AAAA,QACR;AAAA,QACA,KAAK;AAAA,QACL;AAAA,QACA,EAAE,QAAQ,KAAK,OAAA;AAAA,MAAO;AAAA,IAE1B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,eAA8B;AAC1C,QAAI;AAEF,YAAMR,IAAY,KAAK,OAAO,cAAc,WAAW,GAAG,IACtD,KAAK,OAAO,eACZ;AAEJ,WAAK,SAAS,IAAI,OAAOA,GAAW;AAAA,QAClC,MAAM;AAAA,QACN,MAAM;AAAA,MAAA,CACP,GAGD,KAAK,OAAO,YAAY,CAAC3B,MAAwC;AAC/D,aAAK,oBAAoBA,EAAM,IAAI;AAAA,MACrC,GAGA,KAAK,OAAO,UAAU,CAACG,MAAU;AAC/B,gBAAQ,MAAM,wCAAwCA,CAAK,GAC3D,KAAK,kBAAkB,IAAI,MAAM,iBAAiBA,EAAM,OAAO,EAAE,CAAC;AAAA,MACpE,GAGA,KAAK,OAAO,iBAAiB,CAACA,MAAU;AACtC,gBAAQ,MAAM,gDAAgDA,CAAK,GACnE,KAAK,kBAAkB,IAAI,MAAM,8BAA8B,CAAC;AAAA,MAClE;AAAA,IAEF,SAASA,GAAO;AACd,YAAM,IAAIX;AAAA,QACR,kCAAkCW,aAAiB,QAAQA,EAAM,UAAU,eAAe;AAAA,QAC1F;AAAA,QACA;AAAA,QACA,EAAE,cAAc,KAAK,OAAO,aAAA;AAAA,MAAa;AAAA,IAE7C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,kBAAkBwE,GAAqC;AAGlE,QAFA,KAAK,aAAaA,CAAI,GAElB,CAAC,KAAK;AACR,YAAM,IAAI3C;AAAA,QACR;AAAA,QACA,KAAK;AAAA,QACL;AAAA,MAAA;AAIJ,UAAMrB,IAAY,KAAK,IAAA;AAEvB,QAAI;AACF,YAAMV,IAAW,MAAM,KAAK,YAAY,qBAAqB;AAAA,QAC3D,MAAM0E,EAAK,KAAA;AAAA,MAAK,GACf,KAAK,OAAO,gBAAgB,GAEzBI,IAAiB,KAAK,IAAA,IAAQpE;AACpC,WAAK,cAAcoE,GAAgB,GAAG,EAAK;AAG3C,YAAMK,IAAY,IAAI,aAAanF,EAAS,SAAS;AACrD,UAAImF,EAAU,WAAW,KAAK;AAC5B,cAAM,IAAIpD;AAAA,UACR,6CAA6CoD,EAAU,MAAM,eAAe,KAAK,UAAU;AAAA,UAC3F,KAAK;AAAA,UACL;AAAA,QAAA;AAIJ,aAAOA;AAAA,IAET,SAASjF,GAAO;AACd,YAAM4E,IAAiB,KAAK,IAAA,IAAQpE;AAGpC,YAFA,KAAK,cAAcoE,GAAgB,GAAG,EAAI,GAEtC5E,aAAiB,QACbA,IAGF,IAAI6B;AAAA,QACR,gCAAgC7B,CAAK;AAAA,QACrC,KAAK;AAAA,QACL;AAAA,QACA;AAAA,QACA,EAAE,MAAMwE,EAAK,UAAU,GAAG,GAAG,IAAI,MAAA;AAAA,MAAM;AAAA,IAE3C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,cAAcE,GAA0C;AAGnE,QAFA,KAAK,cAAcA,CAAK,GAEpB,CAAC,KAAK;AACR,YAAM,IAAI7C;AAAA,QACR;AAAA,QACA,KAAK;AAAA,QACL;AAAA,MAAA;AAIJ,UAAMrB,IAAY,KAAK,IAAA;AAEvB,QAAI;AAEF,YAAM4H,IAA0B,CAAA,GAC1BC,IAAY,KAAK;AAEvB,eAAS5C,IAAI,GAAGA,IAAIf,EAAM,QAAQe,KAAK4C,GAAW;AAChD,cAAMC,IAAQ5D,EAAM,MAAMe,GAAGA,IAAI4C,CAAS,GACpCE,IAAe,MAAM,KAAK,kBAAkBD,CAAK;AACvD,QAAAF,EAAQ,KAAK,GAAGG,CAAY;AAAA,MAC9B;AAEA,YAAM3D,IAAiB,KAAK,IAAA,IAAQpE;AACpC,kBAAK,cAAcoE,GAAgBF,EAAM,QAAQ,EAAK,GAGtD,KAAK,mBAAmB,gBAAgB,GACxC,KAAK,mBAAmB,oBACrB,KAAK,mBAAmB,oBAAoB,KAAK,mBAAmB,eAAe,KAAKA,EAAM,UAC7F,KAAK,mBAAmB,cAErB0D;AAAA,IAET,SAASpI,GAAO;AACd,YAAM4E,IAAiB,KAAK,IAAA,IAAQpE;AAGpC,YAFA,KAAK,cAAcoE,GAAgBF,EAAM,QAAQ,EAAI,GAEjD1E,aAAiB,QACbA,IAGF,IAAI6B;AAAA,QACR,0CAA0C7B,CAAK;AAAA,QAC/C,KAAK;AAAA,QACL;AAAA,QACA;AAAA,QACA,EAAE,WAAW0E,EAAM,OAAA;AAAA,MAAO;AAAA,IAE9B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,kBAAkBA,GAA0C;AAKxE,YAJiB,MAAM,KAAK,YAAY,iBAAiB;AAAA,MACvD,OAAOA,EAAM,IAAI,CAAA8D,MAAKA,EAAE,MAAM;AAAA,IAAA,GAC7B,KAAK,OAAO,mBAAoB,KAAK,KAAK9D,EAAM,SAAS,CAAC,CAAC,GAE9C,WAAW,IAAI,CAAC+D,MAAqC;AACnE,YAAMxD,IAAY,IAAI,aAAawD,CAAO;AAC1C,UAAIxD,EAAU,WAAW,KAAK;AAC5B,cAAM,IAAIpD;AAAA,UACR,6CAA6CoD,EAAU,MAAM,eAAe,KAAK,UAAU;AAAA,UAC3F,KAAK;AAAA,UACL;AAAA,QAAA;AAGJ,aAAOA;AAAA,IACT,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,UAAyB;AACpC,QAAI;AAEF,iBAAW,CAAC1E,GAAImI,CAAO,KAAK,KAAK;AAC/B,QAAIA,EAAQ,WACV,aAAaA,EAAQ,OAAO,GAE9BA,EAAQ,OAAO,IAAI,MAAM,sCAAsC,CAAC;AAKlE,UAHA,KAAK,gBAAgB,MAAA,GAGjB,KAAK,UAAU,KAAK;AACtB,YAAI;AACF,gBAAM,KAAK,YAAY,WAAW,CAAA,GAAI,GAAI;AAAA,QAC5C,SAAS1I,GAAO;AAEd,kBAAQ,KAAK,2CAA2CA,CAAK;AAAA,QAC/D;AAIF,MAAI,KAAK,WACP,KAAK,OAAO,UAAA,GACZ,KAAK,SAAS,SAGhB,KAAK,WAAW,IAChB,KAAK,wBAAwB,QAC7B,KAAK,mBAAmB,cAAc,oBAAI,KAAA,GAEtC,KAAK,OAAO,iBACd,QAAQ,IAAI,yCAAyC;AAAA,IAGzD,SAASA,GAAO;AACd,YAAM,IAAI6B;AAAA,QACR,kCAAkC7B,aAAiB,QAAQA,EAAM,UAAU,eAAe;AAAA,QAC1F,KAAK;AAAA,QACL;AAAA,MAAA;AAAA,IAEJ;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,cAA6C;AACxD,QAAI;AACF,UAAI,CAAC,KAAK,UAAU,CAAC,KAAK;AACxB,eAAO;AAAA,UACL,WAAW;AAAA,UACX,QAAQ;AAAA,UACR,SAAS;AAAA,UACT,kBAAkB;AAAA,QAAA;AAKtB,YAAMQ,IAAY,KAAK,IAAA,GACjBV,IAAW,MAAM,KAAK,YAAY,eAAe,CAAA,GAAI,GAAI,GACzD6I,IAAe,KAAK,IAAA,IAAQnI;AAElC,aAAO;AAAA,QACL,WAAW;AAAA,QACX,6CAA6B,KAAA;AAAA,QAC7B,QAAQ;AAAA,QACR,SAAS,sBAAsBmI,CAAY;AAAA,QAC3C,iBAAiB7I,EAAS,YAAY;AAAA,QACtC,kBAAkB;AAAA,MAAA;AAAA,IAGtB,SAASE,GAAO;AACd,aAAO;AAAA,QACL,WAAW;AAAA,QACX,QAAQ;AAAA,QACR,SAAS,6BAA6BA,aAAiB,QAAQA,EAAM,UAAU,eAAe;AAAA,QAC9F,kBAAkB;AAAA,MAAA;AAAA,IAEtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,aAA8B;AAGnC,WAAO;AAAA,MACL,GAHkB,MAAM,WAAA;AAAA,MAIxB,aAAa,KAAK,mBAAmB;AAAA,MACrC,iBAAiB;AAAA;AAAA,MACjB,iBAAiB;AAAA;AAAA,IAAA;AAAA,EAErB;AAAA;AAAA;AAAA;AAAA,EAKO,yBAAyB;AAC9B,WAAO;AAAA,MACL,GAAG,KAAK;AAAA,MACR,eAAe,KAAK;AAAA,MACpB,cAAc,CAAC,CAAC,KAAK;AAAA,MACrB,iBAAiB,KAAK,gBAAgB;AAAA,IAAA;AAAA,EAE1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,YAAY4I,GAA6BC,GAAWnF,GAAkC;AAClG,QAAI,CAAC,KAAK;AACR,YAAM,IAAIrE,EAAY,wBAAwBuJ,CAAI;AAGpD,WAAO,IAAI,QAAQ,CAACvI,GAASC,MAAW;AACtC,YAAMC,IAAK,GAAGqI,CAAI,IAAI,EAAE,KAAK,cAAc,IAAI,KAAK,IAAA,CAAK,IACnDnI,IAAUiD,KAAa,KAAK,OAAO,oBAAoB,KAGvDoF,IAAgB,WAAW,MAAM;AACrC,aAAK,gBAAgB,OAAOvI,CAAE,GAC9BD,EAAO,IAAImD;AAAA,UACT,YAAYmF,CAAI,sBAAsBnI,CAAO;AAAA,UAC7CA;AAAA,UACAmI;AAAA,QAAA,CACD;AAAA,MACH,GAAGnI,CAAO;AAGV,WAAK,gBAAgB,IAAIF,GAAI;AAAA,QAC3B,SAAAF;AAAA,QACA,QAAAC;AAAA,QACA,WAAW,KAAK,IAAA;AAAA,QAChB,SAASwI;AAAA,MAAA,CACV;AAGD,YAAM7J,IAAyB,EAAE,IAAAsB,GAAI,MAAAqI,GAAM,MAAAC,EAAA;AAC3C,WAAK,OAAQ,YAAY5J,CAAO;AAAA,IAClC,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoBa,GAAgC;AAC1D,UAAM4I,IAAU,KAAK,gBAAgB,IAAI5I,EAAS,EAAE;AACpD,QAAI,CAAC4I,GAAS;AACZ,cAAQ,KAAK,kEAAkE5I,EAAS,EAAE,EAAE;AAC5F;AAAA,IACF;AAiBA,QAdI4I,EAAQ,WACV,aAAaA,EAAQ,OAAO,GAE9B,KAAK,gBAAgB,OAAO5I,EAAS,EAAE,GAGnCA,EAAS,UAAU,gBACrB,KAAK,mBAAmB,aAAa,KAAK;AAAA,MACxC,KAAK,mBAAmB;AAAA,MACxBA,EAAS,SAAS;AAAA,IAAA,IAKlBA,EAAS;AACX,MAAA4I,EAAQ,QAAQ5I,EAAS,IAAI;AAAA,SACxB;AACL,YAAME,IAAQ,IAAI6B;AAAA,QAChB/B,EAAS,SAAS;AAAA,QAClB,KAAK;AAAA,QACL;AAAA,MAAA;AAEF,MAAA4I,EAAQ,OAAO1I,CAAK;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkBA,GAAoB;AAE5C,eAAW,CAACO,GAAImI,CAAO,KAAK,KAAK;AAC/B,MAAIA,EAAQ,WACV,aAAaA,EAAQ,OAAO,GAE9BA,EAAQ,OAAO,IAAIrJ;AAAA,QACjB,iBAAiBW,EAAM,OAAO;AAAA,QAC9B;AAAA,QACA;AAAA,QACA,EAAE,eAAeA,EAAM,QAAA;AAAA,MAAQ,CAChC;AAEH,SAAK,gBAAgB,MAAA,GAErB,KAAK,WAAW;AAAA,EAClB;AACF;AAKO,SAAS+I,EAA2BnJ,GAA2D;AACpG,SAAO,IAAIuI,EAAqBvI,CAAM;AACxC;AAKO,SAASoJ,IAAmC;AACjD,SACE,OAAO,SAAW,OAClB,OAAO,SAAW,OAClB,OAAO,oBAAsB,OAC7B,OAAO,cAAgB;AAE3B;AAKO,SAASC,IAAe;AAC7B,SAAO;AAAA,IACL,IAAI;AAAA,IACJ,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAY;AAAA,IACZ,gBAAgB;AAAA,IAChB,WAAW,CAAC,MAAM,cAAc;AAAA,IAChC,UAAU,CAAC,uBAAuB,mBAAmB,YAAY;AAAA,IACjE,WAAW;AAAA;AAAA,IACX,UAAU;AAAA,EAAA;AAEd;ACleO,MAAMC,EAAiE;AAAA,EAI5E,cAAc;AAFd,SAAiB,uCAAuB,IAAA,GAGtC,KAAK,2BAAA;AAAA,EACP;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,eAAetJ,GAA+D;AACzF,QAAI;AAEF,YAAMgG,IAAa,KAAK,sBAAsBhG,CAAM;AACpD,UAAI,CAACgG,EAAW;AACd,cAAM,IAAIhD;AAAA,UACR,mCAAmCgD,EAAW,OAAO,KAAK,IAAI,CAAC;AAAA,UAC/D;AAAA,UACAA,EAAW,YAAY,KAAK,IAAI;AAAA,UAChChG,EAAO;AAAA,UACP;AAAA,YACE,YAAAgG;AAAA,YACA,QAAQ,EAAE,GAAGhG,GAAQ,QAAQA,EAAO,SAAS,eAAe,OAAA;AAAA,UAAU;AAAA,QACxE;AAKJ,YAAMuJ,IAAc,KAAK,qBAAqBvJ,EAAO,QAAQ;AAC7D,UAAI,CAACuJ,EAAY;AACf,cAAM,IAAInH;AAAA,UACR,YAAYpC,EAAO,QAAQ,sBAAsBuJ,EAAY,iBAAiB;AAAA,UAC9EvJ,EAAO;AAAA,UACP;AAAA,UACA;AAAA,YACE,aAAAuJ;AAAA,YACA,cAAcA,EAAY;AAAA,UAAA;AAAA,QAC5B;AAKJ,UAAIC;AAEJ,cAAQxJ,EAAO,UAAA;AAAA,QACb,KAAK;AACH,UAAAwJ,IAAW,MAAM,KAAK,2BAA2BxJ,CAAM;AACvD;AAAA,QAEF,KAAK;AACH,UAAAwJ,IAAW,MAAM,KAAK,qBAAqBxJ,CAAM;AACjD;AAAA,QAEF;AACE,gBAAM,IAAIgD;AAAA,YACR,8BAA8BhD,EAAO,QAAQ;AAAA,YAC7C;AAAA,YACA;AAAA,YACAA,EAAO;AAAA,UAAA;AAAA,MACT;AAIJ,mBAAMwJ,EAAS,WAAW;AAAA,QACxB,iBAAiBxJ,EAAO;AAAA,QACxB,mBAAmBA,EAAO;AAAA,QAC1B,QAAQA,EAAO;AAAA,QACf,WAAWA,EAAO;AAAA,QAClB,SAASA,EAAO;AAAA,QAChB,SAASA,EAAO;AAAA,QAChB,UAAUA,EAAO;AAAA,MAAA,CAClB,GAEMwJ;AAAA,IAET,SAASpJ,GAAO;AACd,YAAIA,aAAiB,SAAUA,EAAM,KAAK,SAAS,OAAO,IAClDA,IAGF,IAAIgC;AAAA,QACR,6BAA6BpC,EAAO,QAAQ,KAAKI,aAAiB,QAAQA,EAAM,UAAU,eAAe;AAAA,QACzGJ,EAAO;AAAA,QACPI,aAAiB,QAAQA,IAAQ;AAAA,QACjC,EAAE,QAAQ,EAAE,GAAGJ,GAAQ,QAAQA,EAAO,SAAS,eAAe,OAAA,EAAU;AAAA,MAAE;AAAA,IAE9E;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,eAAeA,GAA4C;AAChE,UAAMgG,IAAa,KAAK,sBAAsBhG,CAAM,GAC9CuJ,IAAc,KAAK,qBAAqBvJ,EAAO,QAAQ;AAE7D,WAAOgG,EAAW,WAAWuD,EAAY;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,qBAA2C;AACtD,UAAME,IAAsB,CAAA;AAG5B,WAAIL,OACFK,EAAO,KAAKC,GAA0B,GAIxCD,EAAO,KAAK,GAAGxC,EAAe,mBAAA,CAAoB,GAE3CwC;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,qBAAqBE,GAA2D;AAC3F,YAAQA,GAAA;AAAA,MACN,KAAK;AACH,eAAOP,MAA4B,CAACM,EAAA,CAA0B,IAAI,CAAA;AAAA,MAEpE,KAAK;AACH,eAAOzC,EAAe,mBAAA;AAAA,MAExB;AACE,eAAO,CAAA;AAAA,IAAC;AAAA,EAEd;AAAA;AAAA;AAAA;AAAA,EAKO,sBAAsBjH,GAA6D;AACxF,UAAMyE,IAAmB,CAAA,GACnBC,IAAqB,CAAA,GACrBC,IAAwB,CAAA;AAc9B,YAXK3E,EAAO,aACVyE,EAAO,KAAK,2BAA2B,GACvCE,EAAY,KAAK,8CAA8C,KAG7D,CAAC3E,EAAO,cAAcA,EAAO,cAAc,OAC7CyE,EAAO,KAAK,oCAAoC,GAChDE,EAAY,KAAK,sCAAsC,IAIjD3E,EAAO,UAAA;AAAA,MACb,KAAK;AACH,aAAK,2BAA2BA,GAAQyE,GAAQC,GAAUC,CAAW;AACrE;AAAA,MAEF,KAAK;AACH,aAAK,qBAAqB3E,GAAQyE,GAAQC,GAAUC,CAAW;AAC/D;AAAA,MAEF;AACE,QAAI3E,EAAO,aACTyE,EAAO,KAAK,yBAAyBzE,EAAO,QAAQ,EAAE,GACtD2E,EAAY,KAAK,kCAAkC;AAAA,IACrD;AAIJ,WAAI3E,EAAO,aAAaA,EAAO,YAAY,QACzC0E,EAAS,KAAK,0CAA0C,GACxDC,EAAY,KAAK,4CAA4C,IAG3D3E,EAAO,WAAWA,EAAO,UAAU,QACrC0E,EAAS,KAAK,2CAA2C,GACzDC,EAAY,KAAK,oDAAoD,IAGhE;AAAA,MACL,SAASF,EAAO,WAAW;AAAA,MAC3B,QAAAA;AAAA,MACA,UAAAC;AAAA,MACA,aAAAC;AAAA,IAAA;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA,EAKO,qBAAqBgF,GAA0D;AACpF,YAAQA,GAAA;AAAA,MACN,KAAK;AACH,eAAO,KAAK,yBAAA;AAAA,MAEd,KAAK;AACH,eAAO,KAAK,mBAAA;AAAA,MAEd;AACE,eAAO;AAAA,UACL,aAAa;AAAA,UACb,mBAAmB,0BAA0BA,CAAY;AAAA,UACzD,cAAc,CAAC,gBAAgB,QAAQ;AAAA,UACvC,cAAc,CAAC,qBAAqB;AAAA,QAAA;AAAA,IACtC;AAAA,EAEN;AAAA;AAAA;AAAA;AAAA,EAKO,gBAAgBA,GAAqE;AAC1F,WAAO,KAAK,iBAAiB,IAAIA,CAAY;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKO,wBAA8C;AACnD,WAAO,MAAM,KAAK,KAAK,iBAAiB,QAAQ;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAKO,2BAA2BvB,GAML;AAC3B,UAAMwB,IAA4C,CAAA,GAC5C,EAAE,YAAAtF,IAAa,KAAK,QAAA+D,IAAS,UAAU,aAAAC,IAAc,YAAY,SAAAuB,IAAU,MAAA,IAAUzB;AAgB3F,SAbIyB,MAAY,WAAWA,MAAY,UACjCT,EAAA,KAA6B9E,MAAe,OAC9CsF,EAAgB,KAAK;AAAA,MACnB,UAAU;AAAA,MACV,YAAY;AAAA,MACZ,QAAQ;AAAA,MACR,UAAUC,MAAY,UAAU,KAAK;AAAA,MACrC,cAAc,CAAA;AAAA,IAAC,CAChB,IAKDA,MAAY,WAAWA,MAAY,YACjCxB,MAAW,SAASC,MAAgB,WACtCsB,EAAgB,KAAK;AAAA,MACnB,UAAU;AAAA,MACV,OAAO;AAAA,MACP,YAAY,KAAK,IAAItF,GAAY,GAAG;AAAA,MACpC,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,cAAc;AAAA,QACZ;AAAA,UACE,UAAU;AAAA,UACV,OAAO;AAAA,UACP,YAAY;AAAA,UACZ,QAAQ;AAAA,QAAA;AAAA,MACV;AAAA,IACF,CACD,IAGC+D,MAAW,UAAUC,MAAgB,eACvCsB,EAAgB,KAAK;AAAA,MACnB,UAAU;AAAA,MACV,OAAO;AAAA,MACP,YAAY,KAAK,IAAItF,GAAY,IAAI;AAAA,MACrC,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,cAAc;AAAA,QACZ;AAAA,UACE,UAAU;AAAA,UACV,OAAO;AAAA,UACP,YAAY;AAAA,UACZ,QAAQ;AAAA,QAAA;AAAA,MACV;AAAA,IACF,CACD,GAICgE,MAAgB,aAAY;AAC9B,YAAMwB,IAAe3B,EAAqB,EAAE,YAAA7D,GAAY,QAAA+D,GAAQ,aAAAC,GAAa;AAC7E,MAAAsB,EAAgB,KAAK;AAAA,QACnB,UAAU;AAAA,QACV,OAAOE,EAAa;AAAA,QACpB,YAAYA,EAAa;AAAA,QACzB,QAAQA,EAAa;AAAA,QACrB,UAAU;AAAA,QACV,cAAc,CAAA;AAAA,MAAC,CAChB;AAAA,IACH;AAIF,WAAOF,EAAgB,KAAK,CAAC,GAAGnE,MAAMA,EAAE,WAAW,EAAE,QAAQ;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,2BAA2BzF,GAAkE;AACzG,QAAIA,EAAO,eAAe;AACxB,YAAM,IAAIgD;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACAhD,EAAO;AAAA,MAAA;AAIX,WAAO,IAAIuI,EAAqB;AAAA,MAC9B,iBAAiB;AAAA,MACjB,mBAAmB;AAAA,MACnB,WAAWvI,EAAO,aAAa;AAAA,MAC/B,eAAe;AAAA,MACf,kBAAkBA,EAAO,WAAW;AAAA,MACpC,kBAAkBA,EAAO,WAAW;AAAA,MACpC,kBAAkBA,EAAO,iBAAiB;AAAA,MAC1C,GAAGA,EAAO;AAAA,IAAA,CACX;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,qBAAqBA,GAA4D;AAC7F,QAAI,CAACA,EAAO;AACV,YAAM,IAAIgD;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAIJ,UAAMkE,IAAQlH,EAAO,SAAS;AAG9B,QAAI,CAACkI,EAA2BhB,GAAOlH,EAAO,UAAU;AACtD,YAAM,IAAIgD;AAAA,QACR,SAASkE,CAAK,qBAAqBlH,EAAO,UAAU;AAAA,QACpD;AAAA,QACA;AAAA,QACAA,EAAO;AAAA,QACP,EAAE,OAAAkH,GAAO,UAAU,SAAA;AAAA,MAAS;AAIhC,WAAO,IAAID,EAAejH,EAAO,YAAYkH,CAAK;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKQ,2BACNlH,GACAyE,GACAC,GACAC,GACM;AACN,IAAI3E,EAAO,eAAe,QACxByE,EAAO,KAAK,uDAAuD,GACnEE,EAAY,KAAK,oDAAoD,IAGnE3E,EAAO,WACT0E,EAAS,KAAK,oDAAoD,GAClEC,EAAY,KAAK,qDAAqD,IAGpE3E,EAAO,SAASA,EAAO,UAAU,uBACnC0E,EAAS,KAAK,SAAS1E,EAAO,KAAK,+CAA+C,GAClF2E,EAAY,KAAK,iDAAiD,IAG/DyE,QACH3E,EAAO,KAAK,yDAAyD,GACrEE,EAAY,KAAK,8DAA8D;AAAA,EAEnF;AAAA;AAAA;AAAA;AAAA,EAKQ,qBACN3E,GACAyE,GACAC,GACAC,GACM;AACN,IAAK3E,EAAO,SAGAA,EAAO,OAAO,WAAW,KAAK,MACxC0E,EAAS,KAAK,wCAAwC,GACtDC,EAAY,KAAK,uBAAuB,MAJxCF,EAAO,KAAK,kCAAkC,GAC9CE,EAAY,KAAK,6BAA6B;AAMhD,UAAMuC,IAAQlH,EAAO,SAAS;AAC9B,IAAKkI,EAA2BhB,GAAOlH,EAAO,UAAU,MACtDyE,EAAO,KAAK,SAASyC,CAAK,qBAAqBlH,EAAO,UAAU,aAAa,GAC7E2E,EAAY,KAAK,mDAAmD,IAGlE3E,EAAO,aAAaA,EAAO,YAAY,QACzC0E,EAAS,KAAK,qDAAqD,GACnEC,EAAY,KAAK,yCAAyC;AAAA,EAE9D;AAAA;AAAA;AAAA;AAAA,EAKQ,2BAAgD;AACtD,WAAKyE,MAcE;AAAA,MACL,aAAa;AAAA,IAAA,IAdN;AAAA,MACL,aAAa;AAAA,MACb,mBAAmB;AAAA,MACnB,cAAc,CAAC,QAAQ;AAAA,MACvB,cAAc;AAAA,QACZ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,IACF;AAAA,EAON;AAAA;AAAA;AAAA;AAAA,EAKQ,qBAA0C;AAEhD,WAAI,OAAO,QAAU,MACZ;AAAA,MACL,aAAa;AAAA,MACb,mBAAmB;AAAA,MACnB,cAAc,CAAC,cAAc;AAAA,MAC7B,cAAc,CAAC,uCAAuC;AAAA,IAAA,IAInD;AAAA,MACL,aAAa;AAAA,IAAA;AAAA,EAEjB;AAAA;AAAA;AAAA;AAAA,EAKQ,6BAAmC;AAEzC,SAAK,iBAAiB,IAAI,gBAAgB;AAAA,MACxC,MAAM;AAAA,MACN,aAAa;AAAA,MACb,aAAa;AAAA,MACb,qBAAqB,CAAC,GAAG;AAAA,MACzB,mBAAmB;AAAA,MACnB,gBAAgB;AAAA,MAChB,SAAS;AAAA,MACT,iBAAiBA,EAAA,IAA4B,CAACM,EAAA,CAA0B,IAAI,CAAA;AAAA,MAC5E,qBAAqB;AAAA,QACnB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,MAEF,yBAAyB;AAAA,QACvB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,IACF,CACD,GAGD,KAAK,iBAAiB,IAAI,UAAU;AAAA,MAClC,MAAM;AAAA,MACN,aAAa;AAAA,MACb,aAAa;AAAA,MACb,qBAAqB,CAAC,KAAK,KAAK,KAAK,KAAK,MAAM,MAAM,IAAI;AAAA,MAC1D,mBAAmB;AAAA,MACnB,gBAAgB;AAAA,MAChB,SAAS;AAAA,MACT,iBAAiBzC,EAAe,mBAAA;AAAA,MAChC,qBAAqB;AAAA,QACnB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,MAEF,yBAAyB;AAAA,QACvB;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,IACF,CACD;AAAA,EACH;AACF;AAKO,MAAM8C,IAAkB,IAAIT,EAAA;AAKnC,eAAsBU,EAAwBhK,GAA+D;AAC3G,SAAO+J,EAAgB,eAAe/J,CAAM;AAC9C;AAKO,SAASiK,EAAuBjK,GAA6D;AAClG,SAAO+J,EAAgB,sBAAsB/J,CAAM;AACrD;AAKO,SAASkK,EAAqBP,GAA0D;AAC7F,SAAOI,EAAgB,qBAAqBJ,CAAY;AAC1D;AAKO,SAASQ,EAA2B/B,GAMd;AAC3B,SAAO2B,EAAgB,2BAA2B3B,CAAY;AAChE;AAKO,SAASgC,IAA8C;AAC5D,SAAOL,EAAgB,sBAAA;AACzB;AAKA,eAAsBM,IAA2C;AAC/D,SAAON,EAAgB,mBAAA;AACzB;"}