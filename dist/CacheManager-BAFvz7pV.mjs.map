{"version":3,"file":"CacheManager-BAFvz7pV.mjs","sources":["../src/types/worker.ts","../src/utils/rpc.ts","../src/embedding/errors.ts","../src/embedding/providers/BaseProvider.ts","../src/embedding/providers/ExternalProvider.ts","../src/embedding/providers/OpenAIProvider.ts","../src/embedding/providers/TransformersProvider.ts","../src/embedding/utils.ts","../src/embedding/ProviderFactory.ts","../src/pipeline/InternalPipeline.ts","../src/pipeline/ModelManager.ts","../src/cache/QueryCache.ts","../src/cache/ModelCache.ts","../src/cache/CacheManager.ts"],"sourcesContent":["/**\n * Worker Types for LocalRetrieve Database Worker\n * \n * This file defines the message types and interfaces for communication\n * between the main thread and the database worker via RPC.\n */\n\n// Base SQL value types compatible with sql.js\nexport type SQLValue = number | string | Uint8Array | null;\n\n// Extended SQL value types for internal worker use (includes Float32Array for vectors)\nexport type ExtendedSQLValue = SQLValue | Float32Array;\n\n// SQL parameter types\nexport type SQLParams = Record<string, SQLValue> | SQLValue[];\n\n// Extended SQL parameter types for internal worker use\nexport type ExtendedSQLParams = Record<string, ExtendedSQLValue> | ExtendedSQLValue[];\n\n// Database operation result types\nexport interface QueryResult {\n  rows: Record<string, any>[];\n  columns?: string[];\n  rowsAffected?: number;\n  lastInsertRowid?: number;\n}\n\n// Search-specific types\nexport interface SearchQuery {\n  text?: string;\n  vector?: Float32Array;\n  filters?: Record<string, any>;\n}\n\nexport interface SearchRequest {\n  query: SearchQuery;\n  collection?: string;\n  limit?: number;\n  fusionMethod?: 'rrf' | 'weighted';\n  fusionWeights?: { fts: number; vec: number };\n}\n\nexport interface SearchResult {\n  id: string;\n  title?: string;\n  content?: string;\n  metadata?: Record<string, any>;\n  score: number;\n  ftsScore?: number;\n  vecScore?: number;\n}\n\nexport interface SearchResponse {\n  results: SearchResult[];\n  totalResults: number;\n  searchTime: number;\n}\n\n// Collection management types\nexport interface CollectionInfo {\n  name: string;\n  createdAt: number;\n  schemaVersion: number;\n  vectorDimensions: number;\n  documentCount: number;\n}\n\n// Collection creation with embedding support\nexport interface CreateCollectionParams {\n  name: string;\n  dimensions?: number;\n  config?: Record<string, any>;\n  embeddingConfig?: import('../embedding/types.js').CollectionEmbeddingConfig;\n  description?: string;\n  metadata?: Record<string, any>;\n}\n\n// Document insertion with automatic embedding generation\nexport interface InsertDocumentWithEmbeddingParams {\n  collection: string;\n  document: {\n    id?: string;\n    title?: string;\n    content: string;\n    metadata?: Record<string, any>;\n  };\n  options?: {\n    generateEmbedding?: boolean;\n    embeddingOptions?: import('../embedding/types.js').EmbeddingRequestOptions;\n  };\n}\n\n// Semantic search with optional embedding inclusion\nexport interface SemanticSearchParams {\n  collection: string;\n  query: string;\n  options?: {\n    limit?: number;\n    similarityThreshold?: number;\n    includeEmbeddings?: boolean;\n    filters?: Record<string, any>;\n    generateQueryEmbedding?: boolean;\n  };\n}\n\n// Collection embedding status\nexport interface CollectionEmbeddingStatusResult {\n  collection: string;\n  collectionId: string;\n  provider?: string;\n  model?: string;\n  dimensions?: number;\n  documentsWithEmbeddings: number;\n  totalDocuments: number;\n  isReady: boolean;\n  generationProgress: number;\n  lastUpdated?: Date;\n  configErrors: string[];\n}\n\n// Batch embedding operations\nexport interface BatchEmbeddingRequest {\n  collection: string;\n  documents: Array<{\n    id: string;\n    content: string;\n    metadata?: Record<string, any>;\n  }>;\n  options?: {\n    batchSize?: number;\n    timeout?: number;\n    onProgress?: (progress: EmbeddingProgress) => void;\n  };\n}\n\nexport interface BatchEmbeddingResult {\n  success: number;\n  failed: number;\n  errors: Array<{\n    documentId: string;\n    error: string;\n  }>;\n  processingTime: number;\n}\n\n// Progress reporting for embedding operations\nexport interface EmbeddingProgress {\n  phase: 'initializing' | 'generating' | 'storing' | 'complete' | 'error';\n  processedCount: number;\n  totalCount: number;\n  currentItem?: string;\n  timeElapsed: number;\n  estimatedTimeRemaining?: number;\n  errorCount?: number;\n}\n\n// Embedding generation request\nexport interface GenerateEmbeddingRequest {\n  collection: string;\n  text: string;\n  options?: {\n    includeInVector?: boolean;\n    cacheKey?: string;\n    timeout?: number;\n  };\n}\n\nexport interface GenerateEmbeddingResult {\n  embedding: Float32Array;\n  dimensions: number;\n  generationTime: number;\n  cached: boolean;\n  provider: string;\n}\n\n// Worker RPC message types\nexport interface WorkerMessage<T = any> {\n  id: string;\n  method: string;\n  params?: T;\n}\n\nexport interface WorkerResponse<T = any> {\n  id: string;\n  result?: T;\n  error?: {\n    message: string;\n    code?: string;\n    stack?: string;\n  };\n}\n\n// Specific message types for each database operation\nexport interface OpenDatabaseParams {\n  filename: string;\n  path?: string;\n  vfs?: 'opfs' | 'opfs-sahpool';\n  pragmas?: Record<string, string>;\n}\n\nexport interface ExecParams {\n  sql: string;\n  params?: SQLParams;\n}\n\nexport interface SelectParams {\n  sql: string;\n  params?: SQLParams;\n}\n\nexport interface BulkInsertParams {\n  table: string;\n  tableName: string;\n  data: any[][];\n  rows: Record<string, any>[];\n  batchSize?: number;\n}\n\n// Progress callback interface for export/import operations\nexport interface ExportImportProgress {\n  phase: 'validating' | 'preparing' | 'exporting' | 'importing' | 'finalizing' | 'complete';\n  bytesProcessed: number;\n  totalBytes: number;\n  timeElapsed: number;\n}\n\nexport interface ExportParams {\n  format?: 'sqlite' | 'json';\n  includeSchema?: boolean;\n  onProgress?: (progress: ExportImportProgress) => void;\n}\n\nexport interface ImportParams {\n  data: Uint8Array;\n  format?: 'sqlite' | 'json';\n  overwrite?: boolean;\n  onProgress?: (progress: ExportImportProgress) => void;\n}\n\n// Queue management types\nexport interface EnqueueEmbeddingParams {\n  collection: string;\n  documentId: string;\n  textContent: string;\n  priority?: number;\n}\n\nexport interface ProcessEmbeddingQueueParams {\n  collection?: string;\n  batchSize?: number;\n  maxProcessingTime?: number;\n}\n\nexport interface ProcessEmbeddingQueueResult {\n  processed: number;\n  failed: number;\n  remainingInQueue: number;\n  errors: Array<{\n    documentId: string;\n    error: string;\n  }>;\n}\n\nexport interface QueueStatusResult {\n  totalCount: number;\n  pendingCount: number;\n  processingCount: number;\n  completedCount: number;\n  failedCount: number;\n  oldestPending?: Date;\n  newestCompleted?: Date;\n}\n\nexport interface ClearEmbeddingQueueParams {\n  collection?: string;\n  status?: 'pending' | 'processing' | 'completed' | 'failed';\n  olderThan?: Date;\n}\n\n// Database Worker API Interface\nexport interface DBWorkerAPI {\n  // Core database operations\n  open(params: OpenDatabaseParams): Promise<void>;\n  close(): Promise<void>;\n  exec(params: ExecParams): Promise<void>;\n  select(params: SelectParams): Promise<QueryResult>;\n  bulkInsert(params: BulkInsertParams): Promise<void>;\n\n  // WASM-specific operations\n  initVecExtension(): Promise<void>;\n\n  // Schema management\n  initializeSchema(): Promise<void>;\n  getCollectionInfo(name: string): Promise<CollectionInfo>;\n\n  // Collection management with embedding support\n  createCollection(params: CreateCollectionParams): Promise<void>;\n  getCollectionEmbeddingStatus(collection: string): Promise<CollectionEmbeddingStatusResult>;\n\n  // Document operations with embedding support\n  insertDocumentWithEmbedding(params: InsertDocumentWithEmbeddingParams): Promise<{ id: string; embeddingGenerated: boolean }>;\n\n  // Embedding generation operations\n  generateEmbedding(params: GenerateEmbeddingRequest): Promise<GenerateEmbeddingResult>;\n  batchGenerateEmbeddings(params: BatchEmbeddingRequest): Promise<BatchEmbeddingResult>;\n  regenerateCollectionEmbeddings(collection: string, options?: { batchSize?: number; onProgress?: (progress: EmbeddingProgress) => void }): Promise<BatchEmbeddingResult>;\n\n  // Search operations\n  search(params: SearchRequest): Promise<SearchResponse>;\n  searchSemantic(params: SemanticSearchParams): Promise<SearchResponse>;\n\n  // Enhanced search API (Task 6.1)\n  searchText(params: TextSearchParams): Promise<EnhancedSearchResponse>;\n  searchAdvanced(params: AdvancedSearchParams): Promise<EnhancedSearchResponse>;\n  searchGlobal(params: GlobalSearchParams): Promise<GlobalSearchResponse>;\n  // Data export/import\n  export(params?: ExportParams): Promise<Uint8Array>;\n  import(params: ImportParams): Promise<void>;\n  clear(): Promise<void>;\n\n  // Embedding queue management\n  enqueueEmbedding(params: EnqueueEmbeddingParams): Promise<number>;\n  processEmbeddingQueue(params?: ProcessEmbeddingQueueParams): Promise<ProcessEmbeddingQueueResult>;\n  getQueueStatus(collection?: string): Promise<QueueStatusResult>;\n  clearEmbeddingQueue(params?: ClearEmbeddingQueueParams): Promise<number>;\n\n  // Task 6.2: Internal Embedding Pipeline Operations\n  generateQueryEmbedding(params: GenerateQueryEmbeddingParams): Promise<QueryEmbeddingResult>;\n  batchGenerateQueryEmbeddings(params: BatchGenerateQueryEmbeddingsParams): Promise<BatchQueryEmbeddingResult[]>;\n  warmEmbeddingCache(params: WarmEmbeddingCacheParams): Promise<void>;\n  clearEmbeddingCache(params?: ClearEmbeddingCacheParams): Promise<void>;\n  getPipelineStats(): Promise<PipelinePerformanceStats>;\n  getModelStatus(): Promise<ModelStatusResult>;\n  preloadModels(params: PreloadModelsParams): Promise<void>;\n  optimizeModelMemory(params?: OptimizeModelMemoryParams): Promise<void>;\n\n  // Utility operations\n  getVersion(): Promise<{ sqlite: string; vec: string; sdk: string }>;\n  getStats(): Promise<{ memory: number; dbSize: number; operations: number }>;\n}\n\n// Worker method names (for type safety in RPC calls)\nexport type WorkerMethodName = keyof DBWorkerAPI;\n\n// Worker events for notifications\nexport interface WorkerEvent<T = any> {\n  type: string;\n  data: T;\n}\n\nexport interface EmbeddingProgressEvent extends WorkerEvent<EmbeddingProgress> {\n  type: 'embedding_progress';\n}\n\nexport interface EmbeddingCompletedEvent extends WorkerEvent<{ collection: string; documentsProcessed: number; errors: number }> {\n  type: 'embedding_completed';\n}\n\nexport interface DatabaseEvent extends WorkerEvent {\n  type: 'database' | 'search' | 'error' | 'performance';\n}\n\n// Error types\nexport class WorkerError extends Error {\n  constructor(\n    message: string,\n    public code?: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'WorkerError';\n  }\n}\n\nexport class DatabaseError extends WorkerError {\n  constructor(message: string, public sqliteCode?: number) {\n    super(message, 'DATABASE_ERROR');\n    this.name = 'DatabaseError';\n  }\n}\n\nexport class VectorError extends WorkerError {\n  constructor(message: string) {\n    super(message, 'VECTOR_ERROR');\n    this.name = 'VectorError';\n  }\n}\n\nexport class OPFSError extends WorkerError {\n  constructor(message: string) {\n    super(message, 'OPFS_ERROR');\n    this.name = 'OPFSError';\n  }\n}\n\n// Configuration types\nexport interface WorkerConfig {\n  maxConcurrentOperations?: number;\n  operationTimeout?: number;\n  enablePerformanceMonitoring?: boolean;\n  logLevel?: 'debug' | 'info' | 'warn' | 'error';\n}\n\n// Performance monitoring types\nexport interface PerformanceMetrics {\n  operationCount: number;\n  averageLatency: number;\n  memoryUsage: number;\n  cacheHitRate: number;\n  lastOperationTime: number;\n}\n\n// Embedding queue management types\nexport interface EmbeddingQueueItem {\n  id: number;\n  collection_name: string;\n  document_id: string;\n  text_content: string;\n  priority: number;\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  created_at: number;\n  processed_at?: number;\n  error_message?: string;\n}\n\nexport interface EnqueueEmbeddingParams {\n  collection: string;\n  documentId: string;\n  textContent: string;\n  priority?: number;\n}\n\nexport interface QueueStatusResult {\n  collection: string;\n  pendingCount: number;\n  processingCount: number;\n  completedCount: number;\n  failedCount: number;\n  totalCount: number;\n  oldestPendingDate?: number;\n  averageProcessingTime?: number;\n}\n\nexport interface ProcessEmbeddingQueueParams {\n  collection?: string;\n  batchSize?: number;\n  maxRetries?: number;\n}\n\n\n\n// Enhanced Search API types (Task 6.1)\nexport interface TextSearchParams {\n  query: string;\n  options?: import(\"./search.js\").TextSearchOptions;\n}\n\nexport interface AdvancedSearchParams {\n  query: string;\n  collections?: string[];\n  searchPlan?: Partial<import(\"./search.js\").SearchExecutionPlan>;\n  boosts?: import(\"./search.js\").FieldBoosts;\n  filters?: import(\"./search.js\").AdvancedFilters;\n  aggregations?: import(\"./search.js\").AggregationRequest[];\n  facets?: import(\"./search.js\").FacetRequest[];\n  explain?: boolean;\n}\n\nexport interface GlobalSearchParams {\n  query: string;\n  options?: import(\"./search.js\").GlobalSearchOptions;\n}\n\n// Task 6.2: Internal Embedding Pipeline RPC Parameters\n\nexport interface GenerateQueryEmbeddingParams {\n  query: string;\n  collection: string;\n  options?: {\n    forceRefresh?: boolean;\n    timeout?: number;\n    priority?: number;\n    context?: {\n      userId?: string;\n      sessionId?: string;\n      source?: string;\n    };\n  };\n}\n\nexport interface BatchGenerateQueryEmbeddingsParams {\n  requests: Array<{\n    id: string;\n    query: string;\n    collection: string;\n    options?: GenerateQueryEmbeddingParams['options'];\n  }>;\n  batchOptions?: {\n    batchSize?: number;\n    concurrency?: number;\n    timeout?: number;\n    onProgress?: (completed: number, total: number, current?: string) => void;\n  };\n}\n\nexport interface WarmEmbeddingCacheParams {\n  collection: string;\n  commonQueries: string[];\n}\n\nexport interface ClearEmbeddingCacheParams {\n  collection?: string;\n  pattern?: string;\n}\n\nexport interface PreloadModelsParams {\n  providers: string[];\n  strategy?: 'eager' | 'lazy' | 'predictive';\n}\n\nexport interface OptimizeModelMemoryParams {\n  maxMemoryUsage?: number;\n  maxModels?: number;\n  idleTimeout?: number;\n  aggressive?: boolean;\n}\n\n// Task 6.2: Pipeline Response Types\n\nexport interface QueryEmbeddingResult {\n  embedding: Float32Array;\n  dimensions: number;\n  source: 'cache_memory' | 'cache_indexeddb' | 'cache_database' | 'provider_fresh';\n  processingTime: number;\n  metadata?: {\n    cacheHit?: boolean;\n    modelUsed?: string;\n    provider?: string;\n    confidence?: number;\n  };\n}\n\nexport interface BatchQueryEmbeddingResult extends QueryEmbeddingResult {\n  requestId: string;\n  status: 'completed' | 'failed' | 'skipped';\n  error?: string;\n}\n\nexport interface PipelinePerformanceStats {\n  totalRequests: number;\n  cacheHitRate: number;\n  averageGenerationTime: number;\n  activeModels: number;\n  memoryUsage: number;\n  cacheStats: {\n    memory: { hits: number; misses: number };\n    indexedDB: { hits: number; misses: number };\n    database: { hits: number; misses: number };\n  };\n}\n\nexport interface ModelStatusResult {\n  loadedModels: Array<{\n    modelId: string;\n    provider: string;\n    modelName: string;\n    dimensions: number;\n    memoryUsage: number;\n    lastUsed: number;\n    usageCount: number;\n    status: 'loading' | 'ready' | 'error' | 'unloading';\n  }>;\n  totalMemoryUsage: number;\n  activeCount: number;\n  providerStats: Record<string, {\n    count: number;\n    memoryUsage: number;\n    avgLoadTime: number;\n  }>;\n}\n\n// Enhanced search response types\nexport interface EnhancedSearchResponse extends SearchResponse {\n  strategy?: import(\"./search.js\").SearchStrategy;\n  fusion?: import(\"./search.js\").FusionMethod;\n  aggregations?: Record<string, any>;\n  facets?: Record<string, any>;\n  suggestions?: string[];\n  debugInfo?: import(\"./search.js\").SearchDebugInfo;\n}\n\nexport interface GlobalSearchResponse extends EnhancedSearchResponse {\n  collectionResults: Array<{\n    collection: string;\n    results: SearchResult[];\n    totalInCollection: number;\n  }>;\n  collectionsSearched: string[];\n}\n","/**\n * RPC Utilities for Worker Communication\n * \n * This module provides a robust RPC (Remote Procedure Call) system for\n * communication between the main thread and database worker.\n */\n\nimport type {\n  WorkerMessage,\n  WorkerResponse,\n  WorkerMethodName,\n  DBWorkerAPI,\n  WorkerConfig\n} from '../types/worker.js';\n\nimport {\n  WorkerError\n} from '../types/worker.js';\n\n// Default configuration\nconst DEFAULT_CONFIG: Required<WorkerConfig> = {\n  maxConcurrentOperations: 10,\n  operationTimeout: 30000, // 30 seconds\n  enablePerformanceMonitoring: true,\n  logLevel: 'info'\n};\n\n/**\n * Client-side RPC wrapper for worker communication\n */\nexport class WorkerRPC implements DBWorkerAPI {\n  private worker: Worker;\n  private config: Required<WorkerConfig>;\n  private pendingCalls = new Map<string, {\n    resolve: (value: any) => void;\n    reject: (error: Error) => void;\n    timeout: ReturnType<typeof setTimeout>;\n    startTime: number;\n  }>();\n  private callCounter = 0;\n  private performanceMetrics = {\n    totalCalls: 0,\n    totalTime: 0,\n    errors: 0,\n    timeouts: 0\n  };\n\n  constructor(worker: Worker, config: Partial<WorkerConfig> = {}) {\n    this.worker = worker;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.setupWorkerListeners();\n  }\n\n  private setupWorkerListeners(): void {\n    this.worker.onmessage = (event: MessageEvent<WorkerResponse | any>) => {\n      const response = event.data;\n\n      // Handle worker log messages\n      if (response.type === 'log') {\n        const level = response.level as 'debug' | 'info' | 'warn' | 'error';\n        const logFn = (console[level] || console.log) as (...args: any[]) => void;\n        logFn(response.message, ...(response.args || []));\n        return;\n      }\n\n      this.handleWorkerResponse(response);\n    };\n\n    this.worker.onerror = (error: ErrorEvent) => {\n      this.log('error', 'Worker error:', error.message);\n      this.rejectAllPending(new WorkerError('Worker error: ' + error.message, 'WORKER_ERROR'));\n    };\n\n    this.worker.onmessageerror = (event: MessageEvent) => {\n      this.log('error', 'Worker message error:', event);\n      this.rejectAllPending(new WorkerError('Worker message error', 'MESSAGE_ERROR'));\n    };\n  }\n\n  private handleWorkerResponse(response: WorkerResponse): void {\n    const pending = this.pendingCalls.get(response.id);\n    if (!pending) {\n      this.log('warn', 'Received response for unknown call ID:', response.id);\n      return;\n    }\n\n    this.pendingCalls.delete(response.id);\n    clearTimeout(pending.timeout);\n\n    // Update performance metrics\n    if (this.config.enablePerformanceMonitoring) {\n      const duration = Date.now() - pending.startTime;\n      this.performanceMetrics.totalCalls++;\n      this.performanceMetrics.totalTime += duration;\n    }\n\n    if (response.error) {\n      this.performanceMetrics.errors++;\n      const error = new WorkerError(\n        response.error.message,\n        response.error.code\n      );\n      if (response.error.stack) {\n        error.stack = response.error.stack;\n      }\n      pending.reject(error);\n    } else {\n      pending.resolve(response.result);\n    }\n  }\n\n  private generateCallId(): string {\n    return `rpc_${++this.callCounter}_${Date.now()}`;\n  }\n\n  private call<T = any>(method: WorkerMethodName, params?: any): Promise<T> {\n    return new Promise((resolve, reject) => {\n      // Check concurrent operations limit\n      if (this.pendingCalls.size >= this.config.maxConcurrentOperations) {\n        this.log('error', `Rate limit exceeded for ${method}: ${this.pendingCalls.size}/${this.config.maxConcurrentOperations}`);\n        reject(new WorkerError(\n          `Too many concurrent operations (max: ${this.config.maxConcurrentOperations})`,\n          'RATE_LIMIT'\n        ));\n        return;\n      }\n\n      const id = this.generateCallId();\n      const startTime = Date.now();\n\n      // Setup timeout\n      const timeout = setTimeout(() => {\n        this.log('error', `Operation timeout for ${method} after ${this.config.operationTimeout}ms`);\n        this.pendingCalls.delete(id);\n        this.performanceMetrics.timeouts++;\n        reject(new WorkerError(\n          `Operation timeout after ${this.config.operationTimeout}ms`,\n          'TIMEOUT'\n        ));\n      }, this.config.operationTimeout);\n\n      // Store pending call\n      this.pendingCalls.set(id, {\n        resolve,\n        reject,\n        timeout,\n        startTime\n      });\n\n      // Send message to worker\n      const message: WorkerMessage = {\n        id,\n        method,\n        params\n      };\n\n      try {\n        this.worker.postMessage(message);\n      } catch (error) {\n        this.log('error', `Failed to send RPC message for ${method}:`, error);\n        this.pendingCalls.delete(id);\n        clearTimeout(timeout);\n        reject(new WorkerError(\n          `Failed to send message: ${error instanceof Error ? error.message : String(error)}`,\n          'SEND_ERROR'\n        ));\n      }\n    });\n  }\n\n  private rejectAllPending(error: Error): void {\n    for (const [id, pending] of this.pendingCalls) {\n      clearTimeout(pending.timeout);\n      pending.reject(error);\n    }\n    this.pendingCalls.clear();\n  }\n\n  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string, ...args: any[]): void {\n    const levels = { debug: 0, info: 1, warn: 2, error: 3 };\n    const configLevel = levels[this.config.logLevel];\n    const messageLevel = levels[level];\n\n    if (messageLevel >= configLevel) {\n      console[level](`[WorkerRPC] ${message}`, ...args);\n    }\n  }\n\n  // DBWorkerAPI implementation\n  async open(params: Parameters<DBWorkerAPI['open']>[0]): Promise<void> {\n    return this.call('open', params);\n  }\n\n  async close(): Promise<void> {\n    const result = await this.call('close');\n    // Clean up any pending calls after close\n    this.rejectAllPending(new WorkerError('Worker closed', 'WORKER_CLOSED'));\n    return result;\n  }\n\n  async exec(params: Parameters<DBWorkerAPI['exec']>[0]): Promise<void> {\n    return this.call('exec', params);\n  }\n\n  async select(params: Parameters<DBWorkerAPI['select']>[0]) {\n    return this.call('select', params);\n  }\n\n  async bulkInsert(params: Parameters<DBWorkerAPI['bulkInsert']>[0]): Promise<void> {\n    return this.call('bulkInsert', params);\n  }\n\n  async initVecExtension(): Promise<void> {\n    return this.call('initVecExtension');\n  }\n\n  async initializeSchema(): Promise<void> {\n    return this.call('initializeSchema');\n  }\n\n  async getCollectionInfo(name: string) {\n    return this.call('getCollectionInfo', name);\n  }\n\n  async search(params: Parameters<DBWorkerAPI['search']>[0]) {\n    return this.call('search', params);\n  }\n\n  async export(params?: Parameters<DBWorkerAPI['export']>[0]): Promise<Uint8Array> {\n    return this.call('export', params);\n  }\n\n  async import(params: Parameters<DBWorkerAPI['import']>[0]): Promise<void> {\n    return this.call('import', params);\n  }\n\n  async clear(): Promise<void> {\n    return this.call('clear');\n  }\n\n  async getVersion() {\n    return this.call('getVersion');\n  }\n\n  async getStats() {\n    return this.call('getStats');\n  }\n\n  // Collection management with embedding support\n  async createCollection(params: Parameters<DBWorkerAPI['createCollection']>[0]): Promise<void> {\n    return this.call('createCollection', params);\n  }\n\n  async getCollectionEmbeddingStatus(collection: string) {\n    return this.call('getCollectionEmbeddingStatus', collection);\n  }\n\n  // Document operations with embedding support\n  async insertDocumentWithEmbedding(params: Parameters<DBWorkerAPI['insertDocumentWithEmbedding']>[0]) {\n    return this.call('insertDocumentWithEmbedding', params);\n  }\n\n  // Search operations\n  async searchSemantic(params: Parameters<DBWorkerAPI['searchSemantic']>[0]) {\n    return this.call('searchSemantic', params);\n  }\n\n  // Enhanced search API (Task 6.1)\n  async searchText(params: Parameters<DBWorkerAPI[\"searchText\"]>[0]) {\n    return this.call(\"searchText\", params);\n  }\n\n  async searchAdvanced(params: Parameters<DBWorkerAPI[\"searchAdvanced\"]>[0]) {\n    return this.call(\"searchAdvanced\", params);\n  }\n\n  async searchGlobal(params: Parameters<DBWorkerAPI[\"searchGlobal\"]>[0]) {\n    return this.call(\"searchGlobal\", params);\n  }\n\n  // Embedding generation operations\n  async generateEmbedding(params: Parameters<DBWorkerAPI['generateEmbedding']>[0]) {\n    return this.call('generateEmbedding', params);\n  }\n\n  async batchGenerateEmbeddings(params: Parameters<DBWorkerAPI['batchGenerateEmbeddings']>[0]) {\n    return this.call('batchGenerateEmbeddings', params);\n  }\n\n  async regenerateCollectionEmbeddings(collection: string, options?: Parameters<DBWorkerAPI['regenerateCollectionEmbeddings']>[1]) {\n    return this.call('regenerateCollectionEmbeddings', { collection, options });\n  }\n\n  // Embedding queue management\n  async enqueueEmbedding(params: Parameters<DBWorkerAPI['enqueueEmbedding']>[0]): Promise<number> {\n    return this.call('enqueueEmbedding', params);\n  }\n\n  async processEmbeddingQueue(params?: Parameters<DBWorkerAPI['processEmbeddingQueue']>[0]) {\n    return this.call('processEmbeddingQueue', params);\n  }\n\n  async getQueueStatus(collection?: string) {\n    return this.call('getQueueStatus', collection);\n  }\n\n  async clearEmbeddingQueue(params?: Parameters<DBWorkerAPI['clearEmbeddingQueue']>[0]): Promise<number> {\n    return this.call('clearEmbeddingQueue', params);\n  }\n\n  // Task 6.2: Internal Embedding Pipeline RPC methods\n  async generateQueryEmbedding(params: Parameters<DBWorkerAPI[\"generateQueryEmbedding\"]>[0]) {\n    return this.call(\"generateQueryEmbedding\", params);\n  }\n\n  async batchGenerateQueryEmbeddings(params: Parameters<DBWorkerAPI[\"batchGenerateQueryEmbeddings\"]>[0]) {\n    return this.call(\"batchGenerateQueryEmbeddings\", params);\n  }\n\n  async warmEmbeddingCache(params: Parameters<DBWorkerAPI[\"warmEmbeddingCache\"]>[0]) {\n    return this.call(\"warmEmbeddingCache\", params);\n  }\n\n  async clearEmbeddingCache(params?: Parameters<DBWorkerAPI[\"clearEmbeddingCache\"]>[0]) {\n    return this.call(\"clearEmbeddingCache\", params);\n  }\n\n  async getPipelineStats() {\n    return this.call(\"getPipelineStats\");\n  }\n\n  async getModelStatus() {\n    return this.call(\"getModelStatus\");\n  }\n\n  async preloadModels(params: Parameters<DBWorkerAPI[\"preloadModels\"]>[0]) {\n    return this.call(\"preloadModels\", params);\n  }\n\n  async optimizeModelMemory(params?: Parameters<DBWorkerAPI[\"optimizeModelMemory\"]>[0]) {\n    return this.call(\"optimizeModelMemory\", params);\n  }\n\n  // Utility methods\n  getPerformanceMetrics() {\n    const avgLatency = this.performanceMetrics.totalCalls > 0 \n      ? this.performanceMetrics.totalTime / this.performanceMetrics.totalCalls \n      : 0;\n\n    return {\n      ...this.performanceMetrics,\n      averageLatency: avgLatency,\n      pendingOperations: this.pendingCalls.size,\n      successRate: this.performanceMetrics.totalCalls > 0\n        ? (this.performanceMetrics.totalCalls - this.performanceMetrics.errors) / this.performanceMetrics.totalCalls\n        : 1\n    };\n  }\n\n  terminate(): void {\n    this.rejectAllPending(new WorkerError('Worker terminated', 'TERMINATED'));\n    this.worker.terminate();\n  }\n}\n\n/**\n * Server-side RPC handler for the worker\n */\nexport class WorkerRPCHandler {\n  private handlers = new Map<string, (params: any) => Promise<any>>();\n  private config: Required<WorkerConfig>;\n\n  constructor(config: Partial<WorkerConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.setupMessageHandler();\n  }\n\n  private setupMessageHandler(): void {\n    self.onmessage = async (event: MessageEvent<WorkerMessage>) => {\n      const message = event.data;\n      await this.handleMessage(message);\n    };\n  }\n\n  private async handleMessage(message: WorkerMessage): Promise<void> {\n    const startTime = Date.now();\n    let response: WorkerResponse;\n\n    try {\n\n      const handler = this.handlers.get(message.method);\n      if (!handler) {\n        throw new WorkerError(`Unknown method: ${message.method}`, 'UNKNOWN_METHOD');\n      }\n\n      const result = await handler(message.params);\n\n      response = {\n        id: message.id,\n        result\n      };\n    } catch (error) {\n      this.log('error', `Method ${message.method} failed:`, error);\n      \n      response = {\n        id: message.id,\n        error: {\n          message: error instanceof Error ? error.message : String(error),\n          code: error instanceof WorkerError ? error.code : 'UNKNOWN_ERROR',\n          stack: error instanceof Error ? error.stack : undefined\n        }\n      };\n    }\n\n    try {\n      self.postMessage(response);\n    } catch (postError) {\n      this.log('error', 'Failed to post response:', postError);\n      \n      // Try to send a simpler error response\n      const errorResponse: WorkerResponse = {\n        id: message.id,\n        error: {\n          message: 'Failed to serialize response',\n          code: 'SERIALIZATION_ERROR'\n        }\n      };\n      \n      try {\n        self.postMessage(errorResponse);\n      } catch (finalError) {\n        this.log('error', 'Failed to send error response:', finalError);\n      }\n    }\n  }\n\n  register(method: string, handler: (params: any) => Promise<any>): void {\n    this.handlers.set(method, handler);\n    this.log('debug', `Registered handler for method: ${method}`);\n  }\n\n  unregister(method: string): void {\n    this.handlers.delete(method);\n    this.log('debug', `Unregistered handler for method: ${method}`);\n  }\n\n  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string, ...args: any[]): void {\n    const levels = { debug: 0, info: 1, warn: 2, error: 3 };\n    const configLevel = levels[this.config.logLevel];\n    const messageLevel = levels[level];\n\n    if (messageLevel >= configLevel) {\n      console[level](`[WorkerRPCHandler] ${message}`, ...args);\n    }\n  }\n}\n\n/**\n * Utility function to create a typed RPC client\n */\nexport function createWorkerRPC(\n  workerUrl: string | URL, \n  config?: Partial<WorkerConfig>\n): WorkerRPC {\n  const worker = new Worker(workerUrl, { type: 'module' });\n  return new WorkerRPC(worker, config);\n}\n\n/**\n * Helper for handling transferable objects in RPC calls\n */\nexport function createTransferableMessage<T = any>(\n  message: WorkerMessage<T>,\n  transferables: Transferable[] = []\n): [WorkerMessage<T>, Transferable[]] {\n  return [message, transferables];\n}\n\n/**\n * Error handling utilities\n */\nexport function isWorkerError(error: any): error is WorkerError {\n  return error instanceof Error && error.name === 'WorkerError';\n}\n\nexport function createTimeoutError(timeout: number): WorkerError {\n  return new WorkerError(\n    `Operation timed out after ${timeout}ms`,\n    'TIMEOUT'\n  );\n}","/**\r\n * Классы ошибок для системы эмбеддингов LocalRetrieve\r\n *\r\n * Данный модуль предоставляет иерархию классов ошибок для различных\r\n * типов проблем, которые могут возникнуть при работе с эмбеддингами.\r\n */\r\n\r\n/**\r\n * Базовый класс для всех ошибок системы эмбеддингов\r\n */\r\nexport class EmbeddingError extends Error {\r\n  /** Код ошибки для программной обработки */\r\n  public readonly code: string;\r\n\r\n  /** Категория ошибки */\r\n  public readonly category: ErrorCategory;\r\n\r\n  /** Дополнительный контекст ошибки */\r\n  public readonly context?: Record<string, any>;\r\n\r\n  /** Информация о возможном восстановлении */\r\n  public readonly recoveryInfo?: ErrorRecoveryInfo;\r\n\r\n  /** Время возникновения ошибки */\r\n  public readonly timestamp: Date;\r\n\r\n  constructor(\r\n    message: string,\r\n    code: string = 'EMBEDDING_ERROR',\r\n    category: ErrorCategory = 'unknown',\r\n    context?: Record<string, any>,\r\n    recoveryInfo?: ErrorRecoveryInfo\r\n  ) {\r\n    super(message);\r\n    this.name = 'EmbeddingError';\r\n    this.code = code;\r\n    this.category = category;\r\n    this.context = context;\r\n    this.recoveryInfo = recoveryInfo;\r\n    this.timestamp = new Date();\r\n\r\n    // Обеспечиваем правильный прототип для instanceof\r\n    Object.setPrototypeOf(this, EmbeddingError.prototype);\r\n  }\r\n\r\n  /**\r\n   * Создает JSON представление ошибки для логирования\r\n   */\r\n  toJSON(): ErrorJSON {\r\n    return {\r\n      name: this.name,\r\n      message: this.message,\r\n      code: this.code,\r\n      category: this.category,\r\n      context: this.context,\r\n      recoveryInfo: this.recoveryInfo,\r\n      timestamp: this.timestamp.toISOString(),\r\n      stack: this.stack\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Создает пользовательски-дружественное сообщение об ошибке\r\n   */\r\n  getUserMessage(): string {\r\n    switch (this.category) {\r\n      case 'provider':\r\n        return `Ошибка провайдера эмбеддингов: ${this.message}`;\r\n      case 'network':\r\n        return `Проблема с сетевым подключением: ${this.message}`;\r\n      case 'configuration':\r\n        return `Ошибка конфигурации: ${this.message}`;\r\n      case 'validation':\r\n        return `Неверные данные: ${this.message}`;\r\n      case 'quota':\r\n        return `Превышен лимит: ${this.message}`;\r\n      case 'timeout':\r\n        return `Превышено время ожидания: ${this.message}`;\r\n      default:\r\n        return this.message;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки провайдера эмбеддингов\r\n */\r\nexport class ProviderError extends EmbeddingError {\r\n  /** Имя провайдера */\r\n  public readonly providerName: string;\r\n\r\n  /** Версия модели (если применимо) */\r\n  public readonly modelVersion?: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    providerName: string,\r\n    code: string = 'PROVIDER_ERROR',\r\n    modelVersion?: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      code,\r\n      'provider',\r\n      { ...context, providerName, modelVersion },\r\n      {\r\n        canRetry: true,\r\n        retryAfter: 1000,\r\n        maxRetries: 3,\r\n        fallbackAvailable: true\r\n      }\r\n    );\r\n    this.name = 'ProviderError';\r\n    this.providerName = providerName;\r\n    this.modelVersion = modelVersion;\r\n\r\n    Object.setPrototypeOf(this, ProviderError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки инициализации провайдера\r\n */\r\nexport class ProviderInitializationError extends ProviderError {\r\n  constructor(\r\n    message: string,\r\n    providerName: string,\r\n    cause?: Error,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      providerName,\r\n      'PROVIDER_INIT_ERROR',\r\n      undefined,\r\n      { ...context, cause: cause?.message }\r\n    );\r\n    this.name = 'ProviderInitializationError';\r\n\r\n    // Инициализация обычно не подлежит автоматическому повтору\r\n    (this as any).recoveryInfo = {\r\n      canRetry: false,\r\n      retryAfter: 0,\r\n      maxRetries: 0,\r\n      fallbackAvailable: true,\r\n      userActionRequired: true,\r\n      suggestedActions: [\r\n        'Проверьте конфигурацию провайдера',\r\n        'Убедитесь, что API ключ корректен',\r\n        'Проверьте доступность сервиса'\r\n      ]\r\n    };\r\n\r\n    Object.setPrototypeOf(this, ProviderInitializationError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки загрузки модели\r\n */\r\nexport class ModelLoadError extends ProviderError {\r\n  /** Имя модели */\r\n  public readonly modelName: string;\r\n\r\n  /** Размер модели в байтах */\r\n  public readonly modelSize?: number;\r\n\r\n  constructor(\r\n    message: string,\r\n    providerName: string,\r\n    modelName: string,\r\n    modelSize?: number,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      providerName,\r\n      'MODEL_LOAD_ERROR',\r\n      undefined,\r\n      { ...context, modelName, modelSize }\r\n    );\r\n    this.name = 'ModelLoadError';\r\n    this.modelName = modelName;\r\n    this.modelSize = modelSize;\r\n\r\n    Object.setPrototypeOf(this, ModelLoadError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Сетевые ошибки\r\n */\r\nexport class NetworkError extends EmbeddingError {\r\n  /** HTTP статус код (если применимо) */\r\n  public readonly statusCode?: number;\r\n\r\n  /** URL запроса */\r\n  public readonly url?: string;\r\n\r\n  /** Тип сетевой ошибки */\r\n  public readonly networkType: NetworkErrorType;\r\n\r\n  constructor(\r\n    message: string,\r\n    networkType: NetworkErrorType,\r\n    statusCode?: number,\r\n    url?: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    const code = `NETWORK_${networkType.toUpperCase()}_ERROR`;\r\n    const retryAfter = NetworkError.getRetryDelay(statusCode, networkType);\r\n\r\n    super(\r\n      message,\r\n      code,\r\n      'network',\r\n      { ...context, statusCode, url, networkType },\r\n      {\r\n        canRetry: NetworkError.isRetryable(statusCode, networkType),\r\n        retryAfter,\r\n        maxRetries: 5,\r\n        fallbackAvailable: false\r\n      }\r\n    );\r\n\r\n    this.name = 'NetworkError';\r\n    this.statusCode = statusCode;\r\n    this.url = url;\r\n    this.networkType = networkType;\r\n\r\n    Object.setPrototypeOf(this, NetworkError.prototype);\r\n  }\r\n\r\n  /**\r\n   * Определяет, можно ли повторить запрос\r\n   */\r\n  private static isRetryable(statusCode?: number, networkType?: NetworkErrorType): boolean {\r\n    if (networkType === 'timeout' || networkType === 'connection') {\r\n      return true;\r\n    }\r\n\r\n    if (statusCode) {\r\n      // Повторяем при серверных ошибках и некоторых клиентских\r\n      return statusCode >= 500 || statusCode === 429 || statusCode === 408;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Вычисляет задержку перед повтором\r\n   */\r\n  private static getRetryDelay(statusCode?: number, networkType?: NetworkErrorType): number {\r\n    if (statusCode === 429) return 60000; // Rate limit - ждем минуту\r\n    if (networkType === 'timeout') return 5000; // Timeout - ждем 5 секунд\r\n    if (statusCode && statusCode >= 500) return 2000; // Server error - ждем 2 секунды\r\n    return 1000; // По умолчанию 1 секунда\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки аутентификации\r\n */\r\nexport class AuthenticationError extends EmbeddingError {\r\n  /** Тип ошибки аутентификации */\r\n  public readonly authType: AuthErrorType;\r\n\r\n  constructor(\r\n    message: string,\r\n    authType: AuthErrorType,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'AUTH_ERROR',\r\n      'authentication',\r\n      { ...context, authType },\r\n      {\r\n        canRetry: false,\r\n        retryAfter: 0,\r\n        maxRetries: 0,\r\n        fallbackAvailable: false,\r\n        userActionRequired: true,\r\n        suggestedActions: AuthenticationError.getSuggestedActions(authType)\r\n      }\r\n    );\r\n\r\n    this.name = 'AuthenticationError';\r\n    this.authType = authType;\r\n\r\n    Object.setPrototypeOf(this, AuthenticationError.prototype);\r\n  }\r\n\r\n  private static getSuggestedActions(authType: AuthErrorType): string[] {\r\n    switch (authType) {\r\n      case 'invalid_key':\r\n        return ['Проверьте правильность API ключа', 'Убедитесь, что ключ не истек'];\r\n      case 'expired_key':\r\n        return ['Обновите API ключ', 'Проверьте дату истечения подписки'];\r\n      case 'insufficient_permissions':\r\n        return ['Проверьте права доступа', 'Обратитесь к администратору'];\r\n      case 'quota_exceeded':\r\n        return ['Проверьте лимиты использования', 'Обновите тарифный план'];\r\n      default:\r\n        return ['Проверьте настройки аутентификации'];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки конфигурации\r\n */\r\nexport class ConfigurationError extends EmbeddingError {\r\n  /** Имя некорректного параметра */\r\n  public readonly parameterName: string;\r\n\r\n  /** Ожидаемое значение или тип */\r\n  public readonly expectedValue?: string;\r\n\r\n  /** Текущее (неверное) значение */\r\n  public readonly actualValue?: any;\r\n\r\n  constructor(\r\n    message: string,\r\n    parameterName: string,\r\n    expectedValue?: string,\r\n    actualValue?: any,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'CONFIG_ERROR',\r\n      'configuration',\r\n      { ...context, parameterName, expectedValue, actualValue },\r\n      {\r\n        canRetry: false,\r\n        retryAfter: 0,\r\n        maxRetries: 0,\r\n        fallbackAvailable: false,\r\n        userActionRequired: true,\r\n        suggestedActions: [\r\n          `Исправьте параметр '${parameterName}'`,\r\n          expectedValue ? `Ожидается: ${expectedValue}` : 'Проверьте документацию'\r\n        ]\r\n      }\r\n    );\r\n\r\n    this.name = 'ConfigurationError';\r\n    this.parameterName = parameterName;\r\n    this.expectedValue = expectedValue;\r\n    this.actualValue = actualValue;\r\n\r\n    Object.setPrototypeOf(this, ConfigurationError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки валидации данных\r\n */\r\nexport class ValidationError extends EmbeddingError {\r\n  /** Поле, которое не прошло валидацию */\r\n  public readonly fieldName: string;\r\n\r\n  /** Правило валидации, которое было нарушено */\r\n  public readonly validationRule: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    fieldName: string,\r\n    validationRule: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'VALIDATION_ERROR',\r\n      'validation',\r\n      { ...context, fieldName, validationRule },\r\n      {\r\n        canRetry: false,\r\n        retryAfter: 0,\r\n        maxRetries: 0,\r\n        fallbackAvailable: false,\r\n        userActionRequired: true,\r\n        suggestedActions: [`Исправьте поле '${fieldName}' согласно правилу: ${validationRule}`]\r\n      }\r\n    );\r\n\r\n    this.name = 'ValidationError';\r\n    this.fieldName = fieldName;\r\n    this.validationRule = validationRule;\r\n\r\n    Object.setPrototypeOf(this, ValidationError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки превышения лимитов\r\n */\r\nexport class QuotaExceededError extends EmbeddingError {\r\n  /** Тип превышенного лимита */\r\n  public readonly quotaType: QuotaType;\r\n\r\n  /** Текущее значение */\r\n  public readonly currentValue: number;\r\n\r\n  /** Максимально допустимое значение */\r\n  public readonly maxValue: number;\r\n\r\n  /** Время сброса лимита */\r\n  public readonly resetTime?: Date;\r\n\r\n  constructor(\r\n    message: string,\r\n    quotaType: QuotaType,\r\n    currentValue: number,\r\n    maxValue: number,\r\n    resetTime?: Date,\r\n    context?: Record<string, any>\r\n  ) {\r\n    const retryAfter = resetTime ? resetTime.getTime() - Date.now() : 3600000; // 1 час по умолчанию\r\n\r\n    super(\r\n      message,\r\n      'QUOTA_EXCEEDED',\r\n      'quota',\r\n      { ...context, quotaType, currentValue, maxValue, resetTime },\r\n      {\r\n        canRetry: true,\r\n        retryAfter: Math.max(retryAfter, 0),\r\n        maxRetries: 1,\r\n        fallbackAvailable: quotaType !== 'api_calls',\r\n        suggestedActions: QuotaExceededError.getSuggestedActions(quotaType, resetTime)\r\n      }\r\n    );\r\n\r\n    this.name = 'QuotaExceededError';\r\n    this.quotaType = quotaType;\r\n    this.currentValue = currentValue;\r\n    this.maxValue = maxValue;\r\n    this.resetTime = resetTime;\r\n\r\n    Object.setPrototypeOf(this, QuotaExceededError.prototype);\r\n  }\r\n\r\n  private static getSuggestedActions(quotaType: QuotaType, resetTime?: Date): string[] {\r\n    const actions = [`Превышен лимит: ${quotaType}`];\r\n\r\n    if (resetTime) {\r\n      actions.push(`Лимит будет сброшен: ${resetTime.toLocaleString()}`);\r\n    }\r\n\r\n    switch (quotaType) {\r\n      case 'api_calls':\r\n        actions.push('Подождите до сброса лимита или обновите тариф');\r\n        break;\r\n      case 'tokens':\r\n        actions.push('Сократите размер текста или разбейте на части');\r\n        break;\r\n      case 'memory':\r\n        actions.push('Очистите кэш или используйте меньшую модель');\r\n        break;\r\n      case 'concurrent_requests':\r\n        actions.push('Дождитесь завершения текущих запросов');\r\n        break;\r\n    }\r\n\r\n    return actions;\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки тайм-аута\r\n */\r\nexport class TimeoutError extends EmbeddingError {\r\n  /** Время ожидания в миллисекундах */\r\n  public readonly timeoutMs: number;\r\n\r\n  /** Операция, которая была прервана */\r\n  public readonly operation: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    timeoutMs: number,\r\n    operation: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'TIMEOUT_ERROR',\r\n      'timeout',\r\n      { ...context, timeoutMs, operation },\r\n      {\r\n        canRetry: true,\r\n        retryAfter: Math.min(timeoutMs * 0.5, 5000), // Половина от таймаута, но не более 5 сек\r\n        maxRetries: 3,\r\n        fallbackAvailable: true,\r\n        suggestedActions: [\r\n          'Увеличьте таймаут в настройках',\r\n          'Проверьте размер обрабатываемых данных',\r\n          'Попробуйте разбить операцию на части'\r\n        ]\r\n      }\r\n    );\r\n\r\n    this.name = 'TimeoutError';\r\n    this.timeoutMs = timeoutMs;\r\n    this.operation = operation;\r\n\r\n    Object.setPrototypeOf(this, TimeoutError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки работы с кэшем\r\n */\r\nexport class CacheError extends EmbeddingError {\r\n  /** Тип операции с кэшем */\r\n  public readonly cacheOperation: CacheOperation;\r\n\r\n  /** Ключ кэша */\r\n  public readonly cacheKey?: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    cacheOperation: CacheOperation,\r\n    cacheKey?: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'CACHE_ERROR',\r\n      'cache',\r\n      { ...context, cacheOperation, cacheKey },\r\n      {\r\n        canRetry: cacheOperation !== 'write', // Записи обычно не повторяем\r\n        retryAfter: 1000,\r\n        maxRetries: 2,\r\n        fallbackAvailable: true // Можно работать без кэша\r\n      }\r\n    );\r\n\r\n    this.name = 'CacheError';\r\n    this.cacheOperation = cacheOperation;\r\n    this.cacheKey = cacheKey;\r\n\r\n    Object.setPrototypeOf(this, CacheError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Ошибки работы с воркерами\r\n */\r\nexport class WorkerError extends EmbeddingError {\r\n  /** Идентификатор воркера */\r\n  public readonly workerId?: string;\r\n\r\n  /** Тип операции воркера */\r\n  public readonly workerOperation: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    workerOperation: string,\r\n    workerId?: string,\r\n    context?: Record<string, any>\r\n  ) {\r\n    super(\r\n      message,\r\n      'WORKER_ERROR',\r\n      'worker',\r\n      { ...context, workerOperation, workerId },\r\n      {\r\n        canRetry: true,\r\n        retryAfter: 2000,\r\n        maxRetries: 3,\r\n        fallbackAvailable: false,\r\n        suggestedActions: [\r\n          'Перезагрузите страницу',\r\n          'Проверьте поддержку Web Workers в браузере'\r\n        ]\r\n      }\r\n    );\r\n\r\n    this.name = 'WorkerError';\r\n    this.workerId = workerId;\r\n    this.workerOperation = workerOperation;\r\n\r\n    Object.setPrototypeOf(this, WorkerError.prototype);\r\n  }\r\n}\r\n\r\n// Типы для категоризации ошибок\r\n\r\nexport type ErrorCategory =\r\n  | 'provider'        // Ошибки провайдера эмбеддингов\r\n  | 'network'         // Сетевые ошибки\r\n  | 'authentication' // Ошибки аутентификации\r\n  | 'configuration'  // Ошибки конфигурации\r\n  | 'validation'     // Ошибки валидации данных\r\n  | 'quota'          // Превышение лимитов\r\n  | 'timeout'        // Ошибки тайм-аута\r\n  | 'cache'          // Ошибки кэширования\r\n  | 'worker'         // Ошибки воркеров\r\n  | 'unknown';       // Неизвестные ошибки\r\n\r\nexport type NetworkErrorType =\r\n  | 'connection'     // Ошибки подключения\r\n  | 'timeout'        // Таймауты сети\r\n  | 'rate_limit'     // Превышение rate limit\r\n  | 'server_error'   // Ошибки сервера (5xx)\r\n  | 'client_error'   // Ошибки клиента (4xx)\r\n  | 'dns'           // Ошибки DNS\r\n  | 'ssl';          // Ошибки SSL/TLS\r\n\r\nexport type AuthErrorType =\r\n  | 'invalid_key'               // Неверный API ключ\r\n  | 'expired_key'               // Истекший ключ\r\n  | 'insufficient_permissions'  // Недостаточно прав\r\n  | 'quota_exceeded';           // Превышена квота\r\n\r\nexport type QuotaType =\r\n  | 'api_calls'           // Лимит API вызовов\r\n  | 'tokens'              // Лимит токенов\r\n  | 'memory'              // Лимит памяти\r\n  | 'concurrent_requests' // Лимит одновременных запросов\r\n  | 'storage';            // Лимит хранилища\r\n\r\nexport type CacheOperation =\r\n  | 'read'    // Чтение из кэша\r\n  | 'write'   // Запись в кэш\r\n  | 'delete'  // Удаление из кэша\r\n  | 'clear'   // Очистка кэша\r\n  | 'init'    // Инициализация кэша\r\n  | 'SET_FAILED'      // Ошибка записи\r\n  | 'INVALIDATION_FAILED'; // Ошибка инвалидации\r\n\r\n// Интерфейсы для дополнительной информации\r\n\r\nexport interface ErrorRecoveryInfo {\r\n  /** Можно ли автоматически повторить операцию */\r\n  canRetry: boolean;\r\n\r\n  /** Задержка перед повтором в миллисекундах */\r\n  retryAfter: number;\r\n\r\n  /** Максимальное количество попыток */\r\n  maxRetries: number;\r\n\r\n  /** Доступен ли fallback механизм */\r\n  fallbackAvailable: boolean;\r\n\r\n  /** Требуется ли действие пользователя */\r\n  userActionRequired?: boolean;\r\n\r\n  /** Предлагаемые действия для исправления */\r\n  suggestedActions?: string[];\r\n}\r\n\r\nexport interface ErrorJSON {\r\n  name: string;\r\n  message: string;\r\n  code: string;\r\n  category: ErrorCategory;\r\n  context?: Record<string, any>;\r\n  recoveryInfo?: ErrorRecoveryInfo;\r\n  timestamp: string;\r\n  stack?: string;\r\n}\r\n\r\n/**\r\n * Утилитарные функции для работы с ошибками\r\n */\r\nexport class ErrorUtils {\r\n  /**\r\n   * Проверяет, является ли ошибка ошибкой эмбеддингов\r\n   */\r\n  static isEmbeddingError(error: any): error is EmbeddingError {\r\n    return error instanceof EmbeddingError;\r\n  }\r\n\r\n  /**\r\n   * Проверяет, можно ли повторить операцию после ошибки\r\n   */\r\n  static canRetry(error: Error): boolean {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error.recoveryInfo?.canRetry ?? false;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Получает задержку перед повтором\r\n   */\r\n  static getRetryDelay(error: Error): number {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error.recoveryInfo?.retryAfter ?? 1000;\r\n    }\r\n    return 1000;\r\n  }\r\n\r\n  /**\r\n   * Получает максимальное количество повторов\r\n   */\r\n  static getMaxRetries(error: Error): number {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error.recoveryInfo?.maxRetries ?? 3;\r\n    }\r\n    return 3;\r\n  }\r\n\r\n  /**\r\n   * Создает пользовательски-дружественное сообщение об ошибке\r\n   */\r\n  static getUserMessage(error: Error): string {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error.getUserMessage();\r\n    }\r\n    return error.message;\r\n  }\r\n\r\n  /**\r\n   * Получает предлагаемые действия для исправления ошибки\r\n   */\r\n  static getSuggestedActions(error: Error): string[] {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error.recoveryInfo?.suggestedActions ?? [];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Конвертирует любую ошибку в EmbeddingError\r\n   */\r\n  static toEmbeddingError(error: any, defaultMessage: string = 'Unknown error'): EmbeddingError {\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      return error;\r\n    }\r\n\r\n    if (error instanceof Error) {\r\n      return new EmbeddingError(\r\n        error.message || defaultMessage,\r\n        'UNKNOWN_ERROR',\r\n        'unknown',\r\n        { originalError: error.name, stack: error.stack }\r\n      );\r\n    }\r\n\r\n    return new EmbeddingError(\r\n      typeof error === 'string' ? error : defaultMessage,\r\n      'UNKNOWN_ERROR',\r\n      'unknown',\r\n      { originalError: error }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Логирует ошибку с соответствующим уровнем\r\n   */\r\n  static logError(error: Error, logger?: Console): void {\r\n    const log = logger || console;\r\n\r\n    if (ErrorUtils.isEmbeddingError(error)) {\r\n      const level = ErrorUtils.getLogLevel(error.category);\r\n      const logMethod = log[level] || log.error;\r\n      logMethod(`[${error.category.toUpperCase()}] ${error.name}: ${error.message}`, error.toJSON());\r\n    } else {\r\n      log.error('Unknown error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Определяет уровень логирования для категории ошибки\r\n   */\r\n  private static getLogLevel(category: ErrorCategory): 'error' | 'warn' | 'info' {\r\n    switch (category) {\r\n      case 'provider':\r\n      case 'network':\r\n      case 'authentication':\r\n      case 'worker':\r\n        return 'error';\r\n      case 'quota':\r\n      case 'timeout':\r\n        return 'warn';\r\n      case 'cache':\r\n      case 'validation':\r\n      case 'configuration':\r\n        return 'info';\r\n      default:\r\n        return 'error';\r\n    }\r\n  }\r\n}","/**\r\n * Базовый интерфейс и типы для провайдеров эмбеддингов\r\n *\r\n * Данный модуль определяет основной интерфейс EmbeddingProvider, который должны\r\n * реализовывать все провайдеры эмбеддингов (локальные и внешние).\r\n *\r\n * Ключевые принципы:\r\n * - Фиксированная размерность на экземпляр провайдера\r\n * - Конфигурация на уровне коллекций\r\n * - Неблокирующая архитектура для UI\r\n */\r\n\r\nimport type { EmbeddingConfig, CollectionEmbeddingConfig } from '../types.js';\r\nimport { EmbeddingError, ProviderError } from '../errors.js';\r\n\r\n/**\r\n * Базовый интерфейс провайдера эмбеддингов\r\n *\r\n * Каждый экземпляр провайдера имеет фиксированную размерность,\r\n * которая устанавливается при создании и не может быть изменена.\r\n */\r\nexport interface EmbeddingProvider {\r\n  /** Уникальное имя провайдера (например: 'transformers', 'openai', 'cohere') */\r\n  readonly name: string;\r\n\r\n  /** Размерность векторов, которые генерирует данный экземпляр провайдера */\r\n  readonly dimensions: number;\r\n\r\n  /** Максимальный размер батча для пакетной обработки */\r\n  readonly maxBatchSize: number;\r\n\r\n  /** Максимальная длина текста в токенах для данного провайдера */\r\n  readonly maxTextLength: number;\r\n\r\n  /** Флаг готовности провайдера к работе */\r\n  readonly isReady: boolean;\r\n\r\n  /**\r\n   * Инициализация провайдера с заданной конфигурацией\r\n   *\r\n   * @param config - Конфигурация эмбеддингов\r\n   * @throws {ProviderError} При ошибках загрузки модели или аутентификации\r\n   */\r\n  initialize(config: EmbeddingConfig): Promise<void>;\r\n\r\n  /**\r\n   * Генерация эмбеддинга для одного текста\r\n   *\r\n   * @param text - Текст для генерации эмбеддинга\r\n   * @returns Вектор размерности this.dimensions\r\n   * @throws {EmbeddingError} При ошибках генерации\r\n   */\r\n  generateEmbedding(text: string): Promise<Float32Array>;\r\n\r\n  /**\r\n   * Пакетная генерация эмбеддингов\r\n   *\r\n   * Рекомендуется для обработки больших объемов данных.\r\n   * Размер батча не должен превышать maxBatchSize.\r\n   *\r\n   * @param texts - Массив текстов для обработки\r\n   * @returns Массив векторов в том же порядке, что и входные тексты\r\n   * @throws {EmbeddingError} При ошибках генерации\r\n   */\r\n  generateBatch(texts: string[]): Promise<Float32Array[]>;\r\n\r\n  /**\r\n   * Очистка ресурсов и завершение работы провайдера\r\n   *\r\n   * Должна вызываться при завершении работы с провайдером\r\n   * для освобождения памяти и других ресурсов.\r\n   */\r\n  cleanup(): Promise<void>;\r\n\r\n  /**\r\n   * Проверка здоровья провайдера\r\n   *\r\n   * @returns Информация о состоянии провайдера\r\n   */\r\n  healthCheck(): Promise<ProviderHealthStatus>;\r\n\r\n  /**\r\n   * Получение статистики работы провайдера\r\n   *\r\n   * @returns Метрики производительности\r\n   */\r\n  getMetrics(): ProviderMetrics;\r\n}\r\n\r\n/**\r\n * Статус здоровья провайдера\r\n */\r\nexport interface ProviderHealthStatus {\r\n  /** Готов ли провайдер к работе */\r\n  isHealthy: boolean;\r\n\r\n  /** Время последней успешной операции */\r\n  lastSuccessfulOperation?: Date;\r\n\r\n  /** Описание текущего состояния */\r\n  status: 'ready' | 'initializing' | 'error' | 'degraded';\r\n\r\n  /** Дополнительная информация о состоянии */\r\n  details?: string;\r\n\r\n  /** Доступная память (для локальных провайдеров) */\r\n  availableMemory?: number;\r\n\r\n  /** Состояние подключения (для внешних API) */\r\n  connectionStatus?: 'connected' | 'disconnected' | 'limited';\r\n}\r\n\r\n/**\r\n * Метрики производительности провайдера\r\n */\r\nexport interface ProviderMetrics {\r\n  /** Общее количество сгенерированных эмбеддингов */\r\n  totalEmbeddings: number;\r\n\r\n  /** Среднее время генерации одного эмбеддинга (мс) */\r\n  averageGenerationTime: number;\r\n\r\n  /** Количество ошибок */\r\n  errorCount: number;\r\n\r\n  /** Время последнего сброса метрик */\r\n  metricsResetTime: Date;\r\n\r\n  /** Использование памяти (байты) */\r\n  memoryUsage?: number;\r\n\r\n  /** Количество запросов к внешнему API */\r\n  apiRequestCount?: number;\r\n\r\n  /** Скорость ограничений (requests per minute) */\r\n  rateLimitStatus?: {\r\n    remaining: number;\r\n    resetTime: Date;\r\n  };\r\n}\r\n\r\n/**\r\n * Результат валидации конфигурации провайдера\r\n */\r\nexport interface ProviderConfigValidation {\r\n  /** Валидна ли конфигурация */\r\n  isValid: boolean;\r\n\r\n  /** Ошибки валидации */\r\n  errors: string[];\r\n\r\n  /** Предупреждения */\r\n  warnings: string[];\r\n\r\n  /** Рекомендуемые исправления */\r\n  suggestions: string[];\r\n}\r\n\r\n/**\r\n * Абстрактный базовый класс для провайдеров эмбеддингов\r\n *\r\n * Предоставляет общую функциональность и валидацию для всех провайдеров.\r\n */\r\nexport abstract class BaseEmbeddingProvider implements EmbeddingProvider {\r\n  public readonly name: string;\r\n  public readonly dimensions: number;\r\n  public readonly maxBatchSize: number;\r\n  public readonly maxTextLength: number;\r\n\r\n  protected _isReady = false;\r\n  protected metrics: ProviderMetrics;\r\n  protected config?: EmbeddingConfig;\r\n\r\n  constructor(\r\n    name: string,\r\n    dimensions: number,\r\n    maxBatchSize: number = 32,\r\n    maxTextLength: number = 512\r\n  ) {\r\n    this.name = name;\r\n    this.dimensions = dimensions;\r\n    this.maxBatchSize = maxBatchSize;\r\n    this.maxTextLength = maxTextLength;\r\n\r\n    this.metrics = {\r\n      totalEmbeddings: 0,\r\n      averageGenerationTime: 0,\r\n      errorCount: 0,\r\n      metricsResetTime: new Date()\r\n    };\r\n  }\r\n\r\n  public get isReady(): boolean {\r\n    return this._isReady;\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации провайдера\r\n   *\r\n   * @param config - Конфигурация для валидации\r\n   * @returns Результат валидации\r\n   */\r\n  public validateConfig(config: EmbeddingConfig): ProviderConfigValidation {\r\n    const errors: string[] = [];\r\n    const warnings: string[] = [];\r\n    const suggestions: string[] = [];\r\n\r\n    // Базовая валидация\r\n    if (!config.provider && !config.defaultProvider) {\r\n      errors.push('Provider type is required');\r\n    }\r\n\r\n    if (config.timeout && config.timeout < 1000) {\r\n      warnings.push('Timeout less than 1 second may cause frequent timeouts');\r\n      suggestions.push('Consider increasing timeout to at least 5000ms');\r\n    }\r\n\r\n    if (config.batchSize && config.batchSize > this.maxBatchSize) {\r\n      errors.push(`Batch size ${config.batchSize} exceeds maximum ${this.maxBatchSize}`);\r\n      suggestions.push(`Set batch size to ${this.maxBatchSize} or less`);\r\n    }\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n      suggestions\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Валидация входного текста\r\n   *\r\n   * @param text - Текст для валидации\r\n   * @throws {EmbeddingError} При невалидном тексте\r\n   */\r\n  protected validateText(text: string): void {\r\n    if (!text || typeof text !== 'string') {\r\n      throw new EmbeddingError('Input text must be a non-empty string');\r\n    }\r\n\r\n    if (text.trim().length === 0) {\r\n      throw new EmbeddingError('Input text cannot be empty or whitespace only');\r\n    }\r\n\r\n    // Проверка длины (примерная оценка токенов)\r\n    const estimatedTokens = text.length / 4; // Примерно 4 символа на токен\r\n    if (estimatedTokens > this.maxTextLength) {\r\n      throw new EmbeddingError(\r\n        `Text too long: ~${Math.round(estimatedTokens)} tokens, max: ${this.maxTextLength}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Валидация массива текстов для пакетной обработки\r\n   *\r\n   * @param texts - Массив текстов для валидации\r\n   * @throws {EmbeddingError} При невалидных данных\r\n   */\r\n  protected validateBatch(texts: string[]): void {\r\n    if (!Array.isArray(texts)) {\r\n      throw new EmbeddingError('Input must be an array of strings');\r\n    }\r\n\r\n    if (texts.length === 0) {\r\n      throw new EmbeddingError('Batch cannot be empty');\r\n    }\r\n\r\n    if (texts.length > this.maxBatchSize) {\r\n      throw new EmbeddingError(\r\n        `Batch size ${texts.length} exceeds maximum ${this.maxBatchSize}`\r\n      );\r\n    }\r\n\r\n    // Валидация каждого текста\r\n    texts.forEach((text, index) => {\r\n      try {\r\n        this.validateText(text);\r\n      } catch (error) {\r\n        throw new EmbeddingError(\r\n          `Invalid text at index ${index}: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Обновление метрик производительности\r\n   *\r\n   * @param generationTime - Время генерации в миллисекундах\r\n   * @param embeddingCount - Количество сгенерированных эмбеддингов\r\n   * @param isError - Была ли ошибка\r\n   */\r\n  protected updateMetrics(generationTime: number, embeddingCount: number = 1, isError: boolean = false): void {\r\n    if (isError) {\r\n      this.metrics.errorCount += 1;\r\n      return;\r\n    }\r\n\r\n    const totalTime = this.metrics.averageGenerationTime * this.metrics.totalEmbeddings;\r\n    this.metrics.totalEmbeddings += embeddingCount;\r\n    this.metrics.averageGenerationTime = (totalTime + generationTime) / this.metrics.totalEmbeddings;\r\n  }\r\n\r\n  /**\r\n   * Сброс метрик производительности\r\n   */\r\n  public resetMetrics(): void {\r\n    this.metrics = {\r\n      totalEmbeddings: 0,\r\n      averageGenerationTime: 0,\r\n      errorCount: 0,\r\n      metricsResetTime: new Date()\r\n    };\r\n  }\r\n\r\n  public getMetrics(): ProviderMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  // Абстрактные методы, которые должны быть реализованы в дочерних классах\r\n  public abstract initialize(config: EmbeddingConfig): Promise<void>;\r\n  public abstract generateEmbedding(text: string): Promise<Float32Array>;\r\n  public abstract generateBatch(texts: string[]): Promise<Float32Array[]>;\r\n  public abstract cleanup(): Promise<void>;\r\n  public abstract healthCheck(): Promise<ProviderHealthStatus>;\r\n}\r\n\r\n/**\r\n * Фабрика для создания провайдеров эмбеддингов\r\n */\r\nexport interface EmbeddingProviderFactory {\r\n  /**\r\n   * Создание экземпляра провайдера\r\n   *\r\n   * @param config - Конфигурация коллекции\r\n   * @returns Экземпляр провайдера с фиксированной размерностью\r\n   */\r\n  createProvider(config: CollectionEmbeddingConfig): Promise<EmbeddingProvider>;\r\n\r\n  /**\r\n   * Проверка поддержки конфигурации\r\n   *\r\n   * @param config - Конфигурация для проверки\r\n   * @returns true, если конфигурация поддерживается\r\n   */\r\n  supportsConfig(config: CollectionEmbeddingConfig): boolean;\r\n\r\n  /**\r\n   * Получение доступных моделей для провайдера\r\n   *\r\n   * @returns Список доступных моделей с их характеристиками\r\n   */\r\n  getAvailableModels(): Promise<ModelInfo[]>;\r\n}\r\n\r\n/**\r\n * Информация о доступной модели\r\n */\r\nexport interface ModelInfo {\r\n  /** Идентификатор модели */\r\n  id: string;\r\n\r\n  /** Отображаемое название */\r\n  name: string;\r\n\r\n  /** Описание модели */\r\n  description: string;\r\n\r\n  /** Размерность векторов */\r\n  dimensions: number;\r\n\r\n  /** Максимальная длина входного текста */\r\n  maxInputLength: number;\r\n\r\n  /** Поддерживаемые языки */\r\n  languages: string[];\r\n\r\n  /** Рекомендуемые случаи использования */\r\n  useCases: string[];\r\n\r\n  /** Размер модели (для локальных моделей) */\r\n  modelSize?: number;\r\n\r\n  /** Стоимость за токен (для API) */\r\n  costPerToken?: number;\r\n}\r\n\r\n/**\r\n * Вспомогательные функции для работы с провайдерами\r\n */\r\nexport class ProviderUtils {\r\n  /**\r\n   * Нормализация вектора эмбеддинга\r\n   *\r\n   * @param embedding - Вектор для нормализации\r\n   * @returns Нормализованный вектор\r\n   */\r\n  static normalizeEmbedding(embedding: Float32Array): Float32Array {\r\n    let norm = 0;\r\n    for (let i = 0; i < embedding.length; i++) {\r\n      norm += embedding[i] * embedding[i];\r\n    }\r\n    norm = Math.sqrt(norm);\r\n\r\n    if (norm === 0) {\r\n      throw new EmbeddingError('Cannot normalize zero vector');\r\n    }\r\n\r\n    const normalized = new Float32Array(embedding.length);\r\n    for (let i = 0; i < embedding.length; i++) {\r\n      normalized[i] = embedding[i] / norm;\r\n    }\r\n\r\n    return normalized;\r\n  }\r\n\r\n  /**\r\n   * Вычисление косинусного расстояния между векторами\r\n   *\r\n   * @param a - Первый вектор\r\n   * @param b - Второй вектор\r\n   * @returns Косинусное расстояние (0 = идентичные, 2 = противоположные)\r\n   */\r\n  static cosineDistance(a: Float32Array, b: Float32Array): number {\r\n    if (a.length !== b.length) {\r\n      throw new EmbeddingError('Vectors must have the same dimensions');\r\n    }\r\n\r\n    let dotProduct = 0;\r\n    let normA = 0;\r\n    let normB = 0;\r\n\r\n    for (let i = 0; i < a.length; i++) {\r\n      dotProduct += a[i] * b[i];\r\n      normA += a[i] * a[i];\r\n      normB += b[i] * b[i];\r\n    }\r\n\r\n    normA = Math.sqrt(normA);\r\n    normB = Math.sqrt(normB);\r\n\r\n    if (normA === 0 || normB === 0) {\r\n      return 2; // Максимальное расстояние для нулевых векторов\r\n    }\r\n\r\n    const cosineSimilarity = dotProduct / (normA * normB);\r\n    return 1 - cosineSimilarity; // Конвертация в расстояние\r\n  }\r\n\r\n  /**\r\n   * Создание случайного вектора (для тестирования)\r\n   *\r\n   * @param dimensions - Размерность вектора\r\n   * @param normalize - Нормализовать ли вектор\r\n   * @returns Случайный вектор\r\n   */\r\n  static createRandomEmbedding(dimensions: number, normalize: boolean = true): Float32Array {\r\n    const embedding = new Float32Array(dimensions);\r\n    for (let i = 0; i < dimensions; i++) {\r\n      embedding[i] = Math.random() * 2 - 1; // Значения от -1 до 1\r\n    }\r\n\r\n    return normalize ? this.normalizeEmbedding(embedding) : embedding;\r\n  }\r\n}","/**\r\n * Базовый класс для внешних провайдеров эмбеддингов (API)\r\n *\r\n * Данный модуль предоставляет общую функциональность для всех провайдеров,\r\n * которые используют внешние API для генерации эмбеддингов.\r\n *\r\n * Ключевые возможности:\r\n * - Управление API ключами\r\n * - Rate limiting с exponential backoff\r\n * - Retry логика\r\n * - Метрики API запросов\r\n * - Обработка сетевых ошибок\r\n */\r\n\r\nimport { BaseEmbeddingProvider, ProviderHealthStatus, ProviderMetrics } from './BaseProvider.js';\r\nimport type { EmbeddingConfig } from '../types.js';\r\nimport {\r\n  EmbeddingError,\r\n  ProviderError,\r\n  NetworkError,\r\n  AuthenticationError,\r\n  QuotaExceededError,\r\n  TimeoutError\r\n} from '../errors.js';\r\n\r\n/**\r\n * Конфигурация для внешних API провайдеров\r\n */\r\nexport interface ExternalProviderConfig {\r\n  /** API ключ (обязателен для внешних провайдеров) */\r\n  apiKey: string;\r\n\r\n  /** Базовый URL для API (опционально) */\r\n  baseUrl?: string;\r\n\r\n  /** Таймаут запросов в миллисекундах */\r\n  timeout?: number;\r\n\r\n  /** Максимальное количество попыток */\r\n  maxRetries?: number;\r\n\r\n  /** Включить ли rate limiting */\r\n  enableRateLimit?: boolean;\r\n\r\n  /** Лимит запросов в минуту */\r\n  requestsPerMinute?: number;\r\n\r\n  /** Дополнительные заголовки */\r\n  headers?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Информация о rate limiting\r\n */\r\ninterface RateLimitInfo {\r\n  /** Количество оставшихся запросов */\r\n  remaining: number;\r\n\r\n  /** Время сброса лимита */\r\n  resetTime: Date;\r\n\r\n  /** Максимальное количество запросов в периоде */\r\n  limit: number;\r\n}\r\n\r\n/**\r\n * Состояние retry попыток\r\n */\r\ninterface RetryState {\r\n  /** Текущая попытка */\r\n  attempt: number;\r\n\r\n  /** Время последней попытки */\r\n  lastAttempt: Date;\r\n\r\n  /** Задержка перед следующей попытками */\r\n  nextDelay: number;\r\n}\r\n\r\n/**\r\n * Абстрактный базовый класс для внешних API провайдеров\r\n */\r\nexport abstract class ExternalProvider extends BaseEmbeddingProvider {\r\n  protected config?: EmbeddingConfig & ExternalProviderConfig;\r\n  protected rateLimitInfo?: RateLimitInfo;\r\n  protected requestQueue: Array<() => void> = [];\r\n  protected isProcessingQueue = false;\r\n  protected lastRequestTime = 0;\r\n  protected retryStates = new Map<string, RetryState>();\r\n\r\n  // Конфигурация по умолчанию для внешних провайдеров\r\n  private static readonly DEFAULT_CONFIG = {\r\n    timeout: 30000,\r\n    maxRetries: 3,\r\n    enableRateLimit: true,\r\n    requestsPerMinute: 60\r\n  };\r\n\r\n  constructor(\r\n    name: string,\r\n    dimensions: number,\r\n    maxBatchSize: number = 16, // Меньший размер батча для API\r\n    maxTextLength: number = 8192 // Больше символов для API\r\n  ) {\r\n    super(name, dimensions, maxBatchSize, maxTextLength);\r\n  }\r\n\r\n  /**\r\n   * Инициализация внешнего провайдера\r\n   */\r\n  public async initialize(config: EmbeddingConfig): Promise<void> {\r\n    // Валидация конфигурации\r\n    const validation = this.validateConfig(config);\r\n    if (!validation.isValid) {\r\n      throw new ProviderError(\r\n        `Configuration validation failed: ${validation.errors.join(', ')}`,\r\n        this.name,\r\n        'CONFIG_VALIDATION_ERROR'\r\n      );\r\n    }\r\n\r\n    // Проверка обязательного API ключа\r\n    if (!config.apiKey) {\r\n      throw new AuthenticationError(\r\n        'API key is required for external providers',\r\n        'invalid_key',\r\n        { provider: this.name }\r\n      );\r\n    }\r\n\r\n    // Настройка конфигурации провайдера\r\n    this.config = {\r\n      ...ExternalProvider.DEFAULT_CONFIG,\r\n      ...config,\r\n      apiKey: config.apiKey,\r\n      baseUrl: (config as any).providerOptions?.baseUrl,\r\n      timeout: (config as any).timeout || ExternalProvider.DEFAULT_CONFIG.timeout,\r\n      maxRetries: (config as any).maxRetries || ExternalProvider.DEFAULT_CONFIG.maxRetries,\r\n      enableRateLimit: (config as any).providerOptions?.enableRateLimit ?? ExternalProvider.DEFAULT_CONFIG.enableRateLimit,\r\n      requestsPerMinute: (config as any).providerOptions?.requestsPerMinute || ExternalProvider.DEFAULT_CONFIG.requestsPerMinute,\r\n      headers: (config as any).providerOptions?.headers || {}\r\n    } as any;\r\n\r\n    // Инициализация rate limiting\r\n    if (this.config?.enableRateLimit) {\r\n      this.initializeRateLimit();\r\n    }\r\n\r\n    // Выполнение специфичной для провайдера инициализации\r\n    await this.initializeProvider(this.config!);\r\n\r\n    // Проверка здоровья после инициализации\r\n    const health = await this.healthCheck();\r\n    if (!health.isHealthy) {\r\n      throw new ProviderError(\r\n        `Provider health check failed: ${health.details}`,\r\n        this.name,\r\n        'HEALTH_CHECK_FAILED'\r\n      );\r\n    }\r\n\r\n    this._isReady = true;\r\n  }\r\n\r\n  /**\r\n   * Генерация одного эмбеддинга с retry логикой\r\n   */\r\n  public async generateEmbedding(text: string): Promise<Float32Array> {\r\n    this.validateText(text);\r\n\r\n    const startTime = Date.now();\r\n    let lastError: Error | null = null;\r\n\r\n    const maxRetries = this.config?.maxRetries || 3;\r\n\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        // Ожидание rate limit если необходимо\r\n        await this.waitForRateLimit();\r\n\r\n        // Выполнение запроса\r\n        const embedding = await this.executeEmbeddingRequest([text]);\r\n\r\n        // Обновление метрик\r\n        const generationTime = Date.now() - startTime;\r\n        this.updateMetrics(generationTime, 1, false);\r\n        this.updateApiMetrics(1, true);\r\n\r\n        return embedding[0];\r\n\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n\r\n        // Проверяем, можно ли повторить запрос\r\n        if (attempt < maxRetries && this.shouldRetry(error as Error)) {\r\n          const delay = this.calculateRetryDelay(attempt, error as Error);\r\n          await this.sleep(delay);\r\n          continue;\r\n        }\r\n\r\n        // Если все попытки исчерпаны или ошибка не подлежит повтору\r\n        this.updateMetrics(Date.now() - startTime, 0, true);\r\n        this.updateApiMetrics(1, false);\r\n        throw this.wrapError(error as Error);\r\n      }\r\n    }\r\n\r\n    // Этот код не должен выполняться, но добавляем для типизации\r\n    throw this.wrapError(lastError || new Error('Unknown error during embedding generation'));\r\n  }\r\n\r\n  /**\r\n   * Пакетная генерация эмбеддингов\r\n   */\r\n  public async generateBatch(texts: string[]): Promise<Float32Array[]> {\r\n    this.validateBatch(texts);\r\n\r\n    const startTime = Date.now();\r\n    let lastError: Error | null = null;\r\n\r\n    const maxRetries = this.config?.maxRetries || 3;\r\n\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        // Ожидание rate limit если необходимо\r\n        await this.waitForRateLimit();\r\n\r\n        // Выполнение запроса\r\n        const embeddings = await this.executeEmbeddingRequest(texts);\r\n\r\n        // Обновление метрик\r\n        const generationTime = Date.now() - startTime;\r\n        this.updateMetrics(generationTime, texts.length, false);\r\n        this.updateApiMetrics(1, true);\r\n\r\n        return embeddings;\r\n\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n\r\n        // Проверяем, можно ли повторить запрос\r\n        if (attempt < maxRetries && this.shouldRetry(error as Error)) {\r\n          const delay = this.calculateRetryDelay(attempt, error as Error);\r\n          await this.sleep(delay);\r\n          continue;\r\n        }\r\n\r\n        // Если все попытки исчерпаны или ошибка не подлежит повтору\r\n        this.updateMetrics(Date.now() - startTime, 0, true);\r\n        this.updateApiMetrics(1, false);\r\n        throw this.wrapError(error as Error);\r\n      }\r\n    }\r\n\r\n    // Этот код не должен выполняться, но добавляем для типизации\r\n    throw this.wrapError(lastError || new Error('Unknown error during batch embedding generation'));\r\n  }\r\n\r\n  /**\r\n   * Проверка здоровья провайдера\r\n   */\r\n  public async healthCheck(): Promise<ProviderHealthStatus> {\r\n    try {\r\n      // Проверяем наличие конфигурации (не проверяем _isReady во время инициализации)\r\n      if (!this.config) {\r\n        return {\r\n          isHealthy: false,\r\n          status: 'error',\r\n          details: 'Provider not initialized',\r\n          connectionStatus: 'disconnected'\r\n        };\r\n      }\r\n\r\n      // Выполняем специфичную для провайдера проверку\r\n      const isHealthy = await this.checkProviderHealth();\r\n\r\n      return {\r\n        isHealthy,\r\n        status: isHealthy ? 'ready' : 'error',\r\n        lastSuccessfulOperation: this.getLastSuccessfulOperation(),\r\n        connectionStatus: isHealthy ? 'connected' : 'disconnected',\r\n        details: isHealthy ? 'Provider is healthy' : 'Provider health check failed'\r\n      };\r\n\r\n    } catch (error) {\r\n      return {\r\n        isHealthy: false,\r\n        status: 'error',\r\n        details: error instanceof Error ? error.message : 'Unknown health check error',\r\n        connectionStatus: 'disconnected'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение метрик с информацией об API\r\n   */\r\n  public getMetrics(): ProviderMetrics {\r\n    const baseMetrics = super.getMetrics();\r\n\r\n    return {\r\n      ...baseMetrics,\r\n      apiRequestCount: this.getApiRequestCount(),\r\n      rateLimitStatus: this.rateLimitInfo ? {\r\n        remaining: this.rateLimitInfo.remaining,\r\n        resetTime: this.rateLimitInfo.resetTime\r\n      } : undefined\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Очистка ресурсов\r\n   */\r\n  public async cleanup(): Promise<void> {\r\n    // Очищаем очередь запросов\r\n    this.requestQueue = [];\r\n    this.isProcessingQueue = false;\r\n\r\n    // Очищаем состояния retry\r\n    this.retryStates.clear();\r\n\r\n    // Сбрасываем готовность\r\n    this._isReady = false;\r\n\r\n    // Выполняем специфичную для провайдера очистку\r\n    await this.cleanupProvider();\r\n  }\r\n\r\n  // Абстрактные методы для реализации в дочерних классах\r\n\r\n  /**\r\n   * Инициализация специфичная для провайдера\r\n   */\r\n  protected abstract initializeProvider(config: ExternalProviderConfig): Promise<void>;\r\n\r\n  /**\r\n   * Выполнение запроса к API для генерации эмбеддингов\r\n   */\r\n  protected abstract executeEmbeddingRequest(texts: string[]): Promise<Float32Array[]>;\r\n\r\n  /**\r\n   * Проверка здоровья специфичная для провайдера\r\n   */\r\n  protected abstract checkProviderHealth(): Promise<boolean>;\r\n\r\n  /**\r\n   * Очистка ресурсов специфичная для провайдера\r\n   */\r\n  protected abstract cleanupProvider(): Promise<void>;\r\n\r\n  // Приватные методы для управления rate limiting и retry логикой\r\n\r\n  /**\r\n   * Инициализация rate limiting\r\n   */\r\n  private initializeRateLimit(): void {\r\n    const requestsPerMinute = this.config?.requestsPerMinute || 60;\r\n    this.rateLimitInfo = {\r\n      remaining: requestsPerMinute,\r\n      resetTime: new Date(Date.now() + 60000), // Сброс через минуту\r\n      limit: requestsPerMinute\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Ожидание rate limit\r\n   */\r\n  private async waitForRateLimit(): Promise<void> {\r\n    if (!this.config?.enableRateLimit || !this.rateLimitInfo) {\r\n      return;\r\n    }\r\n\r\n    // Проверяем, нужно ли сбросить счетчик\r\n    if (Date.now() >= this.rateLimitInfo.resetTime.getTime()) {\r\n      this.rateLimitInfo.remaining = this.rateLimitInfo.limit;\r\n      this.rateLimitInfo.resetTime = new Date(Date.now() + 60000);\r\n    }\r\n\r\n    // Если нет оставшихся запросов, ждем до сброса\r\n    if (this.rateLimitInfo.remaining <= 0) {\r\n      const waitTime = this.rateLimitInfo.resetTime.getTime() - Date.now();\r\n      if (waitTime > 0) {\r\n        await this.sleep(waitTime);\r\n        // После ожидания сбрасываем счетчик\r\n        this.rateLimitInfo.remaining = this.rateLimitInfo.limit;\r\n        this.rateLimitInfo.resetTime = new Date(Date.now() + 60000);\r\n      }\r\n    }\r\n\r\n    // Уменьшаем счетчик оставшихся запросов\r\n    this.rateLimitInfo.remaining--;\r\n  }\r\n\r\n  /**\r\n   * Проверка, можно ли повторить запрос после ошибки\r\n   */\r\n  private shouldRetry(error: Error): boolean {\r\n    // Не повторяем при ошибках аутентификации\r\n    if (error instanceof AuthenticationError) {\r\n      return false;\r\n    }\r\n\r\n    // Не повторяем при ошибках конфигурации\r\n    if (error instanceof EmbeddingError && error.category === 'configuration') {\r\n      return false;\r\n    }\r\n\r\n    // Повторяем при сетевых ошибках\r\n    if (error instanceof NetworkError) {\r\n      return error.recoveryInfo?.canRetry ?? false;\r\n    }\r\n\r\n    // Повторяем при превышении квот (rate limit)\r\n    if (error instanceof QuotaExceededError) {\r\n      return true;\r\n    }\r\n\r\n    // Повторяем при таймаутах\r\n    if (error instanceof TimeoutError) {\r\n      return true;\r\n    }\r\n\r\n    // По умолчанию не повторяем\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Вычисление задержки для retry с exponential backoff\r\n   */\r\n  private calculateRetryDelay(attempt: number, error: Error): number {\r\n    // Базовая задержка\r\n    let baseDelay = 1000;\r\n\r\n    // Увеличиваем задержку для разных типов ошибок\r\n    if (error instanceof QuotaExceededError && error.resetTime) {\r\n      // Для rate limit ждем до сброса\r\n      return Math.max(error.resetTime.getTime() - Date.now(), 0);\r\n    }\r\n\r\n    if (error instanceof NetworkError) {\r\n      baseDelay = error.recoveryInfo?.retryAfter || 2000;\r\n    }\r\n\r\n    if (error instanceof TimeoutError) {\r\n      baseDelay = Math.min(error.timeoutMs * 0.5, 5000);\r\n    }\r\n\r\n    // Exponential backoff: 2^attempt * baseDelay + jitter\r\n    const exponentialDelay = Math.pow(2, attempt - 1) * baseDelay;\r\n    const jitter = Math.random() * 1000; // Добавляем случайность\r\n\r\n    return Math.min(exponentialDelay + jitter, 30000); // Максимум 30 секунд\r\n  }\r\n\r\n  /**\r\n   * Обертывание ошибок в специфичные типы\r\n   */\r\n  private wrapError(error: Error): EmbeddingError {\r\n    if (error instanceof EmbeddingError) {\r\n      return error;\r\n    }\r\n\r\n    // Обработка стандартных HTTP ошибок\r\n    if (error.message.includes('401') || error.message.includes('Unauthorized')) {\r\n      return new AuthenticationError(\r\n        'Invalid API key or unauthorized access',\r\n        'invalid_key',\r\n        { provider: this.name, originalError: error.message }\r\n      );\r\n    }\r\n\r\n    if (error.message.includes('429') || error.message.includes('rate limit')) {\r\n      return new QuotaExceededError(\r\n        'API rate limit exceeded',\r\n        'api_calls',\r\n        0,\r\n        this.rateLimitInfo?.limit || 0,\r\n        this.rateLimitInfo?.resetTime,\r\n        { provider: this.name, originalError: error.message }\r\n      );\r\n    }\r\n\r\n    if (error.message.includes('timeout') || error.name === 'TimeoutError') {\r\n      return new TimeoutError(\r\n        'Request timeout',\r\n        this.config?.timeout || 30000,\r\n        'embedding_generation',\r\n        { provider: this.name, originalError: error.message }\r\n      );\r\n    }\r\n\r\n    // Сетевые ошибки\r\n    if (error.message.includes('fetch') || error.message.includes('network')) {\r\n      return new NetworkError(\r\n        error.message,\r\n        'connection',\r\n        undefined,\r\n        undefined,\r\n        { provider: this.name }\r\n      );\r\n    }\r\n\r\n    // Общая ошибка провайдера\r\n    return new ProviderError(\r\n      error.message,\r\n      this.name,\r\n      'UNKNOWN_PROVIDER_ERROR',\r\n      undefined,\r\n      { originalError: error.message, stack: error.stack }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Обновление метрик API запросов\r\n   */\r\n  private updateApiMetrics(requestCount: number, success: boolean): void {\r\n    if (!this.metrics.apiRequestCount) {\r\n      this.metrics.apiRequestCount = 0;\r\n    }\r\n    this.metrics.apiRequestCount += requestCount;\r\n\r\n    if (success) {\r\n      (this.metrics as any).lastSuccessfulOperation = new Date();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение количества API запросов\r\n   */\r\n  private getApiRequestCount(): number {\r\n    return this.metrics.apiRequestCount || 0;\r\n  }\r\n\r\n  /**\r\n   * Получение времени последней успешной операции\r\n   */\r\n  private getLastSuccessfulOperation(): Date | undefined {\r\n    return (this.metrics as any).lastSuccessfulOperation;\r\n  }\r\n\r\n  /**\r\n   * Утилита для задержки\r\n   */\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n}","/**\r\n * OpenAI провайдер эмбеддингов для LocalRetrieve\r\n *\r\n * Данный модуль реализует провайдер эмбеддингов для OpenAI Embeddings API,\r\n * поддерживающий модель text-embedding-3-small с конфигурируемыми размерностями.\r\n *\r\n * Поддерживаемые возможности:\r\n * - text-embedding-3-small модель\r\n * - Конфигурируемые размерности: 384, 768, 1536\r\n * - Автоматический retry с exponential backoff\r\n * - Rate limiting и quota management\r\n * - Пакетная обработка запросов\r\n * - Secure API key handling (только в памяти)\r\n */\r\n\r\nimport { ExternalProvider, ExternalProviderConfig } from './ExternalProvider.js';\r\nimport type { EmbeddingConfig } from '../types.js';\r\nimport {\r\n  ProviderError,\r\n  NetworkError,\r\n  AuthenticationError,\r\n  QuotaExceededError,\r\n  ValidationError,\r\n  ConfigurationError\r\n} from '../errors.js';\r\n\r\n/**\r\n * Конфигурация OpenAI провайдера\r\n */\r\ninterface OpenAIConfig extends ExternalProviderConfig {\r\n  /** Модель для использования (по умолчанию text-embedding-3-small) */\r\n  model?: string;\r\n\r\n  /** Размерность выходных векторов */\r\n  dimensions: number;\r\n\r\n  /** Организация OpenAI (опционально) */\r\n  organization?: string;\r\n\r\n  /** Пользователь для отслеживания использования */\r\n  user?: string;\r\n}\r\n\r\n/**\r\n * Поддерживаемые модели OpenAI\r\n */\r\nconst OPENAI_MODELS = {\r\n  'text-embedding-3-small': {\r\n    name: 'text-embedding-3-small',\r\n    maxInputTokens: 8191,\r\n    defaultDimensions: 1536,\r\n    supportedDimensions: [384, 768, 1536],\r\n    costPer1MTokens: 0.02 // USD\r\n  },\r\n  'text-embedding-3-large': {\r\n    name: 'text-embedding-3-large',\r\n    maxInputTokens: 8191,\r\n    defaultDimensions: 3072,\r\n    supportedDimensions: [256, 512, 1024, 3072],\r\n    costPer1MTokens: 0.13 // USD\r\n  },\r\n  'text-embedding-ada-002': {\r\n    name: 'text-embedding-ada-002',\r\n    maxInputTokens: 8191,\r\n    defaultDimensions: 1536,\r\n    supportedDimensions: [1536],\r\n    costPer1MTokens: 0.10 // USD\r\n  }\r\n} as const;\r\n\r\n/**\r\n * Структура запроса к OpenAI API\r\n */\r\ninterface OpenAIEmbeddingRequest {\r\n  /** Модель для использования */\r\n  model: string;\r\n\r\n  /** Входной текст или массив текстов */\r\n  input: string | string[];\r\n\r\n  /** Размерность выходных векторов (опционально) */\r\n  dimensions?: number;\r\n\r\n  /** Пользователь для отслеживания */\r\n  user?: string;\r\n\r\n  /** Кодировка (всегда float для нашего случая) */\r\n  encoding_format?: 'float' | 'base64';\r\n}\r\n\r\n/**\r\n * Структура ответа от OpenAI API\r\n */\r\ninterface OpenAIEmbeddingResponse {\r\n  /** Тип объекта */\r\n  object: 'list';\r\n\r\n  /** Данные эмбеддингов */\r\n  data: Array<{\r\n    object: 'embedding';\r\n    index: number;\r\n    embedding: number[];\r\n  }>;\r\n\r\n  /** Модель, которая была использована */\r\n  model: string;\r\n\r\n  /** Информация об использовании токенов */\r\n  usage: {\r\n    prompt_tokens: number;\r\n    total_tokens: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Структура ошибки OpenAI API\r\n */\r\ninterface OpenAIErrorResponse {\r\n  error: {\r\n    message: string;\r\n    type: string;\r\n    param?: string;\r\n    code?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * OpenAI провайдер эмбеддингов\r\n */\r\nexport class OpenAIProvider extends ExternalProvider {\r\n  private openaiConfig?: OpenAIConfig;\r\n  private model: string;\r\n  private supportedDimensions: number[];\r\n  private maxInputTokens: number;\r\n\r\n  /**\r\n   * Создание экземпляра OpenAI провайдера\r\n   *\r\n   * @param dimensions - Размерность векторов эмбеддингов\r\n   * @param model - Модель OpenAI (по умолчанию text-embedding-3-small)\r\n   */\r\n  constructor(\r\n    dimensions: number,\r\n    model: string = 'text-embedding-3-small'\r\n  ) {\r\n    // Валидация модели\r\n    if (!(model in OPENAI_MODELS)) {\r\n      throw new ConfigurationError(\r\n        `Unsupported OpenAI model: ${model}`,\r\n        'model',\r\n        `One of: ${Object.keys(OPENAI_MODELS).join(', ')}`,\r\n        model\r\n      );\r\n    }\r\n\r\n    const modelInfo = OPENAI_MODELS[model as keyof typeof OPENAI_MODELS];\r\n\r\n    // Валидация размерности для выбранной модели\r\n    if (!(modelInfo.supportedDimensions as readonly number[]).includes(dimensions)) {\r\n      throw new ConfigurationError(\r\n        `Unsupported dimensions ${dimensions} for model ${model}`,\r\n        'dimensions',\r\n        `One of: ${modelInfo.supportedDimensions.join(', ')}`,\r\n        dimensions\r\n      );\r\n    }\r\n\r\n    super(\r\n      'openai',\r\n      dimensions,\r\n      100, // OpenAI поддерживает большие батчи\r\n      modelInfo.maxInputTokens * 4 // Приблизительно 4 символа на токен\r\n    );\r\n\r\n    this.model = model;\r\n    this.supportedDimensions = [...modelInfo.supportedDimensions];\r\n    this.maxInputTokens = modelInfo.maxInputTokens;\r\n  }\r\n\r\n  /**\r\n   * Инициализация OpenAI провайдера\r\n   */\r\n  protected async initializeProvider(config: ExternalProviderConfig): Promise<void> {\r\n    // Создание конфигурации OpenAI\r\n    this.openaiConfig = {\r\n      ...config,\r\n      model: this.model,\r\n      dimensions: this.dimensions,\r\n      baseUrl: config.baseUrl || 'https://api.openai.com/v1',\r\n      organization: config.headers?.['OpenAI-Organization'],\r\n      user: config.headers?.['OpenAI-User']\r\n    };\r\n\r\n    // Валидация API ключа\r\n    if (!this.openaiConfig.apiKey.startsWith('sk-')) {\r\n      throw new AuthenticationError(\r\n        'Invalid OpenAI API key format. Must start with \"sk-\"',\r\n        'invalid_key',\r\n        { provider: this.name }\r\n      );\r\n    }\r\n\r\n    // Выполнение тестового запроса для проверки аутентификации\r\n    try {\r\n      await this.executeEmbeddingRequest(['test']);\r\n    } catch (error) {\r\n      // Если это ошибка аутентификации, пробрасываем её\r\n      if (error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      // Для других ошибок продолжаем инициализацию\r\n      console.warn(`OpenAI provider test request failed: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Выполнение запроса к OpenAI API для генерации эмбеддингов\r\n   */\r\n  protected async executeEmbeddingRequest(texts: string[]): Promise<Float32Array[]> {\r\n    if (!this.openaiConfig) {\r\n      throw new ProviderError(\r\n        'Provider not initialized',\r\n        this.name,\r\n        'PROVIDER_NOT_INITIALIZED'\r\n      );\r\n    }\r\n\r\n    // Подготовка запроса\r\n    const requestBody: OpenAIEmbeddingRequest = {\r\n      model: this.openaiConfig.model || this.model,\r\n      input: texts,\r\n      encoding_format: 'float'\r\n    };\r\n\r\n    // Добавляем размерность только если она отличается от дефолтной\r\n    const modelInfo = OPENAI_MODELS[this.model as keyof typeof OPENAI_MODELS];\r\n    if (this.dimensions !== modelInfo.defaultDimensions) {\r\n      requestBody.dimensions = this.dimensions;\r\n    }\r\n\r\n    // Добавляем пользователя если указан\r\n    if (this.openaiConfig.user) {\r\n      requestBody.user = this.openaiConfig.user;\r\n    }\r\n\r\n    // Подготовка заголовков\r\n    const headers: Record<string, string> = {\r\n      'Content-Type': 'application/json',\r\n      'Authorization': `Bearer ${this.openaiConfig.apiKey}`,\r\n      'User-Agent': 'LocalRetrieve/1.0.0'\r\n    };\r\n\r\n    // Добавляем организацию если указана\r\n    if (this.openaiConfig.organization) {\r\n      headers['OpenAI-Organization'] = this.openaiConfig.organization;\r\n    }\r\n\r\n    // Дополнительные заголовки\r\n    if (this.openaiConfig.headers) {\r\n      Object.assign(headers, this.openaiConfig.headers);\r\n    }\r\n\r\n    const url = `${this.openaiConfig.baseUrl}/embeddings`;\r\n\r\n    try {\r\n      // Создание контроллера для отмены запроса по таймауту\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => {\r\n        controller.abort();\r\n      }, this.openaiConfig.timeout);\r\n\r\n      // Выполнение запроса\r\n      const response = await fetch(url, {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(requestBody),\r\n        signal: controller.signal\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      // Обработка ответа\r\n      const responseData = await response.json();\r\n\r\n      if (!response.ok) {\r\n        throw this.createErrorFromResponse(response.status, responseData as OpenAIErrorResponse);\r\n      }\r\n\r\n      // Обработка успешного ответа\r\n      return this.processSuccessfulResponse(responseData as OpenAIEmbeddingResponse);\r\n\r\n    } catch (error: unknown) {\r\n      // Обработка ошибок запроса\r\n      if (error instanceof Error && error.name === 'AbortError') {\r\n        throw new NetworkError(\r\n          `Request timeout after ${this.openaiConfig.timeout}ms`,\r\n          'timeout',\r\n          undefined,\r\n          url\r\n        );\r\n      }\r\n\r\n      if (error instanceof TypeError && error.message.includes('fetch')) {\r\n        throw new NetworkError(\r\n          'Network connection failed',\r\n          'connection',\r\n          undefined,\r\n          url\r\n        );\r\n      }\r\n\r\n      // Пробрасываем уже обработанные ошибки\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка здоровья OpenAI провайдера\r\n   */\r\n  protected async checkProviderHealth(): Promise<boolean> {\r\n    try {\r\n      // Выполняем минимальный запрос для проверки доступности API\r\n      await this.executeEmbeddingRequest(['health check']);\r\n      return true;\r\n    } catch (error) {\r\n      console.warn(`OpenAI provider health check failed: ${error}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Очистка ресурсов OpenAI провайдера\r\n   */\r\n  protected async cleanupProvider(): Promise<void> {\r\n    // Очищаем конфигурацию (включая API ключ)\r\n    this.openaiConfig = undefined;\r\n  }\r\n\r\n  /**\r\n   * Получение информации о поддерживаемых моделях\r\n   */\r\n  public static getAvailableModels() {\r\n    return Object.entries(OPENAI_MODELS).map(([id, info]) => ({\r\n      id,\r\n      name: info.name,\r\n      description: `OpenAI ${info.name} embedding model`,\r\n      dimensions: info.defaultDimensions,\r\n      supportedDimensions: info.supportedDimensions,\r\n      maxInputLength: info.maxInputTokens,\r\n      languages: ['en', 'es', 'fr', 'de', 'it', 'pt', 'ru', 'ja', 'ko', 'zh'],\r\n      useCases: ['semantic search', 'classification', 'clustering', 'similarity'],\r\n      costPerToken: info.costPer1MTokens / 1000000\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Создание специфичной ошибки на основе ответа API\r\n   */\r\n  private createErrorFromResponse(status: number, errorData: OpenAIErrorResponse): Error {\r\n    const errorMessage = errorData.error?.message || 'Unknown OpenAI API error';\r\n    const errorType = errorData.error?.type || 'unknown';\r\n    const errorCode = errorData.error?.code || 'unknown';\r\n\r\n    switch (status) {\r\n      case 401:\r\n        return new AuthenticationError(\r\n          `OpenAI API authentication failed: ${errorMessage}`,\r\n          'invalid_key',\r\n          { provider: this.name, errorType, errorCode }\r\n        );\r\n\r\n      case 429:\r\n        // Определяем тип превышения лимита\r\n        if (errorMessage.includes('quota') || errorMessage.includes('billing')) {\r\n          return new QuotaExceededError(\r\n            `OpenAI API quota exceeded: ${errorMessage}`,\r\n            'api_calls',\r\n            0,\r\n            0,\r\n            undefined,\r\n            { provider: this.name, errorType, errorCode }\r\n          );\r\n        } else {\r\n          return new QuotaExceededError(\r\n            `OpenAI API rate limit exceeded: ${errorMessage}`,\r\n            'api_calls',\r\n            0,\r\n            0,\r\n            new Date(Date.now() + 60000), // Retry after 1 minute\r\n            { provider: this.name, errorType, errorCode }\r\n          );\r\n        }\r\n\r\n      case 400:\r\n        if (errorMessage.includes('dimensions') || errorMessage.includes('model')) {\r\n          return new ConfigurationError(\r\n            `OpenAI API configuration error: ${errorMessage}`,\r\n            errorData.error?.param || 'unknown',\r\n            undefined,\r\n            undefined,\r\n            { provider: this.name, errorType, errorCode }\r\n          );\r\n        } else {\r\n          return new ValidationError(\r\n            `OpenAI API validation error: ${errorMessage}`,\r\n            errorData.error?.param || 'input',\r\n            'OpenAI API validation',\r\n            { provider: this.name, errorType, errorCode }\r\n          );\r\n        }\r\n\r\n      case 500:\r\n      case 502:\r\n      case 503:\r\n      case 504:\r\n        return new NetworkError(\r\n          `OpenAI API server error: ${errorMessage}`,\r\n          'server_error',\r\n          status,\r\n          undefined,\r\n          { provider: this.name, errorType, errorCode }\r\n        );\r\n\r\n      default:\r\n        return new ProviderError(\r\n          `OpenAI API error (${status}): ${errorMessage}`,\r\n          this.name,\r\n          'OPENAI_API_ERROR',\r\n          undefined,\r\n          { status, errorType, errorCode }\r\n        );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обработка успешного ответа от OpenAI API\r\n   */\r\n  private processSuccessfulResponse(response: OpenAIEmbeddingResponse): Float32Array[] {\r\n    if (!response.data || !Array.isArray(response.data)) {\r\n      throw new ProviderError(\r\n        'Invalid response format from OpenAI API',\r\n        this.name,\r\n        'INVALID_RESPONSE_FORMAT'\r\n      );\r\n    }\r\n\r\n    // Сортируем по индексу для сохранения порядка\r\n    const sortedData = response.data.sort((a, b) => a.index - b.index);\r\n\r\n    return sortedData.map((item, index) => {\r\n      if (!item.embedding || !Array.isArray(item.embedding)) {\r\n        throw new ProviderError(\r\n          `Invalid embedding format at index ${index}`,\r\n          this.name,\r\n          'INVALID_EMBEDDING_FORMAT'\r\n        );\r\n      }\r\n\r\n      // Проверяем размерность\r\n      if (item.embedding.length !== this.dimensions) {\r\n        throw new ProviderError(\r\n          `Embedding dimension mismatch: expected ${this.dimensions}, got ${item.embedding.length}`,\r\n          this.name,\r\n          'DIMENSION_MISMATCH'\r\n        );\r\n      }\r\n\r\n      // Конвертируем в Float32Array\r\n      return new Float32Array(item.embedding);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации для OpenAI провайдера\r\n   */\r\n  public validateConfig(config: EmbeddingConfig) {\r\n    const baseValidation = super.validateConfig(config);\r\n\r\n    // Дополнительная валидация для OpenAI\r\n    const errors = [...baseValidation.errors];\r\n    const warnings = [...baseValidation.warnings];\r\n    const suggestions = [...baseValidation.suggestions];\r\n\r\n    // Проверка API ключа\r\n    if (!config.apiKey) {\r\n      errors.push('OpenAI API key is required');\r\n      suggestions.push('Set apiKey in configuration');\r\n    } else if (!config.apiKey.startsWith('sk-')) {\r\n      warnings.push('OpenAI API key should start with \"sk-\"');\r\n      suggestions.push('Verify API key format');\r\n    }\r\n\r\n    // Проверка модели и размерности\r\n    const modelName = (config as any).providerOptions?.model || this.model;\r\n    if (modelName in OPENAI_MODELS) {\r\n      const modelInfo = OPENAI_MODELS[modelName as keyof typeof OPENAI_MODELS];\r\n      if (!(modelInfo.supportedDimensions as readonly number[]).includes(this.dimensions)) {\r\n        errors.push(`Model ${modelName} does not support ${this.dimensions} dimensions`);\r\n        suggestions.push(`Use one of: ${modelInfo.supportedDimensions.join(', ')}`);\r\n      }\r\n    }\r\n\r\n    // Проверка размера батча\r\n    if (config.batchSize && config.batchSize > this.maxBatchSize) {\r\n      warnings.push(`Batch size ${config.batchSize} may be inefficient for OpenAI API`);\r\n      suggestions.push(`Consider using batch size of ${Math.min(this.maxBatchSize, 50)} or less`);\r\n    }\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n      suggestions\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Фабричная функция для создания OpenAI провайдера\r\n */\r\nexport function createOpenAIProvider(\r\n  dimensions: number,\r\n  model: string = 'text-embedding-3-small'\r\n): OpenAIProvider {\r\n  return new OpenAIProvider(dimensions, model);\r\n}\r\n\r\n/**\r\n * Проверка поддерживается ли комбинация модели и размерности\r\n */\r\nexport function isValidModelDimensionCombo(model: string, dimensions: number): boolean {\r\n  if (!(model in OPENAI_MODELS)) {\r\n    return false;\r\n  }\r\n\r\n  const modelInfo = OPENAI_MODELS[model as keyof typeof OPENAI_MODELS];\r\n  return (modelInfo.supportedDimensions as readonly number[]).includes(dimensions);\r\n}\r\n\r\n/**\r\n * Получение рекомендуемой конфигурации для заданных требований\r\n */\r\nexport function getRecommendedConfig(\r\n  requirements: {\r\n    dimensions?: number;\r\n    budget?: 'low' | 'medium' | 'high';\r\n    performance?: 'fast' | 'balanced' | 'accurate';\r\n  }\r\n): {\r\n  model: string;\r\n  dimensions: number;\r\n  description: string;\r\n} {\r\n  const { dimensions = 384, budget = 'medium', performance = 'balanced' } = requirements;\r\n\r\n  // Рекомендации на основе бюджета и производительности\r\n  if (budget === 'low' || performance === 'fast') {\r\n    return {\r\n      model: 'text-embedding-3-small',\r\n      dimensions: Math.min(dimensions, 384),\r\n      description: 'Cost-effective option with good performance for most use cases'\r\n    };\r\n  }\r\n\r\n  if (budget === 'high' || performance === 'accurate') {\r\n    if (dimensions <= 1024) {\r\n      return {\r\n        model: 'text-embedding-3-large',\r\n        dimensions: dimensions <= 256 ? 256 : dimensions <= 512 ? 512 : 1024,\r\n        description: 'High-accuracy model for demanding applications'\r\n      };\r\n    }\r\n  }\r\n\r\n  // Сбалансированный выбор\r\n  return {\r\n    model: 'text-embedding-3-small',\r\n    dimensions: dimensions <= 384 ? 384 : dimensions <= 768 ? 768 : 1536,\r\n    description: 'Balanced option providing good accuracy and reasonable cost'\r\n  };\r\n}","/**\r\n * Провайдер эмбеддингов на основе Transformers.js\r\n *\r\n * Реализует локальную генерацию эмбеддингов с использованием модели all-MiniLM-L6-v2\r\n * через Web Worker для неблокирующей производительности.\r\n *\r\n * Ключевые особенности:\r\n * - Фиксированная размерность 384 для модели all-MiniLM-L6-v2\r\n * - Ленивая загрузка модели (только при первом запросе)\r\n * - Работа в Web Worker для изоляции\r\n * - Базовая оптимизация производительности\r\n * - Управление памятью и очистка ресурсов\r\n */\r\n\r\nimport type { EmbeddingConfig } from '../types.js';\r\nimport { BaseEmbeddingProvider, type ProviderHealthStatus, type ProviderMetrics } from './BaseProvider.js';\r\nimport { ProviderError, ProviderInitializationError, ModelLoadError, TimeoutError, WorkerError } from '../errors.js';\r\n\r\n/**\r\n * Конфигурация для Transformers.js провайдера\r\n */\r\nexport interface TransformersProviderConfig extends EmbeddingConfig {\r\n  /** Путь к скрипту воркера */\r\n  workerScript?: string;\r\n\r\n  /** Максимальное время загрузки модели в миллисекундах */\r\n  modelLoadTimeout?: number;\r\n\r\n  /** Максимальное время ожидания операции в миллисекундах */\r\n  operationTimeout?: number;\r\n\r\n  /** Путь к модели (по умолчанию 'Xenova/all-MiniLM-L6-v2') */\r\n  modelPath?: string;\r\n\r\n  /** Кэширование модели в localStorage */\r\n  enableModelCache?: boolean;\r\n\r\n  /** Включить ли детальное логирование */\r\n  enableLogging?: boolean;\r\n}\r\n\r\n/**\r\n * Сообщения для взаимодействия с Web Worker\r\n */\r\ninterface WorkerMessage {\r\n  id: string;\r\n  type: 'initialize' | 'generateEmbedding' | 'generateBatch' | 'cleanup' | 'healthCheck';\r\n  data?: any;\r\n}\r\n\r\ninterface WorkerResponse {\r\n  id: string;\r\n  success: boolean;\r\n  data?: any;\r\n  error?: string;\r\n  metadata?: {\r\n    generationTime: number;\r\n    modelSize?: number;\r\n    memoryUsage?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Провайдер эмбеддингов на основе Transformers.js\r\n *\r\n * Использует модель all-MiniLM-L6-v2 для генерации 384-мерных эмбеддингов.\r\n * Все операции выполняются в Web Worker для неблокирующей производительности.\r\n */\r\nexport class TransformersProvider extends BaseEmbeddingProvider {\r\n  /** Экземпляр Web Worker */\r\n  private worker?: Worker;\r\n\r\n  /** Конфигурация провайдера */\r\n  protected config: TransformersProviderConfig;\r\n\r\n  /** Очередь ожидающих запросов */\r\n  private pendingRequests = new Map<string, {\r\n    resolve: (value: any) => void;\r\n    reject: (error: Error) => void;\r\n    timestamp: number;\r\n    timeout?: NodeJS.Timeout;\r\n  }>();\r\n\r\n  /** Счетчик для уникальных идентификаторов сообщений */\r\n  private messageCounter = 0;\r\n\r\n  /** Статус инициализации */\r\n  private initializationPromise?: Promise<void>;\r\n\r\n  /** Метрики производительности */\r\n  private performanceMetrics = {\r\n    modelLoadTime: 0,\r\n    averageBatchSize: 0,\r\n    totalBatches: 0,\r\n    memoryPeak: 0,\r\n    lastCleanup: new Date()\r\n  };\r\n\r\n  constructor(config: TransformersProviderConfig = {\r\n    defaultProvider: 'transformers',\r\n    defaultDimensions: 384\r\n  }) {\r\n    super(\r\n      'transformers',\r\n      384, // Фиксированная размерность для all-MiniLM-L6-v2\r\n      config.batchSize || 16, // Оптимальный размер батча для локальной модели\r\n      512 // Максимальная длина текста в токенах\r\n    );\r\n\r\n    this.config = {\r\n      workerScript: '/src/embedding/workers/transformers-worker.js',\r\n      modelLoadTimeout: 30000, // 30 секунд на загрузку модели\r\n      operationTimeout: 10000,  // 10 секунд на операцию\r\n      batchSize: 16,\r\n      enableLogging: false,\r\n      modelPath: 'Xenova/all-MiniLM-L6-v2',\r\n      enableModelCache: true,\r\n      ...config\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Инициализация провайдера и загрузка модели\r\n   */\r\n  public async initialize(config: EmbeddingConfig): Promise<void> {\r\n    if (this.initializationPromise) {\r\n      return this.initializationPromise;\r\n    }\r\n\r\n    this.initializationPromise = this._initialize(config);\r\n    return this.initializationPromise;\r\n  }\r\n\r\n  private async _initialize(config: EmbeddingConfig): Promise<void> {\r\n    try {\r\n      this.config = { ...this.config, ...config };\r\n\r\n      // Проверяем поддержку Web Workers\r\n      if (!window.Worker) {\r\n        throw new ProviderInitializationError(\r\n          'Web Workers не поддерживаются в данном браузере',\r\n          this.name,\r\n          undefined,\r\n          { userAgent: navigator.userAgent }\r\n        );\r\n      }\r\n\r\n      // Создаем Web Worker\r\n      await this.createWorker();\r\n\r\n      // Инициализируем модель в воркере\r\n      const startTime = Date.now();\r\n      await this.sendMessage('initialize', {\r\n        modelPath: this.config.modelPath,\r\n        enableCache: this.config.enableModelCache,\r\n        enableLogging: this.config.enableLogging\r\n      }, this.config.modelLoadTimeout);\r\n\r\n      this.performanceMetrics.modelLoadTime = Date.now() - startTime;\r\n      this._isReady = true;\r\n\r\n      if (this.config.enableLogging) {\r\n        console.log(`[TransformersProvider] Модель загружена за ${this.performanceMetrics.modelLoadTime}ms`);\r\n      }\r\n\r\n    } catch (error) {\r\n      this._isReady = false;\r\n\r\n      if (error instanceof Error) {\r\n        throw new ProviderInitializationError(\r\n          `Ошибка инициализации Transformers.js провайдера: ${error.message}`,\r\n          this.name,\r\n          error,\r\n          { config: this.config }\r\n        );\r\n      }\r\n\r\n      throw new ProviderInitializationError(\r\n        'Неизвестная ошибка при инициализации провайдера',\r\n        this.name,\r\n        undefined,\r\n        { config: this.config }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Создание и настройка Web Worker\r\n   */\r\n  private async createWorker(): Promise<void> {\r\n    try {\r\n      // Для разработки используем полный путь, для продакшна - относительный\r\n      const workerUrl = this.config.workerScript?.startsWith('/')\r\n        ? this.config.workerScript\r\n        : `/src/embedding/workers/transformers-worker.js`;\r\n\r\n      this.worker = new Worker(workerUrl, {\r\n        type: 'module',\r\n        name: 'TransformersEmbeddingWorker'\r\n      });\r\n\r\n      // Настраиваем обработчик сообщений\r\n      this.worker.onmessage = (event: MessageEvent<WorkerResponse>) => {\r\n        this.handleWorkerMessage(event.data);\r\n      };\r\n\r\n      // Обработчик ошибок воркера\r\n      this.worker.onerror = (error) => {\r\n        console.error('[TransformersProvider] Worker error:', error);\r\n        this.handleWorkerError(new Error(`Worker error: ${error.message}`));\r\n      };\r\n\r\n      // Обработчик неожиданного завершения воркера\r\n      this.worker.onmessageerror = (error) => {\r\n        console.error('[TransformersProvider] Worker message error:', error);\r\n        this.handleWorkerError(new Error('Worker message parsing error'));\r\n      };\r\n\r\n    } catch (error) {\r\n      throw new WorkerError(\r\n        `Не удалось создать Web Worker: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        'create',\r\n        undefined,\r\n        { workerScript: this.config.workerScript }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Генерация эмбеддинга для одного текста\r\n   */\r\n  public async generateEmbedding(text: string): Promise<Float32Array> {\r\n    this.validateText(text);\r\n\r\n    if (!this._isReady) {\r\n      throw new ProviderError(\r\n        'Провайдер не инициализирован. Вызовите initialize() перед использованием.',\r\n        this.name,\r\n        'NOT_INITIALIZED'\r\n      );\r\n    }\r\n\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const response = await this.sendMessage('generateEmbedding', {\r\n        text: text.trim()\r\n      }, this.config.operationTimeout);\r\n\r\n      const generationTime = Date.now() - startTime;\r\n      this.updateMetrics(generationTime, 1, false);\r\n\r\n      // Убеждаемся, что получили Float32Array правильной размерности\r\n      const embedding = new Float32Array(response.embedding);\r\n      if (embedding.length !== this.dimensions) {\r\n        throw new ProviderError(\r\n          `Неверная размерность эмбеддинга: получено ${embedding.length}, ожидалось ${this.dimensions}`,\r\n          this.name,\r\n          'INVALID_DIMENSIONS'\r\n        );\r\n      }\r\n\r\n      return embedding;\r\n\r\n    } catch (error) {\r\n      const generationTime = Date.now() - startTime;\r\n      this.updateMetrics(generationTime, 1, true);\r\n\r\n      if (error instanceof Error) {\r\n        throw error;\r\n      }\r\n\r\n      throw new ProviderError(\r\n        `Ошибка генерации эмбеддинга: ${error}`,\r\n        this.name,\r\n        'GENERATION_ERROR',\r\n        undefined,\r\n        { text: text.substring(0, 100) + '...' }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Пакетная генерация эмбеддингов\r\n   */\r\n  public async generateBatch(texts: string[]): Promise<Float32Array[]> {\r\n    this.validateBatch(texts);\r\n\r\n    if (!this._isReady) {\r\n      throw new ProviderError(\r\n        'Провайдер не инициализирован. Вызовите initialize() перед использованием.',\r\n        this.name,\r\n        'NOT_INITIALIZED'\r\n      );\r\n    }\r\n\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Для больших батчей разбиваем на части\r\n      const results: Float32Array[] = [];\r\n      const chunkSize = this.maxBatchSize;\r\n\r\n      for (let i = 0; i < texts.length; i += chunkSize) {\r\n        const chunk = texts.slice(i, i + chunkSize);\r\n        const chunkResults = await this.processBatchChunk(chunk);\r\n        results.push(...chunkResults);\r\n      }\r\n\r\n      const generationTime = Date.now() - startTime;\r\n      this.updateMetrics(generationTime, texts.length, false);\r\n\r\n      // Обновляем метрики батчевой обработки\r\n      this.performanceMetrics.totalBatches += 1;\r\n      this.performanceMetrics.averageBatchSize =\r\n        (this.performanceMetrics.averageBatchSize * (this.performanceMetrics.totalBatches - 1) + texts.length)\r\n        / this.performanceMetrics.totalBatches;\r\n\r\n      return results;\r\n\r\n    } catch (error) {\r\n      const generationTime = Date.now() - startTime;\r\n      this.updateMetrics(generationTime, texts.length, true);\r\n\r\n      if (error instanceof Error) {\r\n        throw error;\r\n      }\r\n\r\n      throw new ProviderError(\r\n        `Ошибка пакетной генерации эмбеддингов: ${error}`,\r\n        this.name,\r\n        'BATCH_GENERATION_ERROR',\r\n        undefined,\r\n        { batchSize: texts.length }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обработка части батча\r\n   */\r\n  private async processBatchChunk(texts: string[]): Promise<Float32Array[]> {\r\n    const response = await this.sendMessage('generateBatch', {\r\n      texts: texts.map(t => t.trim())\r\n    }, this.config.operationTimeout! * Math.ceil(texts.length / 4)); // Увеличиваем таймаут для батчей\r\n\r\n    return response.embeddings.map((embData: number[] | Float32Array) => {\r\n      const embedding = new Float32Array(embData);\r\n      if (embedding.length !== this.dimensions) {\r\n        throw new ProviderError(\r\n          `Неверная размерность эмбеддинга: получено ${embedding.length}, ожидалось ${this.dimensions}`,\r\n          this.name,\r\n          'INVALID_DIMENSIONS'\r\n        );\r\n      }\r\n      return embedding;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Очистка ресурсов и завершение работы провайдера\r\n   */\r\n  public async cleanup(): Promise<void> {\r\n    try {\r\n      // Отменяем все ожидающие запросы\r\n      for (const [id, request] of this.pendingRequests) {\r\n        if (request.timeout) {\r\n          clearTimeout(request.timeout);\r\n        }\r\n        request.reject(new Error('Provider cleanup - request cancelled'));\r\n      }\r\n      this.pendingRequests.clear();\r\n\r\n      // Очищаем ресурсы в воркере\r\n      if (this.worker && this._isReady) {\r\n        try {\r\n          await this.sendMessage('cleanup', {}, 5000);\r\n        } catch (error) {\r\n          // Игнорируем ошибки при очистке, продолжаем завершение\r\n          console.warn('[TransformersProvider] Cleanup warning:', error);\r\n        }\r\n      }\r\n\r\n      // Завершаем воркер\r\n      if (this.worker) {\r\n        this.worker.terminate();\r\n        this.worker = undefined;\r\n      }\r\n\r\n      this._isReady = false;\r\n      this.initializationPromise = undefined;\r\n      this.performanceMetrics.lastCleanup = new Date();\r\n\r\n      if (this.config.enableLogging) {\r\n        console.log('[TransformersProvider] Провайдер очищен');\r\n      }\r\n\r\n    } catch (error) {\r\n      throw new ProviderError(\r\n        `Ошибка при очистке провайдера: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        this.name,\r\n        'CLEANUP_ERROR'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка здоровья провайдера\r\n   */\r\n  public async healthCheck(): Promise<ProviderHealthStatus> {\r\n    try {\r\n      if (!this.worker || !this._isReady) {\r\n        return {\r\n          isHealthy: false,\r\n          status: 'error',\r\n          details: 'Провайдер не инициализирован или воркер недоступен',\r\n          connectionStatus: 'disconnected'\r\n        };\r\n      }\r\n\r\n      // Проверяем отзывчивость воркера\r\n      const startTime = Date.now();\r\n      const response = await this.sendMessage('healthCheck', {}, 5000);\r\n      const responseTime = Date.now() - startTime;\r\n\r\n      return {\r\n        isHealthy: true,\r\n        lastSuccessfulOperation: new Date(),\r\n        status: 'ready',\r\n        details: `Воркер отвечает за ${responseTime}ms`,\r\n        availableMemory: response.memoryInfo?.availableMemory,\r\n        connectionStatus: 'connected'\r\n      };\r\n\r\n    } catch (error) {\r\n      return {\r\n        isHealthy: false,\r\n        status: 'degraded',\r\n        details: `Ошибка проверки здоровья: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        connectionStatus: 'limited'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение расширенных метрик производительности\r\n   */\r\n  public getMetrics(): ProviderMetrics {\r\n    const baseMetrics = super.getMetrics();\r\n\r\n    return {\r\n      ...baseMetrics,\r\n      memoryUsage: this.performanceMetrics.memoryPeak,\r\n      apiRequestCount: undefined, // Не применимо для локального провайдера\r\n      rateLimitStatus: undefined  // Не применимо для локального провайдера\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Получение специфичных для Transformers.js метрик\r\n   */\r\n  public getTransformersMetrics() {\r\n    return {\r\n      ...this.performanceMetrics,\r\n      isModelLoaded: this._isReady,\r\n      workerActive: !!this.worker,\r\n      pendingRequests: this.pendingRequests.size\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Отправка сообщения воркеру с обработкой таймаутов\r\n   */\r\n  private async sendMessage(type: WorkerMessage['type'], data: any, timeoutMs?: number): Promise<any> {\r\n    if (!this.worker) {\r\n      throw new WorkerError('Web Worker не создан', type);\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const id = `${type}_${++this.messageCounter}_${Date.now()}`;\r\n      const timeout = timeoutMs || this.config.operationTimeout || 10000;\r\n\r\n      // Настраиваем таймаут\r\n      const timeoutHandle = setTimeout(() => {\r\n        this.pendingRequests.delete(id);\r\n        reject(new TimeoutError(\r\n          `Операция ${type} превысила таймаут ${timeout}ms`,\r\n          timeout,\r\n          type\r\n        ));\r\n      }, timeout);\r\n\r\n      // Сохраняем запрос\r\n      this.pendingRequests.set(id, {\r\n        resolve,\r\n        reject,\r\n        timestamp: Date.now(),\r\n        timeout: timeoutHandle\r\n      });\r\n\r\n      // Отправляем сообщение\r\n      const message: WorkerMessage = { id, type, data };\r\n      this.worker!.postMessage(message);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Обработка сообщений от воркера\r\n   */\r\n  private handleWorkerMessage(response: WorkerResponse): void {\r\n    const request = this.pendingRequests.get(response.id);\r\n    if (!request) {\r\n      console.warn(`[TransformersProvider] Получен ответ для неизвестного запроса: ${response.id}`);\r\n      return;\r\n    }\r\n\r\n    // Очищаем таймаут и удаляем запрос\r\n    if (request.timeout) {\r\n      clearTimeout(request.timeout);\r\n    }\r\n    this.pendingRequests.delete(response.id);\r\n\r\n    // Обновляем метрики памяти\r\n    if (response.metadata?.memoryUsage) {\r\n      this.performanceMetrics.memoryPeak = Math.max(\r\n        this.performanceMetrics.memoryPeak,\r\n        response.metadata.memoryUsage\r\n      );\r\n    }\r\n\r\n    // Обрабатываем ответ\r\n    if (response.success) {\r\n      request.resolve(response.data);\r\n    } else {\r\n      const error = new ProviderError(\r\n        response.error || 'Неизвестная ошибка воркера',\r\n        this.name,\r\n        'WORKER_ERROR'\r\n      );\r\n      request.reject(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обработка ошибок воркера\r\n   */\r\n  private handleWorkerError(error: Error): void {\r\n    // Отклоняем все ожидающие запросы\r\n    for (const [id, request] of this.pendingRequests) {\r\n      if (request.timeout) {\r\n        clearTimeout(request.timeout);\r\n      }\r\n      request.reject(new WorkerError(\r\n        `Worker error: ${error.message}`,\r\n        'worker_error',\r\n        undefined,\r\n        { originalError: error.message }\r\n      ));\r\n    }\r\n    this.pendingRequests.clear();\r\n\r\n    this._isReady = false;\r\n  }\r\n}\r\n\r\n/**\r\n * Фабричная функция для создания TransformersProvider\r\n */\r\nexport function createTransformersProvider(config?: TransformersProviderConfig): TransformersProvider {\r\n  return new TransformersProvider(config);\r\n}\r\n\r\n/**\r\n * Проверка поддержки Transformers.js в текущей среде\r\n */\r\nexport function isTransformersSupported(): boolean {\r\n  return (\r\n    typeof window !== 'undefined' &&\r\n    typeof Worker !== 'undefined' &&\r\n    typeof SharedArrayBuffer !== 'undefined' &&\r\n    typeof WebAssembly !== 'undefined'\r\n  );\r\n}\r\n\r\n/**\r\n * Получение информации о модели all-MiniLM-L6-v2\r\n */\r\nexport function getModelInfo() {\r\n  return {\r\n    id: 'Xenova/all-MiniLM-L6-v2',\r\n    name: 'all-MiniLM-L6-v2',\r\n    description: 'Sentence-BERT model for generating 384-dimensional embeddings',\r\n    dimensions: 384,\r\n    maxInputLength: 512,\r\n    languages: ['en', 'multilingual'],\r\n    useCases: ['sentence similarity', 'semantic search', 'clustering'],\r\n    modelSize: 23_000_000, // ~23MB\r\n    provider: 'transformers'\r\n  };\r\n}","/**\r\n * Утилиты для системы эмбеддингов LocalRetrieve\r\n *\r\n * Данный модуль предоставляет вспомогательные функции для работы с эмбеддингами,\r\n * включая хеширование, валидацию, конвертацию данных и другие служебные операции.\r\n */\r\n\r\nimport type { CollectionEmbeddingConfig, EmbeddingConfig, Collection } from './types.js';\r\nimport { ValidationError, EmbeddingError } from './errors.js';\r\n\r\n/**\r\n * Результат хеширования\r\n */\r\nexport interface HashResult {\r\n  /** Хеш в виде hex строки */\r\n  hash: string;\r\n\r\n  /** Алгоритм хеширования */\r\n  algorithm: string;\r\n\r\n  /** Время создания хеша */\r\n  timestamp: Date;\r\n\r\n  /** Входные данные для хеширования (для отладки) */\r\n  input?: any;\r\n}\r\n\r\n/**\r\n * Опции для генерации хеша\r\n */\r\nexport interface HashOptions {\r\n  /** Алгоритм хеширования */\r\n  algorithm?: 'SHA-256' | 'SHA-1' | 'MD5';\r\n\r\n  /** Включать ли timestamp в хеш */\r\n  includeTimestamp?: boolean;\r\n\r\n  /** Дополнительный salt для хеширования */\r\n  salt?: string;\r\n\r\n  /** Включать ли отладочную информацию */\r\n  includeDebugInfo?: boolean;\r\n}\r\n\r\n/**\r\n * Конфигурация для хеша кеша\r\n */\r\nexport interface CacheKeyConfig {\r\n  /** Текст для хеширования */\r\n  text: string;\r\n\r\n  /** Конфигурация коллекции */\r\n  collectionConfig?: CollectionEmbeddingConfig;\r\n\r\n  /** Глобальная конфигурация */\r\n  globalConfig?: EmbeddingConfig;\r\n\r\n  /** Дополнительные параметры */\r\n  additionalParams?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Результат валидации размерностей\r\n */\r\nexport interface DimensionValidationResult {\r\n  /** Валидны ли размерности */\r\n  isValid: boolean;\r\n\r\n  /** Ожидаемая размерность */\r\n  expectedDimensions: number;\r\n\r\n  /** Фактическая размерность */\r\n  actualDimensions: number;\r\n\r\n  /** Сообщение об ошибке */\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Метаданные производительности\r\n */\r\nexport interface PerformanceMetrics {\r\n  /** Время начала операции */\r\n  startTime: number;\r\n\r\n  /** Время окончания операции */\r\n  endTime?: number;\r\n\r\n  /** Длительность в миллисекундах */\r\n  duration?: number;\r\n\r\n  /** Название операции */\r\n  operation: string;\r\n\r\n  /** Дополнительные данные */\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Основной класс утилит для эмбеддингов\r\n */\r\nexport class EmbeddingUtils {\r\n  /** Кеш для часто используемых хешей */\r\n  private static hashCache = new Map<string, HashResult>();\r\n\r\n  /** Максимальный размер кеша хешей */\r\n  private static readonly MAX_HASH_CACHE_SIZE = 1000;\r\n\r\n  /**\r\n   * Генерация стабильного хеша для ключа кеша\r\n   *\r\n   * @param config - Конфигурация для генерации ключа\r\n   * @param options - Опции хеширования\r\n   * @returns Результат хеширования\r\n   */\r\n  public static async generateCacheKey(\r\n    config: CacheKeyConfig,\r\n    options: HashOptions = {}\r\n  ): Promise<HashResult> {\r\n    const {\r\n      algorithm = 'SHA-256',\r\n      includeTimestamp = false,\r\n      salt = '',\r\n      includeDebugInfo = false\r\n    } = options;\r\n\r\n    // Создаем стабильный объект для хеширования\r\n    const hashInput: {\r\n      text: string;\r\n      provider?: string;\r\n      model?: string;\r\n      dimensions?: number;\r\n      textPreprocessing?: any;\r\n      additionalParams?: Record<string, any>;\r\n      salt: string;\r\n      timestamp?: number;\r\n    } = {\r\n      text: config.text,\r\n      provider: config.collectionConfig?.provider || config.globalConfig?.defaultProvider,\r\n      model: config.collectionConfig?.model || config.globalConfig?.defaultModel,\r\n      dimensions: config.collectionConfig?.dimensions || config.globalConfig?.defaultDimensions,\r\n      textPreprocessing: config.collectionConfig?.textPreprocessing,\r\n      additionalParams: config.additionalParams,\r\n      salt\r\n    };\r\n\r\n    if (includeTimestamp) {\r\n      hashInput.timestamp = Date.now();\r\n    }\r\n\r\n    // Сортируем ключи для стабильности\r\n    const sortedInput = EmbeddingUtils.sortObjectKeys(hashInput);\r\n    const inputString = JSON.stringify(sortedInput);\r\n\r\n    // Проверяем кеш\r\n    const cacheKey = `${algorithm}:${inputString}`;\r\n    if (EmbeddingUtils.hashCache.has(cacheKey)) {\r\n      return EmbeddingUtils.hashCache.get(cacheKey)!;\r\n    }\r\n\r\n    // Генерируем хеш\r\n    const hash = await EmbeddingUtils.hashString(inputString, algorithm);\r\n\r\n    const result: HashResult = {\r\n      hash,\r\n      algorithm,\r\n      timestamp: new Date(),\r\n      input: includeDebugInfo ? sortedInput : undefined\r\n    };\r\n\r\n    // Сохраняем в кеш\r\n    EmbeddingUtils.addToHashCache(cacheKey, result);\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Генерация хеша текста с учетом предобработки\r\n   *\r\n   * @param text - Исходный текст\r\n   * @param processingConfig - Конфигурация предобработки\r\n   * @param options - Опции хеширования\r\n   * @returns Результат хеширования\r\n   */\r\n  public static async generateTextHash(\r\n    text: string,\r\n    processingConfig?: any, // Избегаем циклической зависимости\r\n    options: HashOptions = {}\r\n  ): Promise<HashResult> {\r\n    const config: CacheKeyConfig = {\r\n      text,\r\n      additionalParams: {\r\n        textPreprocessing: processingConfig\r\n      }\r\n    };\r\n\r\n    return EmbeddingUtils.generateCacheKey(config, options);\r\n  }\r\n\r\n  /**\r\n   * Хеширование строки с использованием Web Crypto API\r\n   *\r\n   * @param input - Строка для хеширования\r\n   * @param algorithm - Алгоритм хеширования\r\n   * @returns Хеш в виде hex строки\r\n   */\r\n  public static async hashString(input: string, algorithm: string = 'SHA-256'): Promise<string> {\r\n    // Проверяем поддержку Web Crypto API\r\n    if (typeof crypto === 'undefined' || !crypto.subtle) {\r\n      // Fallback для старых браузеров\r\n      return EmbeddingUtils.simpleHash(input);\r\n    }\r\n\r\n    try {\r\n      const encoder = new TextEncoder();\r\n      const data = encoder.encode(input);\r\n      const hashBuffer = await crypto.subtle.digest(algorithm, data);\r\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\r\n    } catch (error) {\r\n      // Fallback в случае ошибки\r\n      console.warn('Web Crypto API failed, using simple hash:', error);\r\n      return EmbeddingUtils.simpleHash(input);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Простой хеш для fallback (djb2 algorithm)\r\n   *\r\n   * @param input - Строка для хеширования\r\n   * @returns Хеш в виде hex строки\r\n   */\r\n  private static simpleHash(input: string): string {\r\n    let hash = 5381;\r\n    for (let i = 0; i < input.length; i++) {\r\n      hash = ((hash << 5) + hash) + input.charCodeAt(i);\r\n    }\r\n    return Math.abs(hash).toString(16);\r\n  }\r\n\r\n  /**\r\n   * Синхронная генерация хеша для текста\r\n   *\r\n   * @param text - Текст для хеширования\r\n   * @param options - Опции хеширования\r\n   * @returns Результат хеширования\r\n   */\r\n  public static hashText(text: string, options: { algorithm?: string } = {}): HashResult {\r\n    const algorithm = options.algorithm === 'simple' ? 'simple' : 'djb2';\r\n    const hash = EmbeddingUtils.simpleHash(text);\r\n\r\n    return {\r\n      hash,\r\n      algorithm,\r\n      timestamp: new Date()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Сортировка ключей объекта для стабильного хеширования\r\n   *\r\n   * @param obj - Объект для сортировки\r\n   * @returns Объект с отсортированными ключами\r\n   */\r\n  private static sortObjectKeys(obj: any): any {\r\n    if (obj === null || typeof obj !== 'object') {\r\n      return obj;\r\n    }\r\n\r\n    if (Array.isArray(obj)) {\r\n      return obj.map(item => EmbeddingUtils.sortObjectKeys(item));\r\n    }\r\n\r\n    const sortedKeys = Object.keys(obj).sort();\r\n    const sortedObj: any = {};\r\n\r\n    for (const key of sortedKeys) {\r\n      sortedObj[key] = EmbeddingUtils.sortObjectKeys(obj[key]);\r\n    }\r\n\r\n    return sortedObj;\r\n  }\r\n\r\n  /**\r\n   * Добавление результата в кеш хешей\r\n   *\r\n   * @param key - Ключ кеша\r\n   * @param result - Результат хеширования\r\n   */\r\n  private static addToHashCache(key: string, result: HashResult): void {\r\n    // Очищаем кеш если он переполнен\r\n    if (EmbeddingUtils.hashCache.size >= EmbeddingUtils.MAX_HASH_CACHE_SIZE) {\r\n      const firstKey = EmbeddingUtils.hashCache.keys().next().value;\r\n      if (firstKey !== undefined) {\r\n        EmbeddingUtils.hashCache.delete(firstKey);\r\n      }\r\n    }\r\n\r\n    EmbeddingUtils.hashCache.set(key, result);\r\n  }\r\n\r\n  /**\r\n   * Очистка кеша хешей\r\n   */\r\n  public static clearHashCache(): void {\r\n    EmbeddingUtils.hashCache.clear();\r\n  }\r\n\r\n  /**\r\n   * Валидация размерностей эмбеддинга\r\n   *\r\n   * @param embedding - Вектор эмбеддинга\r\n   * @param expectedDimensions - Ожидаемая размерность\r\n   * @returns Результат валидации\r\n   */\r\n  public static validateEmbeddingDimensions(\r\n    embedding: Float32Array | number[],\r\n    expectedDimensions: number\r\n  ): DimensionValidationResult {\r\n    const actualDimensions = embedding.length;\r\n    const isValid = actualDimensions === expectedDimensions;\r\n\r\n    return {\r\n      isValid,\r\n      expectedDimensions,\r\n      actualDimensions,\r\n      error: isValid ? undefined : `Expected ${expectedDimensions} dimensions, got ${actualDimensions}`\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации коллекции\r\n   *\r\n   * @param config - Конфигурация коллекции\r\n   * @throws {ValidationError} При невалидной конфигурации\r\n   */\r\n  public static validateCollectionConfig(config: CollectionEmbeddingConfig): void {\r\n    if (!config.provider) {\r\n      throw new ValidationError(\r\n        'Provider is required in collection config',\r\n        'provider',\r\n        'must be specified'\r\n      );\r\n    }\r\n\r\n    if (!config.dimensions || config.dimensions <= 0) {\r\n      throw new ValidationError(\r\n        'Dimensions must be a positive number',\r\n        'dimensions',\r\n        'dimensions > 0'\r\n      );\r\n    }\r\n\r\n    // Проверяем поддерживаемые размерности\r\n    const supportedDimensions = [384, 512, 768, 1024, 1536, 3072];\r\n    if (!supportedDimensions.includes(config.dimensions)) {\r\n      throw new ValidationError(\r\n        `Unsupported dimensions: ${config.dimensions}. Supported: ${supportedDimensions.join(', ')}`,\r\n        'dimensions',\r\n        `one of: ${supportedDimensions.join(', ')}`\r\n      );\r\n    }\r\n\r\n    if (config.batchSize && (config.batchSize <= 0 || config.batchSize > 1000)) {\r\n      throw new ValidationError(\r\n        'Batch size must be between 1 and 1000',\r\n        'batchSize',\r\n        '1 <= batchSize <= 1000'\r\n      );\r\n    }\r\n\r\n    if (config.timeout && config.timeout < 1000) {\r\n      throw new ValidationError(\r\n        'Timeout must be at least 1000ms',\r\n        'timeout',\r\n        'timeout >= 1000'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Конвертация массива чисел в Float32Array\r\n   *\r\n   * @param array - Массив чисел\r\n   * @returns Float32Array\r\n   */\r\n  public static toFloat32Array(array: number[] | Float32Array): Float32Array {\r\n    if (array instanceof Float32Array) {\r\n      return array;\r\n    }\r\n\r\n    if (Array.isArray(array)) {\r\n      return new Float32Array(array);\r\n    }\r\n\r\n    throw new ValidationError(\r\n      'Input must be an array of numbers or Float32Array',\r\n      'array',\r\n      'Array<number> | Float32Array'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Создание глубокой копии объекта\r\n   *\r\n   * @param obj - Объект для копирования\r\n   * @returns Глубокая копия объекта\r\n   */\r\n  public static deepClone<T>(obj: T): T {\r\n    if (obj === null || typeof obj !== 'object') {\r\n      return obj;\r\n    }\r\n\r\n    if (obj instanceof Date) {\r\n      return new Date(obj.getTime()) as unknown as T;\r\n    }\r\n\r\n    if (obj instanceof Array) {\r\n      return obj.map(item => EmbeddingUtils.deepClone(item)) as unknown as T;\r\n    }\r\n\r\n    if (obj instanceof Float32Array) {\r\n      return new Float32Array(obj) as unknown as T;\r\n    }\r\n\r\n    if (typeof obj === 'object') {\r\n      const copy = {} as { [K in keyof T]: T[K] };\r\n      for (const key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n          copy[key] = EmbeddingUtils.deepClone(obj[key]);\r\n        }\r\n      }\r\n      return copy;\r\n    }\r\n\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * Слияние конфигураций с приоритетом\r\n   *\r\n   * @param base - Базовая конфигурация\r\n   * @param override - Переопределяющая конфигурация\r\n   * @returns Объединенная конфигурация\r\n   */\r\n  public static mergeConfigs<T extends Record<string, any>>(\r\n    base: Partial<T>,\r\n    override: Partial<T>\r\n  ): T {\r\n    const result = EmbeddingUtils.deepClone(base) as T;\r\n\r\n    for (const key in override) {\r\n      if (override.hasOwnProperty(key)) {\r\n        const overrideValue = override[key];\r\n        if (overrideValue !== undefined) {\r\n          if (typeof overrideValue === 'object' && !Array.isArray(overrideValue) && overrideValue !== null) {\r\n            // Рекурсивное слияние для объектов\r\n            (result as any)[key] = EmbeddingUtils.mergeConfigs(\r\n              ((result as any)[key] as Record<string, any>) || {},\r\n              overrideValue as Record<string, any>\r\n            );\r\n          } else {\r\n            // Прямое переопределение для примитивов и массивов\r\n            (result as any)[key] = overrideValue;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Форматирование размера в человеко-читаемый формат\r\n   *\r\n   * @param bytes - Размер в байтах\r\n   * @returns Отформатированная строка\r\n   */\r\n  public static formatBytes(bytes: number): string {\r\n    if (bytes === 0) return '0 Bytes';\r\n\r\n    const k = 1024;\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n\r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\r\n  }\r\n\r\n  /**\r\n   * Форматирование времени в человеко-читаемый формат\r\n   *\r\n   * @param milliseconds - Время в миллисекундах\r\n   * @returns Отформатированная строка\r\n   */\r\n  public static formatDuration(milliseconds: number): string {\r\n    if (milliseconds < 1000) {\r\n      return `${Math.round(milliseconds)}ms`;\r\n    }\r\n\r\n    const seconds = milliseconds / 1000;\r\n    if (seconds < 60) {\r\n      return `${seconds.toFixed(2)}s`;\r\n    }\r\n\r\n    const minutes = seconds / 60;\r\n    if (minutes < 60) {\r\n      return `${minutes.toFixed(2)}m`;\r\n    }\r\n\r\n    const hours = minutes / 60;\r\n    return `${hours.toFixed(2)}h`;\r\n  }\r\n\r\n  /**\r\n   * Создание таймера производительности\r\n   *\r\n   * @param operation - Название операции\r\n   * @returns Объект для измерения производительности\r\n   */\r\n  public static createPerformanceTimer(operation: string): PerformanceMetrics {\r\n    return {\r\n      startTime: performance.now(),\r\n      operation,\r\n      metadata: {}\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Завершение измерения производительности\r\n   *\r\n   * @param timer - Объект таймера\r\n   * @returns Завершенные метрики\r\n   */\r\n  public static finishPerformanceTimer(timer: PerformanceMetrics): PerformanceMetrics {\r\n    const endTime = performance.now();\r\n    return {\r\n      ...timer,\r\n      endTime,\r\n      duration: endTime - timer.startTime\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки Web Workers\r\n   *\r\n   * @returns true, если Web Workers поддерживаются\r\n   */\r\n  public static supportsWebWorkers(): boolean {\r\n    return typeof Worker !== 'undefined';\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки SharedArrayBuffer\r\n   *\r\n   * @returns true, если SharedArrayBuffer поддерживается\r\n   */\r\n  public static supportsSharedArrayBuffer(): boolean {\r\n    return typeof SharedArrayBuffer !== 'undefined';\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки OPFS (Origin Private File System)\r\n   *\r\n   * @returns Promise<boolean> - true, если OPFS поддерживается\r\n   */\r\n  public static async supportsOPFS(): Promise<boolean> {\r\n    try {\r\n      if ('storage' in navigator && 'getDirectory' in navigator.storage) {\r\n        await navigator.storage.getDirectory();\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение информации о браузере\r\n   *\r\n   * @returns Информация о возможностях браузера\r\n   */\r\n  public static async getBrowserCapabilities(): Promise<{\r\n    webWorkers: boolean;\r\n    sharedArrayBuffer: boolean;\r\n    opfs: boolean;\r\n    webCrypto: boolean;\r\n    userAgent: string;\r\n  }> {\r\n    return {\r\n      webWorkers: EmbeddingUtils.supportsWebWorkers(),\r\n      sharedArrayBuffer: EmbeddingUtils.supportsSharedArrayBuffer(),\r\n      opfs: await EmbeddingUtils.supportsOPFS(),\r\n      webCrypto: typeof crypto !== 'undefined' && !!crypto.subtle,\r\n      userAgent: navigator.userAgent\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Генерация уникального ID\r\n   *\r\n   * @param prefix - Префикс для ID\r\n   * @returns Уникальный идентификатор\r\n   */\r\n  public static generateId(prefix: string = 'emb'): string {\r\n    const timestamp = Date.now().toString(36);\r\n    const random = Math.random().toString(36).substring(2);\r\n    return `${prefix}_${timestamp}_${random}`;\r\n  }\r\n\r\n  /**\r\n   * Безопасное парсинг JSON с обработкой ошибок\r\n   *\r\n   * @param jsonString - JSON строка\r\n   * @param defaultValue - Значение по умолчанию при ошибке\r\n   * @returns Распарсенный объект или значение по умолчанию\r\n   */\r\n  public static safeJsonParse<T>(jsonString: string, defaultValue: T): T {\r\n    try {\r\n      return JSON.parse(jsonString) as T;\r\n    } catch {\r\n      return defaultValue;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Безопасная сериализация в JSON\r\n   *\r\n   * @param value - Значение для сериализации\r\n   * @param defaultValue - Значение по умолчанию при ошибке\r\n   * @returns JSON строка или значение по умолчанию\r\n   */\r\n  public static safeJsonStringify(value: any, defaultValue: string = '{}'): string {\r\n    try {\r\n      return JSON.stringify(value);\r\n    } catch {\r\n      return defaultValue;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Задержка выполнения\r\n   *\r\n   * @param milliseconds - Время задержки в миллисекундах\r\n   * @returns Promise, который разрешается через указанное время\r\n   */\r\n  public static delay(milliseconds: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, milliseconds));\r\n  }\r\n\r\n  /**\r\n   * Дебаунс функции\r\n   *\r\n   * @param func - Функция для дебаунса\r\n   * @param delay - Задержка в миллисекундах\r\n   * @returns Дебаунсированная функция\r\n   */\r\n  public static debounce<T extends (...args: any[]) => any>(\r\n    func: T,\r\n    delay: number\r\n  ): (...args: Parameters<T>) => void {\r\n    let timeoutId: NodeJS.Timeout | number;\r\n\r\n    return (...args: Parameters<T>) => {\r\n      clearTimeout(timeoutId);\r\n      timeoutId = setTimeout(() => func(...args), delay);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Троттлинг функции\r\n   *\r\n   * @param func - Функция для троттлинга\r\n   * @param limit - Минимальный интервал между вызовами в миллисекундах\r\n   * @returns Троттлированная функция\r\n   */\r\n  public static throttle<T extends (...args: any[]) => any>(\r\n    func: T,\r\n    limit: number\r\n  ): (...args: Parameters<T>) => void {\r\n    let inThrottle = false;\r\n\r\n    return (...args: Parameters<T>) => {\r\n      if (!inThrottle) {\r\n        func(...args);\r\n        inThrottle = true;\r\n        setTimeout(() => inThrottle = false, limit);\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Константы для системы эмбеддингов\r\n */\r\nexport const EmbeddingConstants = {\r\n  /** Поддерживаемые размерности векторов */\r\n  SUPPORTED_DIMENSIONS: [384, 512, 768, 1024, 1536, 3072] as const,\r\n\r\n  /** Размеры батчей по умолчанию для разных провайдеров */\r\n  DEFAULT_BATCH_SIZES: {\r\n    transformers: 16,\r\n    openai: 100,\r\n    cohere: 100,\r\n    huggingface: 32,\r\n    custom: 32\r\n  } as const,\r\n\r\n  /** Таймауты по умолчанию (в миллисекундах) */\r\n  DEFAULT_TIMEOUTS: {\r\n    local: 30000,    // 30 секунд для локальных моделей\r\n    api: 60000,      // 60 секунд для API\r\n    initialization: 120000 // 2 минуты для инициализации\r\n  } as const,\r\n\r\n  /** Максимальные размеры текста для разных провайдеров */\r\n  MAX_TEXT_LENGTHS: {\r\n    transformers: 512,\r\n    openai: 8192,\r\n    cohere: 2048,\r\n    huggingface: 512,\r\n    custom: 512\r\n  } as const,\r\n\r\n  /** Соотношение символов к токенам для разных языков */\r\n  CHARS_PER_TOKEN: {\r\n    english: 4,\r\n    russian: 3,\r\n    chinese: 1.5,\r\n    default: 4\r\n  } as const,\r\n\r\n  /** Алгоритмы хеширования */\r\n  HASH_ALGORITHMS: ['SHA-256', 'SHA-1', 'MD5'] as const,\r\n\r\n  /** Версия схемы конфигурации */\r\n  CONFIG_SCHEMA_VERSION: '1.0.0'\r\n} as const;\r\n\r\n/**\r\n * Типы для константы\r\n */\r\nexport type SupportedDimensions = typeof EmbeddingConstants.SUPPORTED_DIMENSIONS[number];\r\nexport type ProviderType = keyof typeof EmbeddingConstants.DEFAULT_BATCH_SIZES;\r\nexport type HashAlgorithm = typeof EmbeddingConstants.HASH_ALGORITHMS[number];\r\n\r\n/**\r\n * Вспомогательные функции для работы с коллекциями\r\n */\r\nexport class CollectionUtils {\r\n  /**\r\n   * Генерация имени таблицы векторов для коллекции\r\n   *\r\n   * @param collectionId - ID коллекции\r\n   * @param dimensions - Размерность векторов\r\n   * @returns Имя таблицы векторов\r\n   */\r\n  public static generateVectorTableName(collectionId: string, dimensions: number): string {\r\n    return `vec_${collectionId}_${dimensions}d`;\r\n  }\r\n\r\n  /**\r\n   * Валидация ID коллекции\r\n   *\r\n   * @param collectionId - ID коллекции для валидации\r\n   * @throws {ValidationError} При невалидном ID\r\n   */\r\n  public static validateCollectionId(collectionId: string): void {\r\n    if (!collectionId || typeof collectionId !== 'string') {\r\n      throw new ValidationError(\r\n        'Collection ID must be a non-empty string',\r\n        'collectionId',\r\n        'non-empty string'\r\n      );\r\n    }\r\n\r\n    // Проверяем формат ID (только буквы, цифры, подчеркивания и дефисы)\r\n    const validIdPattern = /^[a-zA-Z0-9_-]+$/;\r\n    if (!validIdPattern.test(collectionId)) {\r\n      throw new ValidationError(\r\n        'Collection ID can only contain letters, numbers, underscores and hyphens',\r\n        'collectionId',\r\n        'matching pattern: /^[a-zA-Z0-9_-]+$/'\r\n      );\r\n    }\r\n\r\n    if (collectionId.length > 50) {\r\n      throw new ValidationError(\r\n        'Collection ID cannot be longer than 50 characters',\r\n        'collectionId',\r\n        'length <= 50'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Создание конфигурации коллекции по умолчанию\r\n   *\r\n   * @param provider - Тип провайдера\r\n   * @param dimensions - Размерность векторов\r\n   * @returns Конфигурация коллекции по умолчанию\r\n   */\r\n  public static createDefaultCollectionConfig(\r\n    provider: ProviderType,\r\n    dimensions: SupportedDimensions\r\n  ): CollectionEmbeddingConfig {\r\n    return {\r\n      provider,\r\n      dimensions,\r\n      batchSize: EmbeddingConstants.DEFAULT_BATCH_SIZES[provider],\r\n      cacheEnabled: true,\r\n      timeout: provider === 'transformers'\r\n        ? EmbeddingConstants.DEFAULT_TIMEOUTS.local\r\n        : EmbeddingConstants.DEFAULT_TIMEOUTS.api,\r\n      autoGenerate: false,\r\n      textPreprocessing: {\r\n        maxLength: EmbeddingConstants.MAX_TEXT_LENGTHS[provider],\r\n        stripHtml: true,\r\n        stripMarkdown: true,\r\n        normalizeWhitespace: true,\r\n        toLowerCase: false,\r\n        removeSpecialChars: false\r\n      }\r\n    };\r\n  }\r\n}","/**\r\n * Фабрика провайдеров эмбеддингов для LocalRetrieve\r\n *\r\n * Данный модуль реализует фабрику для создания экземпляров провайдеров эмбеддингов\r\n * на основе конфигурации коллекции. Поддерживает локальные и внешние провайдеры\r\n * с валидацией конфигурации и управлением моделями.\r\n *\r\n * Поддерживаемые провайдеры:\r\n * - Transformers.js: Локальные модели с фиксированной размерностью 384\r\n * - OpenAI: API модели с конфигурируемыми размерностями (384, 768, 1536)\r\n *\r\n * Основные функции:\r\n * - Создание провайдеров на основе конфигурации коллекции\r\n * - Валидация параметров провайдера\r\n * - Получение информации о доступных моделях\r\n * - Рекомендации по конфигурации\r\n */\r\n\r\nimport type {\r\n  EmbeddingProvider,\r\n  EmbeddingProviderFactory,\r\n  ModelInfo,\r\n  ProviderConfigValidation\r\n} from './providers/BaseProvider.js';\r\nimport type { CollectionEmbeddingConfig, EmbeddingProviderType } from './types.js';\r\nimport { TransformersProvider, getModelInfo as getTransformersModelInfo, isTransformersSupported } from './providers/TransformersProvider.js';\r\nimport { OpenAIProvider, getRecommendedConfig, isValidModelDimensionCombo } from './providers/OpenAIProvider.js';\r\nimport {\r\n  ProviderError,\r\n  ConfigurationError,\r\n  ProviderInitializationError,\r\n  ValidationError\r\n} from './errors.js';\r\n\r\n/**\r\n * Результат проверки поддержки провайдера\r\n */\r\nexport interface ProviderSupportInfo {\r\n  /** Поддерживается ли провайдер в текущей среде */\r\n  isSupported: boolean;\r\n\r\n  /** Причина отсутствия поддержки */\r\n  unsupportedReason?: string;\r\n\r\n  /** Рекомендуемые альтернативы */\r\n  alternatives?: EmbeddingProviderType[];\r\n\r\n  /** Требования для поддержки */\r\n  requirements?: string[];\r\n}\r\n\r\n/**\r\n * Информация о конфигурации провайдера\r\n */\r\nexport interface ProviderConfigInfo {\r\n  /** Тип провайдера */\r\n  type: EmbeddingProviderType;\r\n\r\n  /** Название для отображения */\r\n  displayName: string;\r\n\r\n  /** Описание провайдера */\r\n  description: string;\r\n\r\n  /** Поддерживаемые размерности */\r\n  supportedDimensions: number[];\r\n\r\n  /** Размерность по умолчанию */\r\n  defaultDimensions: number;\r\n\r\n  /** Требуется ли API ключ */\r\n  requiresApiKey: boolean;\r\n\r\n  /** Работает ли провайдер локально */\r\n  isLocal: boolean;\r\n\r\n  /** Доступные модели */\r\n  availableModels: ModelInfo[];\r\n\r\n  /** Рекомендуемые случаи использования */\r\n  recommendedUseCases: string[];\r\n\r\n  /** Требования к окружению */\r\n  environmentRequirements: string[];\r\n}\r\n\r\n/**\r\n * Рекомендации по выбору провайдера\r\n */\r\nexport interface ProviderRecommendation {\r\n  /** Рекомендуемый тип провайдера */\r\n  provider: EmbeddingProviderType;\r\n\r\n  /** Рекомендуемая модель */\r\n  model?: string;\r\n\r\n  /** Рекомендуемая размерность */\r\n  dimensions: number;\r\n\r\n  /** Причина рекомендации */\r\n  reason: string;\r\n\r\n  /** Приоритет рекомендации (1-10, 10 - наивысший) */\r\n  priority: number;\r\n\r\n  /** Альтернативные варианты */\r\n  alternatives: Array<{\r\n    provider: EmbeddingProviderType;\r\n    model?: string;\r\n    dimensions: number;\r\n    reason: string;\r\n  }>;\r\n}\r\n\r\n/**\r\n * Основная фабрика провайдеров эмбеддингов\r\n */\r\nexport class EmbeddingProviderFactoryImpl implements EmbeddingProviderFactory {\r\n  /** Регистр доступных провайдеров */\r\n  private readonly providerRegistry = new Map<EmbeddingProviderType, ProviderConfigInfo>();\r\n\r\n  constructor() {\r\n    this.initializeProviderRegistry();\r\n  }\r\n\r\n  /**\r\n   * Создание экземпляра провайдера на основе конфигурации коллекции\r\n   */\r\n  public async createProvider(config: CollectionEmbeddingConfig): Promise<EmbeddingProvider> {\r\n    try {\r\n      // Валидация базовой конфигурации\r\n      const validation = this.validateConfiguration(config);\r\n      if (!validation.isValid) {\r\n        throw new ConfigurationError(\r\n          `Invalid provider configuration: ${validation.errors.join(', ')}`,\r\n          'provider',\r\n          validation.suggestions.join('; '),\r\n          config.provider,\r\n          {\r\n            validation,\r\n            config: { ...config, apiKey: config.apiKey ? '[REDACTED]' : undefined }\r\n          }\r\n        );\r\n      }\r\n\r\n      // Проверка поддержки провайдера\r\n      const supportInfo = this.checkProviderSupport(config.provider);\r\n      if (!supportInfo.isSupported) {\r\n        throw new ProviderInitializationError(\r\n          `Provider ${config.provider} is not supported: ${supportInfo.unsupportedReason}`,\r\n          config.provider,\r\n          undefined,\r\n          {\r\n            supportInfo,\r\n            alternatives: supportInfo.alternatives\r\n          }\r\n        );\r\n      }\r\n\r\n      // Создание экземпляра провайдера\r\n      let provider: EmbeddingProvider;\r\n\r\n      switch (config.provider) {\r\n        case 'transformers':\r\n          provider = await this.createTransformersProvider(config);\r\n          break;\r\n\r\n        case 'openai':\r\n          provider = await this.createOpenAIProvider(config);\r\n          break;\r\n\r\n        default:\r\n          throw new ConfigurationError(\r\n            `Unsupported provider type: ${config.provider}`,\r\n            'provider',\r\n            'One of: transformers, openai',\r\n            config.provider\r\n          );\r\n      }\r\n\r\n      // Инициализация провайдера\r\n      await provider.initialize({\r\n        defaultProvider: config.provider,\r\n        defaultDimensions: config.dimensions,\r\n        apiKey: config.apiKey,\r\n        batchSize: config.batchSize,\r\n        timeout: config.timeout,\r\n        enabled: config.autoGenerate,\r\n        provider: config.provider\r\n      });\r\n\r\n      return provider;\r\n\r\n    } catch (error) {\r\n      if (error instanceof Error && (error.name.includes('Error'))) {\r\n        throw error; // Пробрасываем уже обработанные ошибки\r\n      }\r\n\r\n      throw new ProviderInitializationError(\r\n        `Failed to create provider ${config.provider}: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        config.provider,\r\n        error instanceof Error ? error : undefined,\r\n        { config: { ...config, apiKey: config.apiKey ? '[REDACTED]' : undefined } }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки конфигурации\r\n   */\r\n  public supportsConfig(config: CollectionEmbeddingConfig): boolean {\r\n    const validation = this.validateConfiguration(config);\r\n    const supportInfo = this.checkProviderSupport(config.provider);\r\n\r\n    return validation.isValid && supportInfo.isSupported;\r\n  }\r\n\r\n  /**\r\n   * Получение доступных моделей для всех провайдеров\r\n   */\r\n  public async getAvailableModels(): Promise<ModelInfo[]> {\r\n    const models: ModelInfo[] = [];\r\n\r\n    // Transformers.js модели\r\n    if (isTransformersSupported()) {\r\n      models.push(getTransformersModelInfo());\r\n    }\r\n\r\n    // OpenAI модели\r\n    models.push(...OpenAIProvider.getAvailableModels());\r\n\r\n    return models;\r\n  }\r\n\r\n  /**\r\n   * Получение моделей для конкретного провайдера\r\n   */\r\n  public async getModelsForProvider(providerType: EmbeddingProviderType): Promise<ModelInfo[]> {\r\n    switch (providerType) {\r\n      case 'transformers':\r\n        return isTransformersSupported() ? [getTransformersModelInfo()] : [];\r\n\r\n      case 'openai':\r\n        return OpenAIProvider.getAvailableModels();\r\n\r\n      default:\r\n        return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации провайдера\r\n   */\r\n  public validateConfiguration(config: CollectionEmbeddingConfig): ProviderConfigValidation {\r\n    const errors: string[] = [];\r\n    const warnings: string[] = [];\r\n    const suggestions: string[] = [];\r\n\r\n    // Базовая валидация\r\n    if (!config.provider) {\r\n      errors.push('Provider type is required');\r\n      suggestions.push('Specify provider type (transformers, openai)');\r\n    }\r\n\r\n    if (!config.dimensions || config.dimensions <= 0) {\r\n      errors.push('Valid dimensions value is required');\r\n      suggestions.push('Set dimensions to a positive integer');\r\n    }\r\n\r\n    // Валидация для конкретного провайдера\r\n    switch (config.provider) {\r\n      case 'transformers':\r\n        this.validateTransformersConfig(config, errors, warnings, suggestions);\r\n        break;\r\n\r\n      case 'openai':\r\n        this.validateOpenAIConfig(config, errors, warnings, suggestions);\r\n        break;\r\n\r\n      default:\r\n        if (config.provider) {\r\n          errors.push(`Unsupported provider: ${config.provider}`);\r\n          suggestions.push('Use one of: transformers, openai');\r\n        }\r\n    }\r\n\r\n    // Общие рекомендации\r\n    if (config.batchSize && config.batchSize > 100) {\r\n      warnings.push('Large batch sizes may impact performance');\r\n      suggestions.push('Consider reducing batch size to 50 or less');\r\n    }\r\n\r\n    if (config.timeout && config.timeout < 5000) {\r\n      warnings.push('Short timeout may cause frequent failures');\r\n      suggestions.push('Consider increasing timeout to at least 10 seconds');\r\n    }\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n      suggestions\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки провайдера в текущей среде\r\n   */\r\n  public checkProviderSupport(providerType: EmbeddingProviderType): ProviderSupportInfo {\r\n    switch (providerType) {\r\n      case 'transformers':\r\n        return this.checkTransformersSupport();\r\n\r\n      case 'openai':\r\n        return this.checkOpenAISupport();\r\n\r\n      default:\r\n        return {\r\n          isSupported: false,\r\n          unsupportedReason: `Unknown provider type: ${providerType}`,\r\n          alternatives: ['transformers', 'openai'],\r\n          requirements: ['Valid provider type']\r\n        };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение информации о провайдере\r\n   */\r\n  public getProviderInfo(providerType: EmbeddingProviderType): ProviderConfigInfo | undefined {\r\n    return this.providerRegistry.get(providerType);\r\n  }\r\n\r\n  /**\r\n   * Получение всех доступных провайдеров\r\n   */\r\n  public getAvailableProviders(): ProviderConfigInfo[] {\r\n    return Array.from(this.providerRegistry.values());\r\n  }\r\n\r\n  /**\r\n   * Получение рекомендаций по выбору провайдера\r\n   */\r\n  public getProviderRecommendations(requirements: {\r\n    dimensions?: number;\r\n    budget?: 'low' | 'medium' | 'high';\r\n    performance?: 'fast' | 'balanced' | 'accurate';\r\n    privacy?: 'local' | 'cloud' | 'any';\r\n    useCase?: string;\r\n  }): ProviderRecommendation[] {\r\n    const recommendations: ProviderRecommendation[] = [];\r\n    const { dimensions = 384, budget = 'medium', performance = 'balanced', privacy = 'any' } = requirements;\r\n\r\n    // Локальные провайдеры для приватности\r\n    if (privacy === 'local' || privacy === 'any') {\r\n      if (isTransformersSupported() && dimensions === 384) {\r\n        recommendations.push({\r\n          provider: 'transformers',\r\n          dimensions: 384,\r\n          reason: 'Local processing for privacy, no API costs, works offline',\r\n          priority: privacy === 'local' ? 10 : 7,\r\n          alternatives: []\r\n        });\r\n      }\r\n    }\r\n\r\n    // Внешние API для гибкости\r\n    if (privacy === 'cloud' || privacy === 'any') {\r\n      if (budget === 'low' || performance === 'fast') {\r\n        recommendations.push({\r\n          provider: 'openai',\r\n          model: 'text-embedding-3-small',\r\n          dimensions: Math.min(dimensions, 384),\r\n          reason: 'Cost-effective with good performance and flexible dimensions',\r\n          priority: 8,\r\n          alternatives: [\r\n            {\r\n              provider: 'openai',\r\n              model: 'text-embedding-3-small',\r\n              dimensions: 768,\r\n              reason: 'Better accuracy with moderate cost increase'\r\n            }\r\n          ]\r\n        });\r\n      }\r\n\r\n      if (budget === 'high' || performance === 'accurate') {\r\n        recommendations.push({\r\n          provider: 'openai',\r\n          model: 'text-embedding-3-large',\r\n          dimensions: Math.min(dimensions, 1024),\r\n          reason: 'Highest accuracy for demanding applications',\r\n          priority: 9,\r\n          alternatives: [\r\n            {\r\n              provider: 'openai',\r\n              model: 'text-embedding-3-small',\r\n              dimensions: 1536,\r\n              reason: 'Lower cost alternative with good accuracy'\r\n            }\r\n          ]\r\n        });\r\n      }\r\n\r\n      // Сбалансированный выбор\r\n      if (performance === 'balanced') {\r\n        const openaiConfig = getRecommendedConfig({ dimensions, budget, performance });\r\n        recommendations.push({\r\n          provider: 'openai',\r\n          model: openaiConfig.model,\r\n          dimensions: openaiConfig.dimensions,\r\n          reason: openaiConfig.description,\r\n          priority: 6,\r\n          alternatives: []\r\n        });\r\n      }\r\n    }\r\n\r\n    // Сортируем по приоритету\r\n    return recommendations.sort((a, b) => b.priority - a.priority);\r\n  }\r\n\r\n  /**\r\n   * Создание Transformers.js провайдера\r\n   */\r\n  private async createTransformersProvider(config: CollectionEmbeddingConfig): Promise<TransformersProvider> {\r\n    if (config.dimensions !== 384) {\r\n      throw new ConfigurationError(\r\n        'Transformers.js provider only supports 384 dimensions',\r\n        'dimensions',\r\n        '384',\r\n        config.dimensions\r\n      );\r\n    }\r\n\r\n    return new TransformersProvider({\r\n      defaultProvider: 'transformers',\r\n      defaultDimensions: 384,\r\n      batchSize: config.batchSize || 16,\r\n      enableLogging: false,\r\n      modelLoadTimeout: config.timeout || 30000,\r\n      operationTimeout: config.timeout || 10000,\r\n      enableModelCache: config.cacheEnabled !== false,\r\n      ...config.providerOptions\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Создание OpenAI провайдера\r\n   */\r\n  private async createOpenAIProvider(config: CollectionEmbeddingConfig): Promise<OpenAIProvider> {\r\n    if (!config.apiKey) {\r\n      throw new ConfigurationError(\r\n        'OpenAI provider requires API key',\r\n        'apiKey',\r\n        'Valid OpenAI API key starting with sk-',\r\n        undefined\r\n      );\r\n    }\r\n\r\n    const model = config.model || 'text-embedding-3-small';\r\n\r\n    // Проверяем совместимость модели и размерности\r\n    if (!isValidModelDimensionCombo(model, config.dimensions)) {\r\n      throw new ConfigurationError(\r\n        `Model ${model} does not support ${config.dimensions} dimensions`,\r\n        'dimensions',\r\n        'Valid dimensions for the selected model',\r\n        config.dimensions,\r\n        { model, provider: 'openai' }\r\n      );\r\n    }\r\n\r\n    return new OpenAIProvider(config.dimensions, model);\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации Transformers.js\r\n   */\r\n  private validateTransformersConfig(\r\n    config: CollectionEmbeddingConfig,\r\n    errors: string[],\r\n    warnings: string[],\r\n    suggestions: string[]\r\n  ): void {\r\n    if (config.dimensions !== 384) {\r\n      errors.push('Transformers.js provider only supports 384 dimensions');\r\n      suggestions.push('Set dimensions to 384 for Transformers.js provider');\r\n    }\r\n\r\n    if (config.apiKey) {\r\n      warnings.push('API key is not needed for Transformers.js provider');\r\n      suggestions.push('Remove apiKey from configuration for local provider');\r\n    }\r\n\r\n    if (config.model && config.model !== 'all-MiniLM-L6-v2') {\r\n      warnings.push(`Model ${config.model} is not supported by Transformers.js provider`);\r\n      suggestions.push('Use default model or remove model specification');\r\n    }\r\n\r\n    if (!isTransformersSupported()) {\r\n      errors.push('Transformers.js is not supported in current environment');\r\n      suggestions.push('Use a browser with Web Workers and SharedArrayBuffer support');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Валидация конфигурации OpenAI\r\n   */\r\n  private validateOpenAIConfig(\r\n    config: CollectionEmbeddingConfig,\r\n    errors: string[],\r\n    warnings: string[],\r\n    suggestions: string[]\r\n  ): void {\r\n    if (!config.apiKey) {\r\n      errors.push('OpenAI provider requires API key');\r\n      suggestions.push('Set apiKey in configuration');\r\n    } else if (!config.apiKey.startsWith('sk-')) {\r\n      warnings.push('OpenAI API key should start with \"sk-\"');\r\n      suggestions.push('Verify API key format');\r\n    }\r\n\r\n    const model = config.model || 'text-embedding-3-small';\r\n    if (!isValidModelDimensionCombo(model, config.dimensions)) {\r\n      errors.push(`Model ${model} does not support ${config.dimensions} dimensions`);\r\n      suggestions.push('Check supported dimensions for the selected model');\r\n    }\r\n\r\n    if (config.batchSize && config.batchSize > 100) {\r\n      warnings.push('Large batch sizes may be inefficient for OpenAI API');\r\n      suggestions.push('Consider using batch size of 50 or less');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки Transformers.js\r\n   */\r\n  private checkTransformersSupport(): ProviderSupportInfo {\r\n    if (!isTransformersSupported()) {\r\n      return {\r\n        isSupported: false,\r\n        unsupportedReason: 'Browser does not support required features',\r\n        alternatives: ['openai'],\r\n        requirements: [\r\n          'Web Workers support',\r\n          'SharedArrayBuffer support',\r\n          'WebAssembly support',\r\n          'Modern browser (Chrome 86+, Firefox 79+, Safari 15+)'\r\n        ]\r\n      };\r\n    }\r\n\r\n    return {\r\n      isSupported: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Проверка поддержки OpenAI\r\n   */\r\n  private checkOpenAISupport(): ProviderSupportInfo {\r\n    // OpenAI API доступен во всех современных браузерах с fetch\r\n    if (typeof fetch === 'undefined') {\r\n      return {\r\n        isSupported: false,\r\n        unsupportedReason: 'Fetch API is not available',\r\n        alternatives: ['transformers'],\r\n        requirements: ['Modern browser with fetch API support']\r\n      };\r\n    }\r\n\r\n    return {\r\n      isSupported: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Инициализация реестра провайдеров\r\n   */\r\n  private initializeProviderRegistry(): void {\r\n    // Transformers.js провайдер\r\n    this.providerRegistry.set('transformers', {\r\n      type: 'transformers',\r\n      displayName: 'Transformers.js (Local)',\r\n      description: 'Local embedding generation using all-MiniLM-L6-v2 model. Runs entirely in browser with no external API calls.',\r\n      supportedDimensions: [384],\r\n      defaultDimensions: 384,\r\n      requiresApiKey: false,\r\n      isLocal: true,\r\n      availableModels: isTransformersSupported() ? [getTransformersModelInfo()] : [],\r\n      recommendedUseCases: [\r\n        'Privacy-sensitive applications',\r\n        'Offline functionality',\r\n        'No API cost constraints',\r\n        'Real-time processing',\r\n        'Development and prototyping'\r\n      ],\r\n      environmentRequirements: [\r\n        'Web Workers support',\r\n        'SharedArrayBuffer support',\r\n        'WebAssembly support',\r\n        'Modern browser'\r\n      ]\r\n    });\r\n\r\n    // OpenAI провайдер\r\n    this.providerRegistry.set('openai', {\r\n      type: 'openai',\r\n      displayName: 'OpenAI Embeddings API',\r\n      description: 'Cloud-based embedding generation using OpenAI models. Supports multiple models and configurable dimensions.',\r\n      supportedDimensions: [256, 384, 512, 768, 1024, 1536, 3072],\r\n      defaultDimensions: 1536,\r\n      requiresApiKey: true,\r\n      isLocal: false,\r\n      availableModels: OpenAIProvider.getAvailableModels(),\r\n      recommendedUseCases: [\r\n        'Production applications',\r\n        'High accuracy requirements',\r\n        'Multiple language support',\r\n        'Flexible dimensions',\r\n        'Large-scale processing'\r\n      ],\r\n      environmentRequirements: [\r\n        'Internet connection',\r\n        'Valid OpenAI API key',\r\n        'fetch API support'\r\n      ]\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Singleton instance of the provider factory\r\n */\r\nexport const providerFactory = new EmbeddingProviderFactoryImpl();\r\n\r\n/**\r\n * Convenience function to create a provider\r\n */\r\nexport async function createEmbeddingProvider(config: CollectionEmbeddingConfig): Promise<EmbeddingProvider> {\r\n  return providerFactory.createProvider(config);\r\n}\r\n\r\n/**\r\n * Convenience function to validate provider configuration\r\n */\r\nexport function validateProviderConfig(config: CollectionEmbeddingConfig): ProviderConfigValidation {\r\n  return providerFactory.validateConfiguration(config);\r\n}\r\n\r\n/**\r\n * Convenience function to check provider support\r\n */\r\nexport function checkProviderSupport(providerType: EmbeddingProviderType): ProviderSupportInfo {\r\n  return providerFactory.checkProviderSupport(providerType);\r\n}\r\n\r\n/**\r\n * Convenience function to get provider recommendations\r\n */\r\nexport function getProviderRecommendations(requirements: {\r\n  dimensions?: number;\r\n  budget?: 'low' | 'medium' | 'high';\r\n  performance?: 'fast' | 'balanced' | 'accurate';\r\n  privacy?: 'local' | 'cloud' | 'any';\r\n  useCase?: string;\r\n}): ProviderRecommendation[] {\r\n  return providerFactory.getProviderRecommendations(requirements);\r\n}\r\n\r\n/**\r\n * Convenience function to get all available providers\r\n */\r\nexport function getAvailableProviders(): ProviderConfigInfo[] {\r\n  return providerFactory.getAvailableProviders();\r\n}\r\n\r\n/**\r\n * Convenience function to get available models\r\n */\r\nexport async function getAvailableModels(): Promise<ModelInfo[]> {\r\n  return providerFactory.getAvailableModels();\r\n}\r\n\r\n// Note: EmbeddingProviderFactoryImpl is already exported above","/**\r\n * InternalPipeline - основная система генерации эмбеддингов по запросу\r\n *\r\n * Реализует интеллектуальную генерацию эмбеддингов с многоуровневым кэшированием,\r\n * интеграцией с системой очередей Phase 5 и оптимизацией производительности.\r\n *\r\n * Архитектурные принципы:\r\n * - Кэш-ориентированная генерация (memory → IndexedDB → database)\r\n * - Интеграция с существующей системой очередей Phase 5\r\n * - Batch обработка с отслеживанием прогресса\r\n * - Переиспользование загруженных моделей\r\n * - Graceful fallback при ошибках\r\n */\r\n\r\nimport type {\r\n  EmbeddingProviderType,\r\n  EmbeddingResult as EmbeddingResultType,\r\n  EmbeddingRequest as EmbeddingRequestType,\r\n  EmbeddingRequestOptions,\r\n  BatchEmbeddingResult as BatchEmbeddingResultType,\r\n  CollectionEmbeddingConfig\r\n} from '../embedding/types.js';\r\nimport type { CacheManager } from '../cache/CacheManager.js';\r\nimport type { ModelManager } from './ModelManager.js';\r\nimport { EmbeddingError, ConfigurationError, TimeoutError } from '../embedding/errors.js';\r\nimport { EmbeddingUtils } from '../embedding/utils.js';\r\nimport { providerFactory } from '../embedding/ProviderFactory.js';\r\n\r\n/**\r\n * Параметры генерации эмбеддингов по запросу\r\n */\r\nexport interface EmbeddingOptions {\r\n  /** Принудительное обновление кэша */\r\n  forceRefresh?: boolean;\r\n  /** Таймаут операции в миллисекундах */\r\n  timeout?: number;\r\n  /** Приоритет для очереди */\r\n  priority?: number;\r\n  /** Контекст для оптимизации кэша */\r\n  context?: {\r\n    userId?: string;\r\n    sessionId?: string;\r\n    source?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Параметры batch обработки\r\n */\r\nexport interface BatchOptions {\r\n  /** Размер batch для обработки */\r\n  batchSize?: number;\r\n  /** Максимальное количество параллельных batch */\r\n  concurrency?: number;\r\n  /** Таймаут для всей batch операции */\r\n  timeout?: number;\r\n  /** Callback для отслеживания прогресса */\r\n  onProgress?: (completed: number, total: number, current?: string) => void;\r\n}\r\n\r\n/**\r\n * Результат генерации эмбеддинга\r\n */\r\nexport interface PipelineEmbeddingResult {\r\n  /** Вектор эмбеддинга */\r\n  embedding: Float32Array;\r\n  /** Размерность вектора */\r\n  dimensions: number;\r\n  /** Источник результата */\r\n  source: 'cache_memory' | 'cache_indexeddb' | 'cache_database' | 'provider_fresh';\r\n  /** Время генерации в миллисекундах */\r\n  processingTime: number;\r\n  /** Метаданные */\r\n  metadata?: {\r\n    cacheHit?: boolean;\r\n    modelUsed?: string;\r\n    provider?: string;\r\n    confidence?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Batch результат с детальной информацией\r\n */\r\nexport interface PipelineBatchEmbeddingResult extends PipelineEmbeddingResult {\r\n  /** ID запроса в batch */\r\n  requestId: string;\r\n  /** Статус обработки */\r\n  status: 'completed' | 'failed' | 'skipped';\r\n  /** Сообщение об ошибке при неудаче */\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Запрос на генерацию эмбеддинга\r\n */\r\nexport interface PipelineEmbeddingRequest {\r\n  /** Уникальный ID запроса */\r\n  id: string;\r\n  /** Текст для обработки */\r\n  query: string;\r\n  /** Имя коллекции */\r\n  collection: string;\r\n  /** Дополнительные опции */\r\n  options?: EmbeddingOptions;\r\n}\r\n\r\n/**\r\n * Интерфейс основного класса InternalPipeline\r\n */\r\nexport interface InternalPipeline {\r\n  /**\r\n   * Генерация эмбеддинга для поискового запроса с кэшированием\r\n   */\r\n  generateQueryEmbedding(query: string, collection: string, options?: EmbeddingOptions): Promise<PipelineEmbeddingResult>;\r\n\r\n  /**\r\n   * Batch генерация эмбеддингов с управлением прогрессом\r\n   */\r\n  batchGenerateEmbeddings(requests: PipelineEmbeddingRequest[], options?: BatchOptions): Promise<PipelineBatchEmbeddingResult[]>;\r\n\r\n  /**\r\n   * Получение кэшированного эмбеддинга\r\n   */\r\n  getCachedEmbedding(query: string, collection: string): Promise<PipelineEmbeddingResult | null>;\r\n\r\n  /**\r\n   * Предварительный прогрев кэша для популярных запросов\r\n   */\r\n  warmCache(commonQueries: string[], collection: string): Promise<void>;\r\n\r\n  /**\r\n   * Очистка кэшей и освобождение ресурсов\r\n   */\r\n  clearCache(collection?: string): Promise<void>;\r\n\r\n  /**\r\n   * Получение статистики производительности\r\n   */\r\n  getPerformanceStats(): PipelinePerformanceStats;\r\n}\r\n\r\n/**\r\n * Статистика производительности пайплайна\r\n */\r\nexport interface PipelinePerformanceStats {\r\n  /** Общее количество запросов */\r\n  totalRequests: number;\r\n  /** Процент попаданий в кэш */\r\n  cacheHitRate: number;\r\n  /** Среднее время генерации */\r\n  averageGenerationTime: number;\r\n  /** Количество активных моделей в памяти */\r\n  activeModels: number;\r\n  /** Использование памяти в MB */\r\n  memoryUsage: number;\r\n  /** Статистика по уровням кэша */\r\n  cacheStats: {\r\n    memory: { hits: number; misses: number };\r\n    indexedDB: { hits: number; misses: number };\r\n    database: { hits: number; misses: number };\r\n  };\r\n}\r\n\r\n/**\r\n * Основная реализация InternalPipeline\r\n */\r\nexport class InternalPipelineImpl implements InternalPipeline {\r\n  private cacheManager: CacheManager;\r\n  private modelManager: ModelManager;\r\n\r\n  // Статистика производительности\r\n  private stats: {\r\n    totalRequests: number;\r\n    cacheHits: number;\r\n    cacheMisses: number;\r\n    totalGenerationTime: number;\r\n    cacheHitsByLevel: Map<string, number>;\r\n  };\r\n\r\n  // Провайдеры по коллекциям\r\n  private providers: Map<string, any>;\r\n\r\n  // Конфигурации коллекций\r\n  private collectionConfigs: Map<string, CollectionEmbeddingConfig>;\r\n\r\n  constructor(cacheManager: CacheManager, modelManager: ModelManager) {\r\n    this.cacheManager = cacheManager;\r\n    this.modelManager = modelManager;\r\n\r\n    this.stats = {\r\n      totalRequests: 0,\r\n      cacheHits: 0,\r\n      cacheMisses: 0,\r\n      totalGenerationTime: 0,\r\n      cacheHitsByLevel: new Map()\r\n    };\r\n\r\n    this.providers = new Map();\r\n    this.collectionConfigs = new Map();\r\n  }\r\n\r\n  /**\r\n   * Генерация эмбеддинга для поискового запроса с многоуровневым кэшированием\r\n   */\r\n  async generateQueryEmbedding(query: string, collection: string, options?: EmbeddingOptions): Promise<PipelineEmbeddingResult> {\r\n    const startTime = Date.now();\r\n    this.stats.totalRequests++;\r\n\r\n    try {\r\n      // Валидация входных параметров\r\n      this.validateInputs(query, collection);\r\n\r\n      // Попытка получить из кэша\r\n      if (!options?.forceRefresh) {\r\n        const cached = await this.getCachedEmbedding(query, collection);\r\n        if (cached) {\r\n          this.stats.cacheHits++;\r\n          this.updateCacheHitStats(cached.source);\r\n          return cached;\r\n        }\r\n      }\r\n\r\n      this.stats.cacheMisses++;\r\n\r\n      // Получение провайдера для коллекции\r\n      const provider = await this.getProviderForCollection(collection);\r\n\r\n      // Настройка таймаута\r\n      const timeout = options?.timeout || 5000; // 5 секунд по умолчанию\r\n      const embeddingPromise = this.generateFreshEmbedding(query, provider);\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new TimeoutError(`Embedding generation timeout after ${timeout}ms`, timeout, 'generateQueryEmbedding')), timeout)\r\n      );\r\n\r\n      // Генерация эмбеддинга с таймаутом\r\n      const embedding = await Promise.race([embeddingPromise, timeoutPromise]);\r\n\r\n      const processingTime = Date.now() - startTime;\r\n      this.stats.totalGenerationTime += processingTime;\r\n\r\n      const result: PipelineEmbeddingResult = {\r\n        embedding,\r\n        dimensions: embedding.length,\r\n        source: 'provider_fresh',\r\n        processingTime,\r\n        metadata: {\r\n          cacheHit: false,\r\n          modelUsed: provider.getModelInfo?.()?.name,\r\n          provider: this.getProviderType(provider),\r\n          confidence: 1.0\r\n        }\r\n      };\r\n\r\n      // Сохранение в кэш асинхронно\r\n      this.saveToCacheAsync(query, collection, result).catch(error =>\r\n        console.warn('Failed to cache embedding result:', error)\r\n      );\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      const processingTime = Date.now() - startTime;\r\n      this.stats.totalGenerationTime += processingTime;\r\n\r\n      if (error instanceof EmbeddingError) {\r\n        throw error;\r\n      }\r\n\r\n      throw new EmbeddingError(\r\n        `Failed to generate query embedding: ${error instanceof Error ? error.message : String(error)}`,\r\n        'GENERATION_FAILED',\r\n        'provider',\r\n        { query: query.substring(0, 100), collection }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Batch генерация эмбеддингов с управлением прогрессом\r\n   */\r\n  async batchGenerateEmbeddings(requests: PipelineEmbeddingRequest[], options?: BatchOptions): Promise<PipelineBatchEmbeddingResult[]> {\r\n    if (requests.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    const batchSize = options?.batchSize || 32;\r\n    const concurrency = options?.concurrency || 3;\r\n    const results: PipelineBatchEmbeddingResult[] = [];\r\n\r\n    // Разбиваем запросы на batch'и\r\n    const batches: PipelineEmbeddingRequest[][] = [];\r\n    for (let i = 0; i < requests.length; i += batchSize) {\r\n      batches.push(requests.slice(i, i + batchSize));\r\n    }\r\n\r\n    let completedCount = 0;\r\n    const total = requests.length;\r\n\r\n    // Обработка batch'ей с ограниченным параллелизмом\r\n    const processBatch = async (batch: PipelineEmbeddingRequest[]): Promise<PipelineBatchEmbeddingResult[]> => {\r\n      const batchResults: PipelineBatchEmbeddingResult[] = [];\r\n\r\n      for (const request of batch) {\r\n        try {\r\n          options?.onProgress?.(completedCount, total, request.query.substring(0, 50) + '...');\r\n\r\n          const embeddingResult = await this.generateQueryEmbedding(\r\n            request.query,\r\n            request.collection,\r\n            request.options\r\n          );\r\n\r\n          batchResults.push({\r\n            requestId: request.id,\r\n            ...embeddingResult,\r\n            status: 'completed'\r\n          });\r\n\r\n          completedCount++;\r\n\r\n        } catch (error) {\r\n          batchResults.push({\r\n            requestId: request.id,\r\n            embedding: new Float32Array(0),\r\n            dimensions: 0,\r\n            source: 'provider_fresh',\r\n            processingTime: 0,\r\n            status: 'failed',\r\n            error: error instanceof Error ? error.message : String(error)\r\n          });\r\n\r\n          completedCount++;\r\n        }\r\n      }\r\n\r\n      return batchResults;\r\n    };\r\n\r\n    // Параллельная обработка с ограничением concurrency\r\n    for (let i = 0; i < batches.length; i += concurrency) {\r\n      const batchSlice = batches.slice(i, i + concurrency);\r\n      const batchPromises = batchSlice.map(processBatch);\r\n      const batchResults = await Promise.all(batchPromises);\r\n\r\n      results.push(...batchResults.flat());\r\n    }\r\n\r\n    options?.onProgress?.(completedCount, total, 'Completed');\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Получение кэшированного эмбеддинга с проверкой всех уровней\r\n   */\r\n  async getCachedEmbedding(query: string, collection: string): Promise<PipelineEmbeddingResult | null> {\r\n    const cacheKey = this.generateCacheKey(query, collection);\r\n\r\n    try {\r\n      // Уровень 1: Memory cache\r\n      const memoryResult = await this.cacheManager.get(cacheKey, 'memory');\r\n      if (memoryResult) {\r\n        return {\r\n          ...memoryResult,\r\n          source: 'cache_memory',\r\n          metadata: { ...memoryResult.metadata, cacheHit: true }\r\n        };\r\n      }\r\n\r\n      // Уровень 2: IndexedDB cache\r\n      const indexedDBResult = await this.cacheManager.get(cacheKey, 'indexeddb');\r\n      if (indexedDBResult) {\r\n        // Сохраняем обратно в memory для быстрого доступа\r\n        await this.cacheManager.set(cacheKey, indexedDBResult, { level: 'memory', ttl: 300000 }); // 5 мин\r\n\r\n        return {\r\n          ...indexedDBResult,\r\n          source: 'cache_indexeddb',\r\n          metadata: { ...indexedDBResult.metadata, cacheHit: true }\r\n        };\r\n      }\r\n\r\n      // Уровень 3: Database cache (через CacheManager)\r\n      const databaseResult = await this.cacheManager.get(cacheKey, 'database');\r\n      if (databaseResult) {\r\n        // Сохраняем в вышестоящие кэши\r\n        await Promise.all([\r\n          this.cacheManager.set(cacheKey, databaseResult, { level: 'memory', ttl: 300000 }),\r\n          this.cacheManager.set(cacheKey, databaseResult, { level: 'indexeddb', ttl: 86400000 }) // 24 часа\r\n        ]);\r\n\r\n        return {\r\n          ...databaseResult,\r\n          source: 'cache_database',\r\n          metadata: { ...databaseResult.metadata, cacheHit: true }\r\n        };\r\n      }\r\n\r\n      return null;\r\n\r\n    } catch (error) {\r\n      console.warn(`Cache lookup failed for query \"${query.substring(0, 50)}\":`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Предварительный прогрев кэша для популярных запросов\r\n   */\r\n  async warmCache(commonQueries: string[], collection: string): Promise<void> {\r\n    const batchSize = 10;\r\n    const requests: PipelineEmbeddingRequest[] = commonQueries.map((query, index) => ({\r\n      id: `warmup-${index}`,\r\n      query,\r\n      collection,\r\n      options: { priority: 0 } // Низкий приоритет для прогрева\r\n    }));\r\n\r\n    // Генерируем эмбеддинги batch'ами\r\n    await this.batchGenerateEmbeddings(requests, {\r\n      batchSize,\r\n      concurrency: 2,\r\n      onProgress: (completed, total) => {\r\n        console.log(`Cache warming progress: ${completed}/${total}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Очистка кэшей и освобождение ресурсов\r\n   */\r\n  async clearCache(collection?: string): Promise<void> {\r\n    if (collection) {\r\n      // Очистка кэша конкретной коллекции\r\n      const pattern = `*:${collection}:*`;\r\n      await this.cacheManager.invalidate(pattern);\r\n    } else {\r\n      // Полная очистка\r\n      await this.cacheManager.invalidate('*');\r\n    }\r\n\r\n    // Сброс статистики\r\n    this.stats.cacheHitsByLevel.clear();\r\n  }\r\n\r\n  /**\r\n   * Получение статистики производительности\r\n   */\r\n  getPerformanceStats(): PipelinePerformanceStats {\r\n    const cacheHitRate = this.stats.totalRequests > 0\r\n      ? (this.stats.cacheHits / this.stats.totalRequests) * 100\r\n      : 0;\r\n\r\n    const averageGenerationTime = this.stats.totalRequests > 0\r\n      ? this.stats.totalGenerationTime / this.stats.totalRequests\r\n      : 0;\r\n\r\n    return {\r\n      totalRequests: this.stats.totalRequests,\r\n      cacheHitRate,\r\n      averageGenerationTime,\r\n      activeModels: this.modelManager.getModelStatus().loadedModels.length,\r\n      memoryUsage: this.estimateMemoryUsage(),\r\n      cacheStats: {\r\n        memory: {\r\n          hits: this.stats.cacheHitsByLevel.get('cache_memory') || 0,\r\n          misses: this.stats.cacheMisses\r\n        },\r\n        indexedDB: {\r\n          hits: this.stats.cacheHitsByLevel.get('cache_indexeddb') || 0,\r\n          misses: 0 // Будет реализовано в CacheManager\r\n        },\r\n        database: {\r\n          hits: this.stats.cacheHitsByLevel.get('cache_database') || 0,\r\n          misses: 0 // Будет реализовано в CacheManager\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  // === Приватные методы ===\r\n\r\n  /**\r\n   * Валидация входных параметров\r\n   */\r\n  private validateInputs(query: string, collection: string): void {\r\n    if (!query || typeof query !== 'string' || query.trim().length === 0) {\r\n      throw new ConfigurationError('Query must be a non-empty string', 'query', 'non-empty string', query);\r\n    }\r\n\r\n    if (query.length > 8192) { // Лимит из embedding constants\r\n      throw new ConfigurationError('Query is too long (max 8192 characters)', 'query', 'string with length <= 8192', query.length);\r\n    }\r\n\r\n    if (!collection || typeof collection !== 'string') {\r\n      throw new ConfigurationError('Collection must be specified', 'collection', 'non-empty string', collection);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение провайдера для коллекции\r\n   */\r\n  private async getProviderForCollection(collection: string): Promise<any> {\r\n    // Проверяем кэш провайдеров\r\n    if (this.providers.has(collection)) {\r\n      const provider = this.providers.get(collection)!;\r\n      return provider;\r\n    }\r\n\r\n    // Получаем конфигурацию коллекции (заглушка - в реальной реализации это будет из базы данных)\r\n    const config = await this.getCollectionConfig(collection);\r\n\r\n    // Создаем провайдера\r\n    const provider = await providerFactory.createProvider(config);\r\n\r\n    // Кэшируем провайдера\r\n    this.providers.set(collection, provider);\r\n    this.collectionConfigs.set(collection, config);\r\n\r\n    return provider;\r\n  }\r\n\r\n  /**\r\n   * Генерация свежего эмбеддинга через провайдера\r\n   */\r\n  private async generateFreshEmbedding(query: string, provider: any): Promise<Float32Array> {\r\n    const result = await provider.generateEmbedding(query);\r\n\r\n    if (!result.success || !result.embedding) {\r\n      throw new EmbeddingError(\r\n        'Provider failed to generate embedding',\r\n        'PROVIDER_ERROR',\r\n        'provider',\r\n        { error: result.error }\r\n      );\r\n    }\r\n\r\n    return result.embedding;\r\n  }\r\n\r\n  /**\r\n   * Асинхронное сохранение в кэш\r\n   */\r\n  private async saveToCacheAsync(query: string, collection: string, result: PipelineEmbeddingResult): Promise<void> {\r\n    const cacheKey = this.generateCacheKey(query, collection);\r\n\r\n    try {\r\n      // Сохраняем на всех уровнях с разными TTL\r\n      await Promise.all([\r\n        this.cacheManager.set(cacheKey, result, { level: 'memory', ttl: 300000 }), // 5 мин\r\n        this.cacheManager.set(cacheKey, result, { level: 'indexeddb', ttl: 86400000 }), // 24 часа\r\n        this.cacheManager.set(cacheKey, result, { level: 'database', ttl: 604800000 }) // 7 дней\r\n      ]);\r\n    } catch (error) {\r\n      // Логируем, но не прерываем работу\r\n      console.warn('Failed to save to cache:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Генерация ключа кэша\r\n   */\r\n  private generateCacheKey(query: string, collection: string): string {\r\n    const config = this.collectionConfigs.get(collection);\r\n    const configHash = config ? EmbeddingUtils.hashText(JSON.stringify(config), { algorithm: 'simple' }).hash : 'default';\r\n    const queryHash = EmbeddingUtils.hashText(query.trim().toLowerCase(), { algorithm: 'simple' }).hash;\r\n\r\n    return `embedding:${collection}:${configHash}:${queryHash}`;\r\n  }\r\n\r\n  /**\r\n   * Получение конфигурации коллекции (заглушка)\r\n   */\r\n  private async getCollectionConfig(collection: string): Promise<CollectionEmbeddingConfig> {\r\n    // Заглушка - в реальной реализации это будет запрос к базе данных\r\n    // Возвращаем конфигурацию по умолчанию\r\n    return {\r\n      provider: 'transformers',\r\n      model: 'all-MiniLM-L6-v2',\r\n      dimensions: 384,\r\n      batchSize: 32,\r\n      cacheEnabled: true,\r\n      autoGenerate: true,\r\n      timeout: 30000\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Получение типа провайдера\r\n   */\r\n  private getProviderType(provider: any): string {\r\n    // Проверяем по классу или свойствам провайдера\r\n    const modelInfo = provider.getModelInfo?.();\r\n    return modelInfo?.provider || 'unknown';\r\n  }\r\n\r\n  /**\r\n   * Обновление статистики попаданий в кэш\r\n   */\r\n  private updateCacheHitStats(source: PipelineEmbeddingResult['source']): void {\r\n    const current = this.stats.cacheHitsByLevel.get(source) || 0;\r\n    this.stats.cacheHitsByLevel.set(source, current + 1);\r\n  }\r\n\r\n  /**\r\n   * Оценка использования памяти\r\n   */\r\n  private estimateMemoryUsage(): number {\r\n    // Приблизительная оценка (в MB)\r\n    let memoryUsage = 0;\r\n\r\n    // Кэш провайдеров\r\n    memoryUsage += this.providers.size * 10; // ~10MB на провайдера\r\n\r\n    // Модели в памяти\r\n    memoryUsage += this.modelManager.getModelStatus().loadedModels.length * 50; // ~50MB на модель\r\n\r\n    // Кэш результатов (будет точнее реализовано в CacheManager)\r\n    memoryUsage += 20; // ~20MB для кэша результатов\r\n\r\n    return memoryUsage;\r\n  }\r\n}\r\n\r\n/**\r\n * Фабричная функция для создания InternalPipeline\r\n */\r\nexport async function createInternalPipeline(\r\n  cacheManager: CacheManager,\r\n  modelManager: ModelManager\r\n): Promise<InternalPipeline> {\r\n  return new InternalPipelineImpl(cacheManager, modelManager);\r\n}","/**\r\n * ModelManager - управление жизненным циклом embedding моделей\r\n *\r\n * Отвечает за интеллектуальную загрузку, кэширование и оптимизацию памяти\r\n * для embedding моделей. Поддерживает стратегии предзагрузки и автоматическую\r\n * выгрузку неиспользуемых моделей для оптимизации ресурсов.\r\n */\r\n\r\nimport type { EmbeddingProviderType, CollectionEmbeddingConfig } from '../embedding/types.js';\r\nimport { providerFactory } from '../embedding/ProviderFactory.js';\r\nimport { ModelLoadError, ConfigurationError, EmbeddingError } from '../embedding/errors.js';\r\n\r\n/**\r\n * Стратегии загрузки моделей\r\n */\r\nexport type LoadingStrategy = 'eager' | 'lazy' | 'predictive';\r\n\r\n/**\r\n * Информация о загруженной модели\r\n */\r\nexport interface LoadedModel {\r\n  /** Уникальный ID модели */\r\n  modelId: string;\r\n  /** Тип провайдера */\r\n  provider: EmbeddingProviderType;\r\n  /** Название модели */\r\n  modelName: string;\r\n  /** Размерность эмбеддингов */\r\n  dimensions: number;\r\n  /** Экземпляр провайдера */\r\n  providerInstance: any;\r\n  /** Время последнего использования */\r\n  lastUsed: number;\r\n  /** Счетчик использований */\r\n  usageCount: number;\r\n  /** Приблизительное использование памяти в MB */\r\n  memoryUsage: number;\r\n  /** Время загрузки модели */\r\n  loadTime: number;\r\n  /** Статус модели */\r\n  status: 'loading' | 'ready' | 'error' | 'unloading';\r\n  /** Сообщение об ошибке (если есть) */\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Статус ModelManager\r\n */\r\nexport interface ModelStatus {\r\n  /** Загруженные модели */\r\n  loadedModels: LoadedModel[];\r\n  /** Общее использование памяти в MB */\r\n  totalMemoryUsage: number;\r\n  /** Количество активных моделей */\r\n  activeCount: number;\r\n  /** Статистика по провайдерам */\r\n  providerStats: Record<EmbeddingProviderType, {\r\n    count: number;\r\n    memoryUsage: number;\r\n    avgLoadTime: number;\r\n  }>;\r\n}\r\n\r\n/**\r\n * Опции оптимизации памяти\r\n */\r\nexport interface MemoryOptimizationOptions {\r\n  /** Максимальное использование памяти в MB */\r\n  maxMemoryUsage?: number;\r\n  /** Максимальное количество одновременно загруженных моделей */\r\n  maxModels?: number;\r\n  /** Время неактивности перед выгрузкой (мс) */\r\n  idleTimeout?: number;\r\n  /** Принудительная очистка всех неиспользуемых моделей */\r\n  aggressive?: boolean;\r\n}\r\n\r\n/**\r\n * Модель с метриками производительности\r\n */\r\nexport interface EmbeddingModel {\r\n  /** Конфигурация */\r\n  config: CollectionEmbeddingConfig;\r\n  /** Провайдер */\r\n  provider: any;\r\n  /** Метрики производительности */\r\n  metrics: {\r\n    averageInferenceTime: number;\r\n    totalRequests: number;\r\n    successRate: number;\r\n    lastPerformanceCheck: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Интерфейс ModelManager\r\n */\r\nexport interface ModelManager {\r\n  /**\r\n   * Загрузка модели с указанным провайдером\r\n   */\r\n  loadModel(provider: EmbeddingProviderType, model?: string): Promise<EmbeddingModel>;\r\n\r\n  /**\r\n   * Предзагрузка моделей по стратегии\r\n   */\r\n  preloadModels(strategy: LoadingStrategy): Promise<void>;\r\n\r\n  /**\r\n   * Оптимизация использования памяти\r\n   */\r\n  optimizeMemory(options?: MemoryOptimizationOptions): Promise<void>;\r\n\r\n  /**\r\n   * Получение статуса всех моделей\r\n   */\r\n  getModelStatus(): ModelStatus;\r\n\r\n  /**\r\n   * Выгрузка неиспользуемых моделей\r\n   */\r\n  unloadUnusedModels(): Promise<void>;\r\n\r\n  /**\r\n   * Получение модели для коллекции\r\n   */\r\n  getModelForCollection(collection: string): Promise<EmbeddingModel | null>;\r\n\r\n  /**\r\n   * Прогрев модели (предварительная инициализация)\r\n   */\r\n  warmModel(modelId: string): Promise<void>;\r\n}\r\n\r\n/**\r\n * Основная реализация ModelManager\r\n */\r\nexport class ModelManagerImpl implements ModelManager {\r\n  private models: Map<string, LoadedModel>;\r\n  private modelConfigs: Map<string, CollectionEmbeddingConfig>;\r\n  private memoryLimit: number;\r\n  private maxModels: number;\r\n  private idleTimeout: number;\r\n  private cleanupInterval: NodeJS.Timeout | null;\r\n\r\n  // Статистика использования\r\n  private stats: {\r\n    totalLoads: number;\r\n    totalUnloads: number;\r\n    cacheHits: number;\r\n    cacheMisses: number;\r\n    avgLoadTime: number;\r\n  };\r\n\r\n  constructor(options: {\r\n    memoryLimit?: number;\r\n    maxModels?: number;\r\n    idleTimeout?: number;\r\n    cleanupInterval?: number;\r\n  } = {}) {\r\n    this.models = new Map();\r\n    this.modelConfigs = new Map();\r\n    this.memoryLimit = options.memoryLimit || 500; // 500MB по умолчанию\r\n    this.maxModels = options.maxModels || 5; // Максимум 5 моделей одновременно\r\n    this.idleTimeout = options.idleTimeout || 10 * 60 * 1000; // 10 минут неактивности\r\n    this.cleanupInterval = null;\r\n\r\n    this.stats = {\r\n      totalLoads: 0,\r\n      totalUnloads: 0,\r\n      cacheHits: 0,\r\n      cacheMisses: 0,\r\n      avgLoadTime: 0\r\n    };\r\n\r\n    // Запускаем периодическую очистку\r\n    this.startCleanupTimer(options.cleanupInterval || 5 * 60 * 1000); // Каждые 5 минут\r\n  }\r\n\r\n  /**\r\n   * Загрузка модели с кэшированием и оптимизацией\r\n   */\r\n  async loadModel(provider: EmbeddingProviderType, model?: string): Promise<EmbeddingModel> {\r\n    const modelId = this.generateModelId(provider, model);\r\n\r\n    // Проверяем наличие в кэше\r\n    if (this.models.has(modelId)) {\r\n      const cachedModel = this.models.get(modelId)!;\r\n\r\n      if (cachedModel.status === 'ready') {\r\n        // Обновляем статистику использования\r\n        cachedModel.lastUsed = Date.now();\r\n        cachedModel.usageCount++;\r\n        this.stats.cacheHits++;\r\n\r\n        return {\r\n          config: this.modelConfigs.get(modelId)!,\r\n          provider: cachedModel.providerInstance,\r\n          metrics: this.getModelMetrics(modelId)\r\n        };\r\n      } else if (cachedModel.status === 'loading') {\r\n        // Ждем завершения загрузки\r\n        return this.waitForModelLoad(modelId);\r\n      } else if (cachedModel.status === 'error') {\r\n        // Удаляем поврежденную модель и загружаем заново\r\n        this.models.delete(modelId);\r\n        this.modelConfigs.delete(modelId);\r\n      }\r\n    }\r\n\r\n    this.stats.cacheMisses++;\r\n\r\n    // Проверяем лимиты и освобождаем место при необходимости\r\n    await this.ensureResourcesAvailable();\r\n\r\n    // Загружаем новую модель\r\n    return this.loadNewModel(provider, model, modelId);\r\n  }\r\n\r\n  /**\r\n   * Предзагрузка моделей по стратегии\r\n   */\r\n  async preloadModels(strategy: LoadingStrategy): Promise<void> {\r\n    const modelsToLoad = this.getModelsForPreloading(strategy);\r\n\r\n    const loadPromises = modelsToLoad.map(async ({ provider, model }) => {\r\n      try {\r\n        await this.loadModel(provider, model);\r\n      } catch (error) {\r\n        console.warn(`Failed to preload model ${provider}:${model}:`, error);\r\n      }\r\n    });\r\n\r\n    await Promise.all(loadPromises);\r\n  }\r\n\r\n  /**\r\n   * Оптимизация использования памяти\r\n   */\r\n  async optimizeMemory(options?: MemoryOptimizationOptions): Promise<void> {\r\n    const {\r\n      maxMemoryUsage = this.memoryLimit,\r\n      maxModels = this.maxModels,\r\n      idleTimeout = this.idleTimeout,\r\n      aggressive = false\r\n    } = options || {};\r\n\r\n    const currentMemory = this.getTotalMemoryUsage();\r\n    const currentModelCount = this.models.size;\r\n\r\n    // Список моделей для выгрузки, отсортированный по приоритету\r\n    const modelsToUnload = Array.from(this.models.values())\r\n      .filter(model => {\r\n        if (aggressive) return true;\r\n\r\n        const timeSinceLastUsed = Date.now() - model.lastUsed;\r\n        return timeSinceLastUsed > idleTimeout;\r\n      })\r\n      .sort((a, b) => {\r\n        // Приоритет выгрузки: старые + малоиспользуемые модели\r\n        const scoreA = a.lastUsed + (a.usageCount * 1000);\r\n        const scoreB = b.lastUsed + (b.usageCount * 1000);\r\n        return scoreA - scoreB;\r\n      });\r\n\r\n    // Выгружаем модели пока не достигнем целевых лимитов\r\n    let freedMemory = 0;\r\n    let unloadedCount = 0;\r\n\r\n    for (const model of modelsToUnload) {\r\n      const shouldUnload = (\r\n        (currentMemory - freedMemory) > maxMemoryUsage ||\r\n        (currentModelCount - unloadedCount) > maxModels\r\n      );\r\n\r\n      if (!shouldUnload) break;\r\n\r\n      try {\r\n        await this.unloadModel(model.modelId);\r\n        freedMemory += model.memoryUsage;\r\n        unloadedCount++;\r\n      } catch (error) {\r\n        console.warn(`Failed to unload model ${model.modelId}:`, error);\r\n      }\r\n    }\r\n\r\n    console.log(`Memory optimization completed: freed ${freedMemory}MB, unloaded ${unloadedCount} models`);\r\n  }\r\n\r\n  /**\r\n   * Получение статуса всех моделей\r\n   */\r\n  getModelStatus(): ModelStatus {\r\n    const loadedModels = Array.from(this.models.values());\r\n    const totalMemoryUsage = this.getTotalMemoryUsage();\r\n    const activeCount = loadedModels.filter(m => m.status === 'ready').length;\r\n\r\n    // Статистика по провайдерам\r\n    const providerStats: Record<EmbeddingProviderType, any> = {} as any;\r\n\r\n    for (const model of loadedModels) {\r\n      if (!providerStats[model.provider]) {\r\n        providerStats[model.provider] = {\r\n          count: 0,\r\n          memoryUsage: 0,\r\n          avgLoadTime: 0,\r\n          totalLoadTime: 0\r\n        };\r\n      }\r\n\r\n      const stats = providerStats[model.provider];\r\n      stats.count++;\r\n      stats.memoryUsage += model.memoryUsage;\r\n      stats.totalLoadTime += model.loadTime;\r\n      stats.avgLoadTime = stats.totalLoadTime / stats.count;\r\n    }\r\n\r\n    return {\r\n      loadedModels,\r\n      totalMemoryUsage,\r\n      activeCount,\r\n      providerStats\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Выгрузка неиспользуемых моделей\r\n   */\r\n  async unloadUnusedModels(): Promise<void> {\r\n    const cutoffTime = Date.now() - this.idleTimeout;\r\n    const modelsToUnload = Array.from(this.models.values())\r\n      .filter(model => model.lastUsed < cutoffTime && model.status !== 'loading');\r\n\r\n    const unloadPromises = modelsToUnload.map(model => this.unloadModel(model.modelId));\r\n    await Promise.all(unloadPromises);\r\n\r\n    console.log(`Unloaded ${modelsToUnload.length} unused models`);\r\n  }\r\n\r\n  /**\r\n   * Получение модели для коллекции\r\n   */\r\n  async getModelForCollection(collection: string): Promise<EmbeddingModel | null> {\r\n    // Заглушка - получение конфигурации коллекции\r\n    const config = await this.getCollectionConfig(collection);\r\n    if (!config) return null;\r\n\r\n    try {\r\n      return await this.loadModel(config.provider, config.model);\r\n    } catch (error) {\r\n      console.error(`Failed to load model for collection ${collection}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Прогрев модели\r\n   */\r\n  async warmModel(modelId: string): Promise<void> {\r\n    const model = this.models.get(modelId);\r\n    if (!model || model.status !== 'ready') {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Выполняем тестовый вызов для инициализации модели\r\n      const testText = \"test warmup query\";\r\n      await model.providerInstance.generateEmbedding(testText);\r\n      console.log(`Model ${modelId} warmed up successfully`);\r\n    } catch (error) {\r\n      console.warn(`Failed to warm up model ${modelId}:`, error);\r\n    }\r\n  }\r\n\r\n  // === Приватные методы ===\r\n\r\n  /**\r\n   * Загрузка новой модели\r\n   */\r\n  private async loadNewModel(provider: EmbeddingProviderType, model: string | undefined, modelId: string): Promise<EmbeddingModel> {\r\n    const startTime = Date.now();\r\n\r\n    // Создаем конфигурацию модели\r\n    const config: CollectionEmbeddingConfig = {\r\n      provider,\r\n      model: model || this.getDefaultModelForProvider(provider),\r\n      dimensions: this.getDimensionsForProvider(provider),\r\n      batchSize: 32,\r\n      cacheEnabled: true,\r\n      autoGenerate: true,\r\n      timeout: 30000\r\n    };\r\n\r\n    // Добавляем запись о загружающейся модели\r\n    const loadingModel: LoadedModel = {\r\n      modelId,\r\n      provider,\r\n      modelName: config.model!,\r\n      dimensions: config.dimensions,\r\n      providerInstance: null as any, // Будет установлено после загрузки\r\n      lastUsed: Date.now(),\r\n      usageCount: 0,\r\n      memoryUsage: this.estimateModelMemoryUsage(provider),\r\n      loadTime: 0,\r\n      status: 'loading'\r\n    };\r\n\r\n    this.models.set(modelId, loadingModel);\r\n    this.modelConfigs.set(modelId, config);\r\n\r\n    try {\r\n      // Создаем провайдера\r\n      const providerInstance = await providerFactory.createProvider(config);\r\n      const loadTime = Date.now() - startTime;\r\n\r\n      // Обновляем модель\r\n      loadingModel.providerInstance = providerInstance;\r\n      loadingModel.loadTime = loadTime;\r\n      loadingModel.status = 'ready';\r\n      loadingModel.usageCount = 1;\r\n\r\n      // Обновляем статистику\r\n      this.stats.totalLoads++;\r\n      this.stats.avgLoadTime = (this.stats.avgLoadTime * (this.stats.totalLoads - 1) + loadTime) / this.stats.totalLoads;\r\n\r\n      console.log(`Model ${modelId} loaded successfully in ${loadTime}ms`);\r\n\r\n      return {\r\n        config,\r\n        provider: providerInstance,\r\n        metrics: this.getModelMetrics(modelId)\r\n      };\r\n\r\n    } catch (error) {\r\n      // Помечаем модель как ошибочную\r\n      loadingModel.status = 'error';\r\n      loadingModel.error = error instanceof Error ? error.message : String(error);\r\n\r\n      throw new ModelLoadError(\r\n        `Failed to load model ${modelId}: ${loadingModel.error}`,\r\n        provider,\r\n        modelId,\r\n        undefined,\r\n        { model }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Выгрузка модели\r\n   */\r\n  private async unloadModel(modelId: string): Promise<void> {\r\n    const model = this.models.get(modelId);\r\n    if (!model) return;\r\n\r\n    model.status = 'unloading';\r\n\r\n    try {\r\n      // Освобождаем ресурсы провайдера, если есть соответствующий метод\r\n      if (model.providerInstance && typeof model.providerInstance.dispose === 'function') {\r\n        await model.providerInstance.dispose();\r\n      }\r\n\r\n      this.models.delete(modelId);\r\n      this.modelConfigs.delete(modelId);\r\n      this.stats.totalUnloads++;\r\n\r\n      console.log(`Model ${modelId} unloaded successfully`);\r\n\r\n    } catch (error) {\r\n      console.warn(`Failed to properly unload model ${modelId}:`, error);\r\n      // Удаляем из кэша в любом случае\r\n      this.models.delete(modelId);\r\n      this.modelConfigs.delete(modelId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ожидание завершения загрузки модели\r\n   */\r\n  private async waitForModelLoad(modelId: string): Promise<EmbeddingModel> {\r\n    const pollInterval = 100;\r\n    const maxWaitTime = 30000; // 30 секунд\r\n    const startTime = Date.now();\r\n\r\n    while (Date.now() - startTime < maxWaitTime) {\r\n      const model = this.models.get(modelId);\r\n      if (!model) {\r\n        throw new ModelLoadError(`Model ${modelId} was removed during loading`, 'unknown', modelId);\r\n      }\r\n\r\n      if (model.status === 'ready') {\r\n        model.lastUsed = Date.now();\r\n        model.usageCount++;\r\n\r\n        return {\r\n          config: this.modelConfigs.get(modelId)!,\r\n          provider: model.providerInstance,\r\n          metrics: this.getModelMetrics(modelId)\r\n        };\r\n      }\r\n\r\n      if (model.status === 'error') {\r\n        throw new ModelLoadError(`Model ${modelId} failed to load: ${model.error}`, 'unknown', modelId);\r\n      }\r\n\r\n      await new Promise(resolve => setTimeout(resolve, pollInterval));\r\n    }\r\n\r\n    throw new ModelLoadError(`Model ${modelId} loading timeout`, 'unknown', modelId);\r\n  }\r\n\r\n  /**\r\n   * Обеспечение доступности ресурсов\r\n   */\r\n  private async ensureResourcesAvailable(): Promise<void> {\r\n    const currentMemory = this.getTotalMemoryUsage();\r\n    const currentModelCount = this.models.size;\r\n\r\n    // Проверяем превышение лимитов\r\n    if (currentMemory > this.memoryLimit || currentModelCount >= this.maxModels) {\r\n      await this.optimizeMemory({\r\n        maxMemoryUsage: this.memoryLimit * 0.8, // Освобождаем до 80% лимита\r\n        maxModels: this.maxModels - 1 // Оставляем место для новой модели\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение общего использования памяти\r\n   */\r\n  private getTotalMemoryUsage(): number {\r\n    return Array.from(this.models.values())\r\n      .reduce((total, model) => total + model.memoryUsage, 0);\r\n  }\r\n\r\n  /**\r\n   * Генерация ID модели\r\n   */\r\n  private generateModelId(provider: EmbeddingProviderType, model?: string): string {\r\n    const modelName = model || this.getDefaultModelForProvider(provider);\r\n    return `${provider}:${modelName}`;\r\n  }\r\n\r\n  /**\r\n   * Получение модели по умолчанию для провайдера\r\n   */\r\n  private getDefaultModelForProvider(provider: EmbeddingProviderType): string {\r\n    const defaults: Record<EmbeddingProviderType, string> = {\r\n      transformers: 'all-MiniLM-L6-v2',\r\n      openai: 'text-embedding-3-small',\r\n      cohere: 'embed-english-light-v3.0',\r\n      huggingface: 'sentence-transformers/all-MiniLM-L6-v2',\r\n      custom: 'custom-model'\r\n    };\r\n\r\n    return defaults[provider] || 'unknown-model';\r\n  }\r\n\r\n  /**\r\n   * Получение размерности для провайдера\r\n   */\r\n  private getDimensionsForProvider(provider: EmbeddingProviderType): number {\r\n    const dimensions: Record<EmbeddingProviderType, number> = {\r\n      transformers: 384,\r\n      openai: 1536,\r\n      cohere: 1024,\r\n      huggingface: 384,\r\n      custom: 384\r\n    };\r\n\r\n    return dimensions[provider] || 384;\r\n  }\r\n\r\n  /**\r\n   * Оценка использования памяти моделью\r\n   */\r\n  private estimateModelMemoryUsage(provider: EmbeddingProviderType): number {\r\n    const estimates: Record<EmbeddingProviderType, number> = {\r\n      transformers: 100, // ~100MB для all-MiniLM-L6-v2\r\n      openai: 5,         // ~5MB для API клиента\r\n      cohere: 5,         // ~5MB для API клиента\r\n      huggingface: 80,   // ~80MB в среднем\r\n      custom: 50         // ~50MB по умолчанию\r\n    };\r\n\r\n    return estimates[provider] || 50;\r\n  }\r\n\r\n  /**\r\n   * Получение конфигурации коллекции (заглушка)\r\n   */\r\n  private async getCollectionConfig(collection: string): Promise<CollectionEmbeddingConfig | null> {\r\n    // Заглушка - в реальной реализации это будет запрос к базе данных\r\n    return {\r\n      provider: 'transformers',\r\n      model: 'all-MiniLM-L6-v2',\r\n      dimensions: 384,\r\n      batchSize: 32,\r\n      cacheEnabled: true,\r\n      autoGenerate: true,\r\n      timeout: 30000\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Получение моделей для предзагрузки\r\n   */\r\n  private getModelsForPreloading(strategy: LoadingStrategy): Array<{ provider: EmbeddingProviderType; model?: string }> {\r\n    switch (strategy) {\r\n      case 'eager':\r\n        // Загружаем все основные модели\r\n        return [\r\n          { provider: 'transformers', model: 'all-MiniLM-L6-v2' },\r\n          { provider: 'openai', model: 'text-embedding-3-small' }\r\n        ];\r\n\r\n      case 'predictive':\r\n        // Загружаем наиболее часто используемые модели\r\n        return [\r\n          { provider: 'transformers', model: 'all-MiniLM-L6-v2' }\r\n        ];\r\n\r\n      case 'lazy':\r\n      default:\r\n        // Не загружаем ничего заранее\r\n        return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение метрик производительности модели\r\n   */\r\n  private getModelMetrics(modelId: string): EmbeddingModel['metrics'] {\r\n    // Заглушка - в реальной реализации здесь будет реальная статистика\r\n    return {\r\n      averageInferenceTime: 150, // мс\r\n      totalRequests: 0,\r\n      successRate: 1.0,\r\n      lastPerformanceCheck: Date.now()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Запуск таймера автоматической очистки\r\n   */\r\n  private startCleanupTimer(interval: number): void {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n    }\r\n\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.unloadUnusedModels().catch(error => {\r\n        console.warn('Automated cleanup failed:', error);\r\n      });\r\n    }, interval);\r\n  }\r\n\r\n  /**\r\n   * Остановка таймера и освобождение ресурсов\r\n   */\r\n  dispose(): void {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n      this.cleanupInterval = null;\r\n    }\r\n\r\n    // Выгружаем все модели\r\n    const unloadPromises = Array.from(this.models.keys()).map(modelId => this.unloadModel(modelId));\r\n    Promise.all(unloadPromises).catch(error => {\r\n      console.warn('Failed to dispose all models:', error);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Фабричная функция для создания ModelManager\r\n */\r\nexport function createModelManager(options: {\r\n  memoryLimit?: number;\r\n  maxModels?: number;\r\n  idleTimeout?: number;\r\n  cleanupInterval?: number;\r\n} = {}): ModelManager {\r\n  return new ModelManagerImpl(options);\r\n}","/**\r\n * QueryCache - специализированный кэш для query embeddings\r\n *\r\n * Реализует LRU (Least Recently Used) кэширование с оптимизацией\r\n * для поисковых запросов. Включает интеллектуальную политику выселения,\r\n * приоритизацию по частоте использования и статистику производительности.\r\n */\r\n\r\nimport { CacheError } from '../embedding/errors.js';\r\n\r\n/**\r\n * Опции для записи в кэш\r\n */\r\nexport interface QueryCacheOptions {\r\n  /** Время жизни в миллисекундах */\r\n  ttl?: number;\r\n  /** Приоритет элемента */\r\n  priority?: 'low' | 'normal' | 'high';\r\n  /** Теги для группировки */\r\n  tags?: string[];\r\n}\r\n\r\n/**\r\n * Элемент кэша с метаданными\r\n */\r\nexport interface QueryCacheEntry<T = any> {\r\n  /** Ключ кэша */\r\n  key: string;\r\n  /** Значение */\r\n  value: T;\r\n  /** Время создания */\r\n  timestamp: number;\r\n  /** Время истечения */\r\n  expiresAt?: number;\r\n  /** Время последнего доступа */\r\n  lastAccessed: number;\r\n  /** Количество обращений */\r\n  accessCount: number;\r\n  /** Приоритет */\r\n  priority: 'low' | 'normal' | 'high';\r\n  /** Теги */\r\n  tags: string[];\r\n  /** Размер в байтах (приблизительно) */\r\n  size: number;\r\n}\r\n\r\n/**\r\n * Конфигурация QueryCache\r\n */\r\nexport interface QueryCacheConfig {\r\n  /** Максимальный размер кэша (количество элементов) */\r\n  maxSize?: number;\r\n  /** Максимальное использование памяти в байтах */\r\n  maxMemory?: number;\r\n  /** TTL по умолчанию в миллисекундах */\r\n  ttl?: number;\r\n  /** Интервал очистки устаревших элементов */\r\n  cleanupInterval?: number;\r\n  /** Стратегия выселения */\r\n  evictionStrategy?: 'lru' | 'lfu' | 'priority' | 'hybrid';\r\n}\r\n\r\n/**\r\n * Статистика QueryCache\r\n */\r\nexport interface QueryCacheStats {\r\n  /** Общее количество элементов */\r\n  size: number;\r\n  /** Максимальный размер */\r\n  maxSize: number;\r\n  /** Использование памяти в байтах */\r\n  memoryUsage: number;\r\n  /** Максимальное использование памяти */\r\n  maxMemory: number;\r\n  /** Количество попаданий */\r\n  hits: number;\r\n  /** Количество промахов */\r\n  misses: number;\r\n  /** Процент попаданий */\r\n  hitRate: number;\r\n  /** Количество выселений */\r\n  evictions: number;\r\n  /** Средний размер элемента */\r\n  averageEntrySize: number;\r\n  /** Количество истекших элементов */\r\n  expiredEntries: number;\r\n}\r\n\r\n/**\r\n * Основная реализация QueryCache\r\n */\r\nexport class QueryCache<T = any> {\r\n  private cache: Map<string, QueryCacheEntry<T>>;\r\n  private accessOrder: string[]; // Для LRU tracking\r\n  private config: Required<QueryCacheConfig>;\r\n  private cleanupTimer: NodeJS.Timeout | null;\r\n\r\n  // Статистика\r\n  private stats: {\r\n    hits: number;\r\n    misses: number;\r\n    evictions: number;\r\n    expiredEntries: number;\r\n    totalAccessTime: number;\r\n    totalAccessCount: number;\r\n  };\r\n\r\n  constructor(config: QueryCacheConfig = {}) {\r\n    this.cache = new Map();\r\n    this.accessOrder = [];\r\n\r\n    this.config = {\r\n      maxSize: config.maxSize || 1000,\r\n      maxMemory: config.maxMemory || 100 * 1024 * 1024, // 100MB\r\n      ttl: config.ttl || 5 * 60 * 1000, // 5 минут\r\n      cleanupInterval: config.cleanupInterval || 60 * 1000, // 1 минута\r\n      evictionStrategy: config.evictionStrategy || 'lru'\r\n    };\r\n\r\n    this.stats = {\r\n      hits: 0,\r\n      misses: 0,\r\n      evictions: 0,\r\n      expiredEntries: 0,\r\n      totalAccessTime: 0,\r\n      totalAccessCount: 0\r\n    };\r\n\r\n    this.cleanupTimer = null;\r\n    this.startCleanupTimer();\r\n  }\r\n\r\n  /**\r\n   * Получение значения из кэша\r\n   */\r\n  async get(key: string): Promise<T | null> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const entry = this.cache.get(key);\r\n\r\n      if (!entry) {\r\n        this.stats.misses++;\r\n        return null;\r\n      }\r\n\r\n      // Проверяем истечение TTL\r\n      if (entry.expiresAt && Date.now() > entry.expiresAt) {\r\n        this.cache.delete(key);\r\n        this.removeFromAccessOrder(key);\r\n        this.stats.expiredEntries++;\r\n        this.stats.misses++;\r\n        return null;\r\n      }\r\n\r\n      // Обновляем статистику доступа\r\n      entry.lastAccessed = Date.now();\r\n      entry.accessCount++;\r\n      this.moveToFront(key);\r\n\r\n      this.stats.hits++;\r\n      return entry.value;\r\n\r\n    } finally {\r\n      this.stats.totalAccessTime += Date.now() - startTime;\r\n      this.stats.totalAccessCount++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Сохранение значения в кэше\r\n   */\r\n  async set(key: string, value: T, options: QueryCacheOptions = {}): Promise<void> {\r\n    const {\r\n      ttl = this.config.ttl,\r\n      priority = 'normal',\r\n      tags = []\r\n    } = options;\r\n\r\n    const now = Date.now();\r\n    const size = this.estimateSize(value);\r\n\r\n    // Создаем элемент кэша\r\n    const entry: QueryCacheEntry<T> = {\r\n      key,\r\n      value,\r\n      timestamp: now,\r\n      expiresAt: ttl ? now + ttl : undefined,\r\n      lastAccessed: now,\r\n      accessCount: 1,\r\n      priority,\r\n      tags,\r\n      size\r\n    };\r\n\r\n    // Проверяем, нужно ли освободить место\r\n    await this.ensureSpace(size);\r\n\r\n    // Сохраняем элемент\r\n    if (this.cache.has(key)) {\r\n      // Обновляем существующий элемент\r\n      this.removeFromAccessOrder(key);\r\n    }\r\n\r\n    this.cache.set(key, entry);\r\n    this.accessOrder.unshift(key);\r\n\r\n    // Проверяем превышение лимитов после добавления\r\n    await this.enforceConstraints();\r\n  }\r\n\r\n  /**\r\n   * Удаление элемента из кэша\r\n   */\r\n  async delete(key: string): Promise<boolean> {\r\n    const deleted = this.cache.delete(key);\r\n    if (deleted) {\r\n      this.removeFromAccessOrder(key);\r\n    }\r\n    return deleted;\r\n  }\r\n\r\n  /**\r\n   * Проверка наличия ключа в кэше\r\n   */\r\n  has(key: string): boolean {\r\n    const entry = this.cache.get(key);\r\n    if (!entry) return false;\r\n\r\n    // Проверяем истечение TTL\r\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\r\n      this.cache.delete(key);\r\n      this.removeFromAccessOrder(key);\r\n      this.stats.expiredEntries++;\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Получение размера кэша\r\n   */\r\n  size(): number {\r\n    return this.cache.size;\r\n  }\r\n\r\n  /**\r\n   * Очистка кэша\r\n   */\r\n  async clear(): Promise<void> {\r\n    this.cache.clear();\r\n    this.accessOrder = [];\r\n\r\n    // Сброс статистики (кроме общих метрик)\r\n    const totalHits = this.stats.hits;\r\n    const totalMisses = this.stats.misses;\r\n\r\n    this.stats = {\r\n      hits: totalHits,\r\n      misses: totalMisses,\r\n      evictions: 0,\r\n      expiredEntries: 0,\r\n      totalAccessTime: this.stats.totalAccessTime,\r\n      totalAccessCount: this.stats.totalAccessCount\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Удаление элементов по паттерну или тегам\r\n   */\r\n  async invalidate(pattern: string): Promise<void> {\r\n    const keysToDelete: string[] = [];\r\n\r\n    if (pattern === '*') {\r\n      // Удаляем все элементы\r\n      keysToDelete.push(...this.cache.keys());\r\n    } else if (pattern.startsWith('tag:')) {\r\n      // Удаляем по тегу\r\n      const tag = pattern.substring(4);\r\n      for (const [key, entry] of this.cache.entries()) {\r\n        if (entry.tags.includes(tag)) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n    } else if (pattern.includes('*')) {\r\n      // Удаляем по wildcard паттерну\r\n      const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\r\n      for (const key of this.cache.keys()) {\r\n        if (regex.test(key)) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n    } else {\r\n      // Точное совпадение\r\n      if (this.cache.has(pattern)) {\r\n        keysToDelete.push(pattern);\r\n      }\r\n    }\r\n\r\n    // Удаляем найденные ключи\r\n    for (const key of keysToDelete) {\r\n      await this.delete(key);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение статистики кэша\r\n   */\r\n  getStats(): QueryCacheStats {\r\n    const memoryUsage = this.getMemoryUsage();\r\n    const totalRequests = this.stats.hits + this.stats.misses;\r\n    const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests) * 100 : 0;\r\n\r\n    const averageEntrySize = this.cache.size > 0\r\n      ? Array.from(this.cache.values()).reduce((sum, entry) => sum + entry.size, 0) / this.cache.size\r\n      : 0;\r\n\r\n    return {\r\n      size: this.cache.size,\r\n      maxSize: this.config.maxSize,\r\n      memoryUsage,\r\n      maxMemory: this.config.maxMemory,\r\n      hits: this.stats.hits,\r\n      misses: this.stats.misses,\r\n      hitRate,\r\n      evictions: this.stats.evictions,\r\n      averageEntrySize,\r\n      expiredEntries: this.stats.expiredEntries\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Оптимизация кэша\r\n   */\r\n  async optimize(): Promise<void> {\r\n    // Удаляем истекшие элементы\r\n    await this.cleanupExpired();\r\n\r\n    // Применяем стратегию выселения если нужно\r\n    await this.enforceConstraints();\r\n\r\n    // Дефрагментируем accessOrder\r\n    this.defragmentAccessOrder();\r\n  }\r\n\r\n  /**\r\n   * Получение текущего использования памяти\r\n   */\r\n  getMemoryUsage(): number {\r\n    let totalSize = 0;\r\n    for (const entry of this.cache.values()) {\r\n      totalSize += entry.size;\r\n    }\r\n    return totalSize;\r\n  }\r\n\r\n  // === Приватные методы ===\r\n\r\n  /**\r\n   * Обеспечение доступного места в кэше\r\n   */\r\n  private async ensureSpace(requiredSize: number): Promise<void> {\r\n    const currentMemory = this.getMemoryUsage();\r\n\r\n    if (currentMemory + requiredSize > this.config.maxMemory ||\r\n        this.cache.size >= this.config.maxSize) {\r\n      await this.evictEntries(requiredSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Применение ограничений кэша\r\n   */\r\n  private async enforceConstraints(): Promise<void> {\r\n    // Удаляем истекшие элементы\r\n    await this.cleanupExpired();\r\n\r\n    // Проверяем размерные ограничения\r\n    const currentMemory = this.getMemoryUsage();\r\n\r\n    if (currentMemory > this.config.maxMemory || this.cache.size > this.config.maxSize) {\r\n      await this.evictEntries(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Выселение элементов согласно стратегии\r\n   */\r\n  private async evictEntries(requiredSpace: number): Promise<void> {\r\n    const targetMemory = this.config.maxMemory * 0.8; // Освобождаем до 80% лимита\r\n    const targetSize = Math.floor(this.config.maxSize * 0.8);\r\n\r\n    let freedMemory = 0;\r\n    const keysToEvict: string[] = [];\r\n\r\n    // Сортируем элементы по приоритету выселения\r\n    const entries = Array.from(this.cache.entries());\r\n    const sortedEntries = this.sortForEviction(entries);\r\n\r\n    for (const [key, entry] of sortedEntries) {\r\n      keysToEvict.push(key);\r\n      freedMemory += entry.size;\r\n\r\n      const remainingMemory = this.getMemoryUsage() - freedMemory;\r\n      const remainingCount = this.cache.size - keysToEvict.length;\r\n\r\n      // Проверяем, достигли ли целевых показателей\r\n      if (remainingMemory <= targetMemory &&\r\n          remainingMemory <= this.config.maxMemory - requiredSpace &&\r\n          remainingCount <= targetSize) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Выселяем элементы\r\n    for (const key of keysToEvict) {\r\n      this.cache.delete(key);\r\n      this.removeFromAccessOrder(key);\r\n      this.stats.evictions++;\r\n    }\r\n\r\n    console.log(`Evicted ${keysToEvict.length} entries, freed ${freedMemory} bytes`);\r\n  }\r\n\r\n  /**\r\n   * Сортировка элементов для выселения\r\n   */\r\n  private sortForEviction(entries: [string, QueryCacheEntry<T>][]): [string, QueryCacheEntry<T>][] {\r\n    switch (this.config.evictionStrategy) {\r\n      case 'lru':\r\n        return entries.sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);\r\n\r\n      case 'lfu':\r\n        return entries.sort((a, b) => a[1].accessCount - b[1].accessCount);\r\n\r\n      case 'priority':\r\n        const priorityOrder = { 'low': 0, 'normal': 1, 'high': 2 };\r\n        return entries.sort((a, b) => {\r\n          const priorityDiff = priorityOrder[a[1].priority] - priorityOrder[b[1].priority];\r\n          if (priorityDiff !== 0) return priorityDiff;\r\n          return a[1].lastAccessed - b[1].lastAccessed; // LRU как tiebreaker\r\n        });\r\n\r\n      case 'hybrid':\r\n      default:\r\n        // Гибридная стратегия: учитываем приоритет, частоту и время\r\n        return entries.sort((a, b) => {\r\n          const priorityOrder = { 'low': 0, 'normal': 1, 'high': 2 };\r\n          const priorityScore = (entry: QueryCacheEntry<T>) => priorityOrder[entry.priority] * 1000;\r\n          const frequencyScore = (entry: QueryCacheEntry<T>) => entry.accessCount * 100;\r\n          const recencyScore = (entry: QueryCacheEntry<T>) => (Date.now() - entry.lastAccessed) / 1000;\r\n\r\n          const scoreA = priorityScore(a[1]) + frequencyScore(a[1]) - recencyScore(a[1]);\r\n          const scoreB = priorityScore(b[1]) + frequencyScore(b[1]) - recencyScore(b[1]);\r\n\r\n          return scoreA - scoreB; // Меньший score = выселяется первым\r\n        });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Очистка истекших элементов\r\n   */\r\n  private async cleanupExpired(): Promise<void> {\r\n    const now = Date.now();\r\n    const keysToDelete: string[] = [];\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (entry.expiresAt && now > entry.expiresAt) {\r\n        keysToDelete.push(key);\r\n      }\r\n    }\r\n\r\n    for (const key of keysToDelete) {\r\n      this.cache.delete(key);\r\n      this.removeFromAccessOrder(key);\r\n      this.stats.expiredEntries++;\r\n    }\r\n\r\n    if (keysToDelete.length > 0) {\r\n      console.log(`Cleaned up ${keysToDelete.length} expired entries`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Перемещение элемента в начало списка доступа (LRU)\r\n   */\r\n  private moveToFront(key: string): void {\r\n    this.removeFromAccessOrder(key);\r\n    this.accessOrder.unshift(key);\r\n  }\r\n\r\n  /**\r\n   * Удаление элемента из списка доступа\r\n   */\r\n  private removeFromAccessOrder(key: string): void {\r\n    const index = this.accessOrder.indexOf(key);\r\n    if (index > -1) {\r\n      this.accessOrder.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Дефрагментация списка доступа\r\n   */\r\n  private defragmentAccessOrder(): void {\r\n    this.accessOrder = this.accessOrder.filter(key => this.cache.has(key));\r\n  }\r\n\r\n  /**\r\n   * Оценка размера значения в байтах\r\n   */\r\n  private estimateSize(value: T): number {\r\n    try {\r\n      const jsonString = JSON.stringify(value);\r\n      return jsonString.length * 2; // UTF-16 uses 2 bytes per character\r\n    } catch {\r\n      // Fallback для объектов, которые не сериализуются\r\n      return 1000; // 1KB по умолчанию\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Запуск таймера очистки\r\n   */\r\n  private startCleanupTimer(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n    }\r\n\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanupExpired().catch(error => {\r\n        console.warn('Cleanup timer error:', error);\r\n      });\r\n    }, this.config.cleanupInterval);\r\n  }\r\n\r\n  /**\r\n   * Остановка таймера и освобождение ресурсов\r\n   */\r\n  dispose(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = null;\r\n    }\r\n\r\n    this.clear();\r\n  }\r\n}","/**\r\n * ModelCache - кэширование embedding моделей и их метаданных\r\n *\r\n * Специализированный кэш для embedding моделей, обеспечивающий:\r\n * - Кэширование загруженных моделей и их состояний\r\n * - Оптимизацию памяти для больших моделей\r\n * - Предзагрузку и warming стратегии\r\n * - Статистику использования моделей\r\n */\r\n\r\nimport type { EmbeddingProviderType } from '../embedding/types.js';\r\nimport type { EmbeddingProvider } from '../embedding/providers/BaseProvider.js';\r\nimport { CacheError } from '../embedding/errors.js';\r\n\r\n/**\r\n * Кэшированная информация о модели\r\n */\r\nexport interface CachedModelInfo {\r\n  /** ID модели */\r\n  modelId: string;\r\n  /** Тип провайдера */\r\n  provider: EmbeddingProviderType;\r\n  /** Название модели */\r\n  modelName: string;\r\n  /** Размерность эмбеддингов */\r\n  dimensions: number;\r\n  /** Время загрузки модели */\r\n  loadTime: number;\r\n  /** Время кэширования */\r\n  cachedAt: number;\r\n  /** Время последнего использования */\r\n  lastUsed: number;\r\n  /** Количество использований */\r\n  usageCount: number;\r\n  /** Приблизительное использование памяти в MB */\r\n  memoryUsage: number;\r\n  /** Статус модели */\r\n  status: 'cached' | 'loading' | 'ready' | 'error';\r\n  /** Метаданные производительности */\r\n  performance: {\r\n    averageInferenceTime: number;\r\n    successRate: number;\r\n    errorCount: number;\r\n    lastBenchmark: number;\r\n  };\r\n  /** Теги для группировки */\r\n  tags: string[];\r\n}\r\n\r\n/**\r\n * Конфигурация ModelCache\r\n */\r\nexport interface ModelCacheConfig {\r\n  /** Максимальное количество моделей в кэше */\r\n  maxSize?: number;\r\n  /** Максимальное использование памяти в MB */\r\n  maxMemory?: number;\r\n  /** TTL для кэшированных моделей в мс */\r\n  ttl?: number;\r\n  /** Стратегия выселения моделей */\r\n  evictionStrategy?: 'lru' | 'memory_usage' | 'usage_count' | 'hybrid';\r\n  /** Интервал оптимизации кэша */\r\n  optimizationInterval?: number;\r\n}\r\n\r\n/**\r\n * Статистика ModelCache\r\n */\r\nexport interface ModelCacheStats {\r\n  /** Количество кэшированных моделей */\r\n  size: number;\r\n  /** Максимальный размер кэша */\r\n  maxSize: number;\r\n  /** Общее использование памяти в MB */\r\n  memoryUsage: number;\r\n  /** Максимально разрешенная память */\r\n  maxMemory: number;\r\n  /** Статистика по провайдерам */\r\n  providerStats: Record<string, {\r\n    count: number;\r\n    memoryUsage: number;\r\n    avgInferenceTime: number;\r\n    successRate: number;\r\n  }>;\r\n  /** Производительность кэша */\r\n  cachePerformance: {\r\n    hits: number;\r\n    misses: number;\r\n    hitRate: number;\r\n    evictions: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Запись в кэше моделей\r\n */\r\nexport interface ModelCacheEntry {\r\n  /** Информация о модели */\r\n  modelInfo: CachedModelInfo;\r\n  /** Экземпляр провайдера (если загружен) */\r\n  providerInstance?: EmbeddingProvider;\r\n  /** Время истечения кэша */\r\n  expiresAt?: number;\r\n}\r\n\r\n/**\r\n * Основная реализация ModelCache\r\n */\r\nexport class ModelCache {\r\n  private cache: Map<string, ModelCacheEntry>;\r\n  private config: Required<ModelCacheConfig>;\r\n  private optimizationTimer: NodeJS.Timeout | null;\r\n\r\n  // Статистика\r\n  private stats: {\r\n    hits: number;\r\n    misses: number;\r\n    evictions: number;\r\n    totalLoadTime: number;\r\n    totalLoads: number;\r\n  };\r\n\r\n  constructor(config: ModelCacheConfig = {}) {\r\n    this.cache = new Map();\r\n\r\n    this.config = {\r\n      maxSize: config.maxSize || 10,\r\n      maxMemory: config.maxMemory || 500, // 500MB\r\n      ttl: config.ttl || 30 * 60 * 1000, // 30 минут\r\n      evictionStrategy: config.evictionStrategy || 'hybrid',\r\n      optimizationInterval: config.optimizationInterval || 5 * 60 * 1000 // 5 минут\r\n    };\r\n\r\n    this.stats = {\r\n      hits: 0,\r\n      misses: 0,\r\n      evictions: 0,\r\n      totalLoadTime: 0,\r\n      totalLoads: 0\r\n    };\r\n\r\n    this.optimizationTimer = null;\r\n    this.startOptimizationTimer();\r\n  }\r\n\r\n  /**\r\n   * Получение модели из кэша\r\n   */\r\n  async get(modelId: string): Promise<CachedModelInfo | null> {\r\n    const entry = this.cache.get(modelId);\r\n\r\n    if (!entry) {\r\n      this.stats.misses++;\r\n      return null;\r\n    }\r\n\r\n    // Проверяем истечение TTL\r\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\r\n      this.cache.delete(modelId);\r\n      this.stats.misses++;\r\n      return null;\r\n    }\r\n\r\n    // Обновляем статистику использования\r\n    entry.modelInfo.lastUsed = Date.now();\r\n    entry.modelInfo.usageCount++;\r\n\r\n    this.stats.hits++;\r\n    return entry.modelInfo;\r\n  }\r\n\r\n  /**\r\n   * Сохранение модели в кэш\r\n   */\r\n  async set(modelId: string, modelInfo: CachedModelInfo, providerInstance?: EmbeddingProvider): Promise<void> {\r\n    // Проверяем необходимость освобождения места\r\n    await this.ensureSpace(modelInfo.memoryUsage);\r\n\r\n    const entry: ModelCacheEntry = {\r\n      modelInfo: {\r\n        ...modelInfo,\r\n        cachedAt: Date.now(),\r\n        lastUsed: Date.now()\r\n      },\r\n      providerInstance,\r\n      expiresAt: this.config.ttl ? Date.now() + this.config.ttl : undefined\r\n    };\r\n\r\n    this.cache.set(modelId, entry);\r\n    this.stats.totalLoads++;\r\n    this.stats.totalLoadTime += modelInfo.loadTime;\r\n\r\n    console.log(`Model ${modelId} cached successfully (${modelInfo.memoryUsage}MB)`);\r\n  }\r\n\r\n  /**\r\n   * Получение экземпляра провайдера\r\n   */\r\n  async getProvider(modelId: string): Promise<EmbeddingProvider | null> {\r\n    const entry = this.cache.get(modelId);\r\n    return entry?.providerInstance || null;\r\n  }\r\n\r\n  /**\r\n   * Обновление производительности модели\r\n   */\r\n  async updatePerformance(modelId: string, stats: {\r\n    inferenceTime?: number;\r\n    success?: boolean;\r\n    error?: boolean;\r\n  }): Promise<void> {\r\n    const entry = this.cache.get(modelId);\r\n    if (!entry) return;\r\n\r\n    const perf = entry.modelInfo.performance;\r\n\r\n    if (stats.inferenceTime !== undefined) {\r\n      const totalInferences = entry.modelInfo.usageCount;\r\n      perf.averageInferenceTime = totalInferences > 1\r\n        ? (perf.averageInferenceTime * (totalInferences - 1) + stats.inferenceTime) / totalInferences\r\n        : stats.inferenceTime;\r\n    }\r\n\r\n    if (stats.success !== undefined) {\r\n      const totalRequests = entry.modelInfo.usageCount;\r\n      const successfulRequests = Math.round(perf.successRate * (totalRequests - 1));\r\n      const newSuccessful = successfulRequests + (stats.success ? 1 : 0);\r\n      perf.successRate = newSuccessful / totalRequests;\r\n    }\r\n\r\n    if (stats.error) {\r\n      perf.errorCount++;\r\n    }\r\n\r\n    perf.lastBenchmark = Date.now();\r\n  }\r\n\r\n  /**\r\n   * Проверка наличия модели в кэше\r\n   */\r\n  has(modelId: string): boolean {\r\n    const entry = this.cache.get(modelId);\r\n    if (!entry) return false;\r\n\r\n    // Проверяем истечение TTL\r\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\r\n      this.cache.delete(modelId);\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Удаление модели из кэша\r\n   */\r\n  async delete(modelId: string): Promise<boolean> {\r\n    const entry = this.cache.get(modelId);\r\n    if (!entry) return false;\r\n\r\n    // Освобождаем ресурсы провайдера\r\n    if (entry.providerInstance && 'dispose' in entry.providerInstance && typeof (entry.providerInstance as any).dispose === 'function') {\r\n      try {\r\n        await (entry.providerInstance as any).dispose();\r\n      } catch (error) {\r\n        console.warn(`Failed to dispose provider for model ${modelId}:`, error);\r\n      }\r\n    }\r\n\r\n    return this.cache.delete(modelId);\r\n  }\r\n\r\n  /**\r\n   * Удаление моделей по паттерну\r\n   */\r\n  async invalidate(pattern: string): Promise<void> {\r\n    const keysToDelete: string[] = [];\r\n\r\n    if (pattern === '*') {\r\n      keysToDelete.push(...this.cache.keys());\r\n    } else if (pattern.startsWith('provider:')) {\r\n      const provider = pattern.substring(9);\r\n      for (const [key, entry] of this.cache.entries()) {\r\n        if (entry.modelInfo.provider === provider) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n    } else if (pattern.startsWith('tag:')) {\r\n      const tag = pattern.substring(4);\r\n      for (const [key, entry] of this.cache.entries()) {\r\n        if (entry.modelInfo.tags.includes(tag)) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n    } else if (pattern.includes('*')) {\r\n      const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\r\n      for (const key of this.cache.keys()) {\r\n        if (regex.test(key)) {\r\n          keysToDelete.push(key);\r\n        }\r\n      }\r\n    } else {\r\n      if (this.cache.has(pattern)) {\r\n        keysToDelete.push(pattern);\r\n      }\r\n    }\r\n\r\n    // Удаляем найденные модели\r\n    for (const key of keysToDelete) {\r\n      await this.delete(key);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение всех кэшированных моделей\r\n   */\r\n  getAllModels(): CachedModelInfo[] {\r\n    return Array.from(this.cache.values()).map(entry => entry.modelInfo);\r\n  }\r\n\r\n  /**\r\n   * Получение моделей по провайдеру\r\n   */\r\n  getModelsByProvider(provider: EmbeddingProviderType): CachedModelInfo[] {\r\n    return this.getAllModels().filter(model => model.provider === provider);\r\n  }\r\n\r\n  /**\r\n   * Получение наиболее используемых моделей\r\n   */\r\n  getMostUsedModels(limit: number = 5): CachedModelInfo[] {\r\n    return this.getAllModels()\r\n      .sort((a, b) => b.usageCount - a.usageCount)\r\n      .slice(0, limit);\r\n  }\r\n\r\n  /**\r\n   * Получение статистики кэша\r\n   */\r\n  getStats(): ModelCacheStats {\r\n    const models = this.getAllModels();\r\n    const totalMemoryUsage = models.reduce((sum, model) => sum + model.memoryUsage, 0);\r\n\r\n    // Статистика по провайдерам\r\n    const providerStats: Record<string, any> = {};\r\n    for (const model of models) {\r\n      if (!providerStats[model.provider]) {\r\n        providerStats[model.provider] = {\r\n          count: 0,\r\n          memoryUsage: 0,\r\n          totalInferenceTime: 0,\r\n          totalSuccessRate: 0\r\n        };\r\n      }\r\n\r\n      const stats = providerStats[model.provider];\r\n      stats.count++;\r\n      stats.memoryUsage += model.memoryUsage;\r\n      stats.totalInferenceTime += model.performance.averageInferenceTime;\r\n      stats.totalSuccessRate += model.performance.successRate;\r\n    }\r\n\r\n    // Вычисляем средние значения\r\n    for (const provider of Object.keys(providerStats)) {\r\n      const stats = providerStats[provider];\r\n      stats.avgInferenceTime = stats.totalInferenceTime / stats.count;\r\n      stats.successRate = stats.totalSuccessRate / stats.count;\r\n      delete stats.totalInferenceTime;\r\n      delete stats.totalSuccessRate;\r\n    }\r\n\r\n    const totalRequests = this.stats.hits + this.stats.misses;\r\n    const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests) * 100 : 0;\r\n\r\n    return {\r\n      size: this.cache.size,\r\n      maxSize: this.config.maxSize,\r\n      memoryUsage: totalMemoryUsage,\r\n      maxMemory: this.config.maxMemory,\r\n      providerStats,\r\n      cachePerformance: {\r\n        hits: this.stats.hits,\r\n        misses: this.stats.misses,\r\n        hitRate,\r\n        evictions: this.stats.evictions\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Очистка всего кэша\r\n   */\r\n  async clear(): Promise<void> {\r\n    const deletePromises = Array.from(this.cache.keys()).map(key => this.delete(key));\r\n    await Promise.all(deletePromises);\r\n\r\n    this.cache.clear();\r\n\r\n    // Сброс статистики\r\n    this.stats = {\r\n      hits: this.stats.hits,\r\n      misses: this.stats.misses,\r\n      evictions: 0,\r\n      totalLoadTime: 0,\r\n      totalLoads: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Оптимизация кэша\r\n   */\r\n  async optimize(): Promise<void> {\r\n    // Удаляем истекшие модели\r\n    await this.cleanupExpired();\r\n\r\n    // Применяем стратегию выселения если превышены лимиты\r\n    const currentMemory = this.getCurrentMemoryUsage();\r\n    if (currentMemory > this.config.maxMemory || this.cache.size > this.config.maxSize) {\r\n      await this.evictModels();\r\n    }\r\n\r\n    console.log('Model cache optimization completed');\r\n  }\r\n\r\n  /**\r\n   * Получение текущего использования памяти\r\n   */\r\n  getMemoryUsage(): number {\r\n    return this.getCurrentMemoryUsage();\r\n  }\r\n\r\n  // === Приватные методы ===\r\n\r\n  /**\r\n   * Обеспечение свободного места в кэше\r\n   */\r\n  private async ensureSpace(requiredMemory: number): Promise<void> {\r\n    const currentMemory = this.getCurrentMemoryUsage();\r\n\r\n    if (currentMemory + requiredMemory > this.config.maxMemory ||\r\n        this.cache.size >= this.config.maxSize) {\r\n      await this.evictModels(requiredMemory);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Выселение моделей согласно стратегии\r\n   */\r\n  private async evictModels(requiredSpace: number = 0): Promise<void> {\r\n    const targetMemory = Math.min(\r\n      this.config.maxMemory * 0.8,\r\n      this.config.maxMemory - requiredSpace\r\n    );\r\n    const targetSize = Math.floor(this.config.maxSize * 0.8);\r\n\r\n    const entries = Array.from(this.cache.entries());\r\n    const sortedEntries = this.sortForEviction(entries);\r\n\r\n    let freedMemory = 0;\r\n    const keysToEvict: string[] = [];\r\n\r\n    for (const [key, entry] of sortedEntries) {\r\n      keysToEvict.push(key);\r\n      freedMemory += entry.modelInfo.memoryUsage;\r\n\r\n      const remainingMemory = this.getCurrentMemoryUsage() - freedMemory;\r\n      const remainingCount = this.cache.size - keysToEvict.length;\r\n\r\n      if (remainingMemory <= targetMemory && remainingCount <= targetSize) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Выселяем модели\r\n    for (const key of keysToEvict) {\r\n      await this.delete(key);\r\n      this.stats.evictions++;\r\n    }\r\n\r\n    console.log(`Evicted ${keysToEvict.length} models, freed ${freedMemory}MB`);\r\n  }\r\n\r\n  /**\r\n   * Сортировка моделей для выселения\r\n   */\r\n  private sortForEviction(entries: [string, ModelCacheEntry][]): [string, ModelCacheEntry][] {\r\n    switch (this.config.evictionStrategy) {\r\n      case 'lru':\r\n        return entries.sort((a, b) => a[1].modelInfo.lastUsed - b[1].modelInfo.lastUsed);\r\n\r\n      case 'memory_usage':\r\n        return entries.sort((a, b) => b[1].modelInfo.memoryUsage - a[1].modelInfo.memoryUsage);\r\n\r\n      case 'usage_count':\r\n        return entries.sort((a, b) => a[1].modelInfo.usageCount - b[1].modelInfo.usageCount);\r\n\r\n      case 'hybrid':\r\n      default:\r\n        // Гибридная стратегия: учитываем все факторы\r\n        return entries.sort((a, b) => {\r\n          const scoreA = this.calculateEvictionScore(a[1].modelInfo);\r\n          const scoreB = this.calculateEvictionScore(b[1].modelInfo);\r\n          return scoreA - scoreB; // Меньший score = выселяется первым\r\n        });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Вычисление оценки для выселения (гибридная стратегия)\r\n   */\r\n  private calculateEvictionScore(model: CachedModelInfo): number {\r\n    const now = Date.now();\r\n    const ageScore = (now - model.lastUsed) / (60 * 1000); // Минуты с последнего использования\r\n    const usageScore = Math.max(1, model.usageCount) * 100; // Частота использования\r\n    const memoryScore = model.memoryUsage * 10; // Использование памяти\r\n    const performanceScore = model.performance.successRate * 50; // Производительность\r\n\r\n    // Итоговая оценка: возраст + память - использование - производительность\r\n    return ageScore + memoryScore - usageScore - performanceScore;\r\n  }\r\n\r\n  /**\r\n   * Очистка истекших моделей\r\n   */\r\n  private async cleanupExpired(): Promise<void> {\r\n    const now = Date.now();\r\n    const keysToDelete: string[] = [];\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (entry.expiresAt && now > entry.expiresAt) {\r\n        keysToDelete.push(key);\r\n      }\r\n    }\r\n\r\n    for (const key of keysToDelete) {\r\n      await this.delete(key);\r\n    }\r\n\r\n    if (keysToDelete.length > 0) {\r\n      console.log(`Cleaned up ${keysToDelete.length} expired models`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение текущего использования памяти\r\n   */\r\n  private getCurrentMemoryUsage(): number {\r\n    let totalMemory = 0;\r\n    for (const entry of this.cache.values()) {\r\n      totalMemory += entry.modelInfo.memoryUsage;\r\n    }\r\n    return totalMemory;\r\n  }\r\n\r\n  /**\r\n   * Запуск таймера оптимизации\r\n   */\r\n  private startOptimizationTimer(): void {\r\n    if (this.optimizationTimer) {\r\n      clearInterval(this.optimizationTimer);\r\n    }\r\n\r\n    this.optimizationTimer = setInterval(() => {\r\n      this.optimize().catch(error => {\r\n        console.warn('Model cache optimization failed:', error);\r\n      });\r\n    }, this.config.optimizationInterval);\r\n  }\r\n\r\n  /**\r\n   * Остановка таймера и освобождение ресурсов\r\n   */\r\n  dispose(): void {\r\n    if (this.optimizationTimer) {\r\n      clearInterval(this.optimizationTimer);\r\n      this.optimizationTimer = null;\r\n    }\r\n\r\n    this.clear().catch(error => {\r\n      console.warn('Failed to clear model cache during disposal:', error);\r\n    });\r\n  }\r\n}","/**\r\n * CacheManager - координатор многоуровневого кэширования\r\n *\r\n * Реализует трехуровневую архитектуру кэширования:\r\n * 1. Memory Cache - быстрый доступ, ограниченный размер\r\n * 2. IndexedDB - персистентное хранилище в браузере\r\n * 3. SQLite Database - долгосрочное хранение через worker\r\n *\r\n * Стратегия кэширования:\r\n * - Чтение: Memory → IndexedDB → SQLite → null\r\n * - Запись: во все уровни с разными TTL\r\n * - Invalidation: каскадная очистка по паттернам\r\n */\r\n\r\nimport { QueryCache } from './QueryCache.js';\r\nimport { ModelCache } from './ModelCache.js';\r\nimport { EmbeddingError, CacheError } from '../embedding/errors.js';\r\n\r\n/**\r\n * Уровни кэширования\r\n */\r\nexport type CacheLevel = 'memory' | 'indexeddb' | 'database';\r\n\r\n/**\r\n * Опции кэширования\r\n */\r\nexport interface CacheOptions {\r\n  /** Уровень кэша для записи */\r\n  level?: CacheLevel;\r\n  /** Время жизни в миллисекундах */\r\n  ttl?: number;\r\n  /** Теги для группировки данных */\r\n  tags?: string[];\r\n  /** Приоритет элемента кэша */\r\n  priority?: 'low' | 'normal' | 'high';\r\n  /** Сжатие данных */\r\n  compression?: boolean;\r\n}\r\n\r\n/**\r\n * Статистика кэширования\r\n */\r\nexport interface CacheStatistics {\r\n  /** Общее количество запросов */\r\n  totalRequests: number;\r\n  /** Попадания в кэш */\r\n  hits: {\r\n    memory: number;\r\n    indexeddb: number;\r\n    database: number;\r\n    total: number;\r\n  };\r\n  /** Промахи кэша */\r\n  misses: number;\r\n  /** Процент попаданий */\r\n  hitRate: number;\r\n  /** Использование памяти по уровням (MB) */\r\n  memoryUsage: {\r\n    memory: number;\r\n    indexeddb: number;\r\n    database: number;\r\n  };\r\n  /** Средние времена доступа (мс) */\r\n  avgAccessTime: {\r\n    memory: number;\r\n    indexeddb: number;\r\n    database: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Результат операции кэширования\r\n */\r\nexport interface CacheResult<T = any> {\r\n  /** Данные из кэша */\r\n  data: T | null;\r\n  /** Источник данных */\r\n  source: CacheLevel | 'miss';\r\n  /** Время доступа в мс */\r\n  accessTime: number;\r\n  /** Попадание в кэш */\r\n  hit: boolean;\r\n}\r\n\r\n/**\r\n * Интерфейс CacheManager\r\n */\r\nexport interface CacheManager {\r\n  /**\r\n   * Получение данных из кэша (проверка всех уровней)\r\n   */\r\n  get<T = any>(key: string, level?: CacheLevel): Promise<T | null>;\r\n\r\n  /**\r\n   * Сохранение данных в кэш\r\n   */\r\n  set<T = any>(key: string, value: T, options?: CacheOptions): Promise<void>;\r\n\r\n  /**\r\n   * Удаление данных по паттерну или конкретному ключу\r\n   */\r\n  invalidate(pattern: string): Promise<void>;\r\n\r\n  /**\r\n   * Предварительный прогрев кэша\r\n   */\r\n  warmCache(collection: string, queries: string[]): Promise<void>;\r\n\r\n  /**\r\n   * Предзагрузка моделей в кэш\r\n   */\r\n  preloadModels(providers: string[]): Promise<void>;\r\n\r\n  /**\r\n   * Получение статистики кэширования\r\n   */\r\n  getStats(): CacheStatistics;\r\n\r\n  /**\r\n   * Очистка всех уровней кэша\r\n   */\r\n  clear(): Promise<void>;\r\n\r\n  /**\r\n   * Оптимизация кэша (удаление устаревших данных)\r\n   */\r\n  optimize(): Promise<void>;\r\n}\r\n\r\n/**\r\n * Основная реализация CacheManager\r\n */\r\nexport class CacheManagerImpl implements CacheManager {\r\n  private queryCache: QueryCache;\r\n  private modelCache: ModelCache;\r\n\r\n  // Статистика производительности\r\n  private stats: {\r\n    totalRequests: number;\r\n    memoryHits: number;\r\n    indexedDBHits: number;\r\n    databaseHits: number;\r\n    misses: number;\r\n    totalAccessTime: number;\r\n    levelAccessTimes: Map<CacheLevel, { total: number; count: number }>;\r\n  };\r\n\r\n  // IndexedDB для второго уровня кэширования\r\n  private indexedDB: IDBDatabase | null;\r\n  private dbReady: Promise<void>;\r\n\r\n  constructor(options: {\r\n    memorySize?: number;\r\n    indexedDBName?: string;\r\n    dbVersion?: number;\r\n  } = {}) {\r\n    this.queryCache = new QueryCache({\r\n      maxSize: options.memorySize || 1000,\r\n      ttl: 5 * 60 * 1000, // 5 минут для memory cache\r\n    });\r\n\r\n    this.modelCache = new ModelCache({\r\n      maxSize: 50, // Максимум 50 моделей в кэше\r\n      ttl: 30 * 60 * 1000, // 30 минут для моделей\r\n    });\r\n\r\n    this.stats = {\r\n      totalRequests: 0,\r\n      memoryHits: 0,\r\n      indexedDBHits: 0,\r\n      databaseHits: 0,\r\n      misses: 0,\r\n      totalAccessTime: 0,\r\n      levelAccessTimes: new Map([\r\n        ['memory', { total: 0, count: 0 }],\r\n        ['indexeddb', { total: 0, count: 0 }],\r\n        ['database', { total: 0, count: 0 }]\r\n      ])\r\n    };\r\n\r\n    this.indexedDB = null;\r\n    this.dbReady = this.initIndexedDB(options.indexedDBName || 'LocalRetrieveCache', options.dbVersion || 1);\r\n  }\r\n\r\n  /**\r\n   * Получение данных с каскадным поиском по уровням кэша\r\n   */\r\n  async get<T = any>(key: string, level?: CacheLevel): Promise<T | null> {\r\n    const startTime = Date.now();\r\n    this.stats.totalRequests++;\r\n\r\n    try {\r\n      // Если указан конкретный уровень, ищем только в нем\r\n      if (level) {\r\n        const result = await this.getFromLevel<T>(key, level);\r\n        this.updateAccessTimeStats(level, Date.now() - startTime);\r\n        return result;\r\n      }\r\n\r\n      // Поиск по всем уровням в порядке приоритета\r\n\r\n      // Уровень 1: Memory Cache\r\n      const memoryResult = await this.getFromLevel<T>(key, 'memory');\r\n      if (memoryResult !== null) {\r\n        this.stats.memoryHits++;\r\n        this.updateAccessTimeStats('memory', Date.now() - startTime);\r\n        return memoryResult;\r\n      }\r\n\r\n      // Уровень 2: IndexedDB\r\n      const indexedDBResult = await this.getFromLevel<T>(key, 'indexeddb');\r\n      if (indexedDBResult !== null) {\r\n        this.stats.indexedDBHits++;\r\n        this.updateAccessTimeStats('indexeddb', Date.now() - startTime);\r\n\r\n        // Восстанавливаем в memory cache для быстрого доступа\r\n        await this.queryCache.set(key, indexedDBResult);\r\n\r\n        return indexedDBResult;\r\n      }\r\n\r\n      // Уровень 3: Database (через SQLite)\r\n      const databaseResult = await this.getFromLevel<T>(key, 'database');\r\n      if (databaseResult !== null) {\r\n        this.stats.databaseHits++;\r\n        this.updateAccessTimeStats('database', Date.now() - startTime);\r\n\r\n        // Восстанавливаем в вышестоящие кэши\r\n        await Promise.all([\r\n          this.queryCache.set(key, databaseResult),\r\n          this.setInIndexedDB(key, databaseResult, { ttl: 24 * 60 * 60 * 1000 }) // 24 часа\r\n        ]);\r\n\r\n        return databaseResult;\r\n      }\r\n\r\n      // Ничего не найдено\r\n      this.stats.misses++;\r\n      return null;\r\n\r\n    } catch (error) {\r\n      console.warn(`Cache get operation failed for key \"${key}\":`, error);\r\n      this.stats.misses++;\r\n      return null;\r\n    } finally {\r\n      this.stats.totalAccessTime += Date.now() - startTime;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Сохранение данных во всех уровнях кэша\r\n   */\r\n  async set<T = any>(key: string, value: T, options?: CacheOptions): Promise<void> {\r\n    const {\r\n      level,\r\n      ttl,\r\n      tags = [],\r\n      priority = 'normal',\r\n      compression = false\r\n    } = options || {};\r\n\r\n    try {\r\n      const promises: Promise<void>[] = [];\r\n\r\n      if (!level || level === 'memory') {\r\n        // Сохранение в memory cache\r\n        promises.push(this.queryCache.set(key, value, {\r\n          ttl: ttl || 5 * 60 * 1000, // 5 минут по умолчанию\r\n          priority,\r\n          tags\r\n        }));\r\n      }\r\n\r\n      if (!level || level === 'indexeddb') {\r\n        // Сохранение в IndexedDB\r\n        promises.push(this.setInIndexedDB(key, value, {\r\n          ttl: ttl || 24 * 60 * 60 * 1000, // 24 часа по умолчанию\r\n          tags,\r\n          compression\r\n        }));\r\n      }\r\n\r\n      if (!level || level === 'database') {\r\n        // Сохранение в SQLite database (заглушка - будет реализовано в worker integration)\r\n        promises.push(this.setInDatabase(key, value, {\r\n          ttl: ttl || 7 * 24 * 60 * 60 * 1000, // 7 дней по умолчанию\r\n          tags\r\n        }));\r\n      }\r\n\r\n      await Promise.all(promises);\r\n\r\n    } catch (error) {\r\n      throw new CacheError(\r\n        `Failed to set cache value for key \"${key}\": ${error instanceof Error ? error.message : String(error)}`,\r\n        'SET_FAILED',\r\n        key,\r\n        { level, options }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Каскадное удаление данных по паттерну\r\n   */\r\n  async invalidate(pattern: string): Promise<void> {\r\n    const promises: Promise<void>[] = [];\r\n\r\n    try {\r\n      // Очистка во всех кэшах\r\n      promises.push(this.queryCache.invalidate(pattern));\r\n      promises.push(this.modelCache.invalidate(pattern));\r\n      promises.push(this.invalidateIndexedDB(pattern));\r\n      promises.push(this.invalidateDatabase(pattern));\r\n\r\n      await Promise.all(promises);\r\n\r\n    } catch (error) {\r\n      throw new CacheError(\r\n        `Failed to invalidate cache pattern \"${pattern}\": ${error instanceof Error ? error.message : String(error)}`,\r\n        'INVALIDATION_FAILED',\r\n        pattern\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Предварительный прогрев кэша для популярных запросов\r\n   */\r\n  async warmCache(collection: string, queries: string[]): Promise<void> {\r\n    // Заглушка - в реальной реализации здесь будет взаимодействие с InternalPipeline\r\n    console.log(`Warming cache for collection \"${collection}\" with ${queries.length} queries`);\r\n\r\n    // Пока что просто сохраняем пустые плейсхолдеры\r\n    const warmupPromises = queries.map(async (query, index) => {\r\n      const cacheKey = `warmup:${collection}:${this.hashString(query)}`;\r\n      const placeholder = {\r\n        warmedAt: Date.now(),\r\n        collection,\r\n        query,\r\n        status: 'placeholder'\r\n      };\r\n\r\n      await this.set(cacheKey, placeholder, {\r\n        level: 'memory',\r\n        ttl: 10 * 60 * 1000, // 10 минут для прогрева\r\n        tags: ['warmup', collection]\r\n      });\r\n    });\r\n\r\n    await Promise.all(warmupPromises);\r\n  }\r\n\r\n  /**\r\n   * Предзагрузка моделей в кэш\r\n   */\r\n  async preloadModels(providers: string[]): Promise<void> {\r\n    // Используем ModelCache для предзагрузки\r\n    const preloadPromises = providers.map(async (provider) => {\r\n      const modelInfo: import('./ModelCache.js').CachedModelInfo = {\r\n        modelId: `${provider}-default`,\r\n        provider: provider as any, // Type assertion for provider\r\n        modelName: `${provider} Default Model`,\r\n        dimensions: 384, // Default dimensions\r\n        loadTime: 0,\r\n        cachedAt: Date.now(),\r\n        lastUsed: Date.now(),\r\n        usageCount: 0,\r\n        memoryUsage: 0,\r\n        status: 'ready',\r\n        performance: {\r\n          averageInferenceTime: 0,\r\n          successRate: 1.0,\r\n          errorCount: 0,\r\n          lastBenchmark: Date.now()\r\n        },\r\n        tags: ['default', 'preloaded']\r\n      };\r\n\r\n      await this.modelCache.set(`model:${provider}`, modelInfo);\r\n    });\r\n\r\n    await Promise.all(preloadPromises);\r\n    console.log(`Preloaded ${providers.length} models into cache`);\r\n  }\r\n\r\n  /**\r\n   * Получение статистики кэширования\r\n   */\r\n  getStats(): CacheStatistics {\r\n    const totalHits = this.stats.memoryHits + this.stats.indexedDBHits + this.stats.databaseHits;\r\n    const hitRate = this.stats.totalRequests > 0\r\n      ? (totalHits / this.stats.totalRequests) * 100\r\n      : 0;\r\n\r\n    // Вычисляем средние времена доступа\r\n    const avgAccessTime: CacheStatistics['avgAccessTime'] = {\r\n      memory: 0,\r\n      indexeddb: 0,\r\n      database: 0\r\n    };\r\n\r\n    for (const [level, stats] of this.stats.levelAccessTimes.entries()) {\r\n      avgAccessTime[level] = stats.count > 0 ? stats.total / stats.count : 0;\r\n    }\r\n\r\n    return {\r\n      totalRequests: this.stats.totalRequests,\r\n      hits: {\r\n        memory: this.stats.memoryHits,\r\n        indexeddb: this.stats.indexedDBHits,\r\n        database: this.stats.databaseHits,\r\n        total: totalHits\r\n      },\r\n      misses: this.stats.misses,\r\n      hitRate,\r\n      memoryUsage: {\r\n        memory: this.queryCache.getMemoryUsage(),\r\n        indexeddb: this.estimateIndexedDBUsage(),\r\n        database: this.estimateDatabaseUsage()\r\n      },\r\n      avgAccessTime\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Очистка всех уровней кэша\r\n   */\r\n  async clear(): Promise<void> {\r\n    const promises: Promise<void>[] = [\r\n      this.queryCache.clear(),\r\n      this.modelCache.clear(),\r\n      this.clearIndexedDB(),\r\n      this.clearDatabase()\r\n    ];\r\n\r\n    await Promise.all(promises);\r\n\r\n    // Сбрасываем статистику\r\n    this.stats = {\r\n      totalRequests: 0,\r\n      memoryHits: 0,\r\n      indexedDBHits: 0,\r\n      databaseHits: 0,\r\n      misses: 0,\r\n      totalAccessTime: 0,\r\n      levelAccessTimes: new Map([\r\n        ['memory', { total: 0, count: 0 }],\r\n        ['indexeddb', { total: 0, count: 0 }],\r\n        ['database', { total: 0, count: 0 }]\r\n      ])\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Оптимизация кэша\r\n   */\r\n  async optimize(): Promise<void> {\r\n    const promises: Promise<void>[] = [\r\n      this.queryCache.optimize(),\r\n      this.modelCache.optimize(),\r\n      this.optimizeIndexedDB(),\r\n      this.optimizeDatabase()\r\n    ];\r\n\r\n    await Promise.all(promises);\r\n    console.log('Cache optimization completed');\r\n  }\r\n\r\n  // === Приватные методы ===\r\n\r\n  /**\r\n   * Получение данных с конкретного уровня\r\n   */\r\n  private async getFromLevel<T>(key: string, level: CacheLevel): Promise<T | null> {\r\n    switch (level) {\r\n      case 'memory':\r\n        return this.queryCache.get(key);\r\n\r\n      case 'indexeddb':\r\n        return this.getFromIndexedDB<T>(key);\r\n\r\n      case 'database':\r\n        return this.getFromDatabase<T>(key);\r\n\r\n      default:\r\n        throw new CacheError(`Unknown cache level: ${level}`, 'read', `unknown:${level}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Инициализация IndexedDB\r\n   */\r\n  private async initIndexedDB(dbName: string, version: number): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (typeof indexedDB === 'undefined') {\r\n        console.warn('IndexedDB not available, skipping initialization');\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      const request = indexedDB.open(dbName, version);\r\n\r\n      request.onerror = () => {\r\n        console.warn('Failed to open IndexedDB:', request.error);\r\n        resolve(); // Продолжаем работу без IndexedDB\r\n      };\r\n\r\n      request.onsuccess = () => {\r\n        this.indexedDB = request.result;\r\n        resolve();\r\n      };\r\n\r\n      request.onupgradeneeded = () => {\r\n        const db = request.result;\r\n\r\n        // Создаем object store для кэша\r\n        if (!db.objectStoreNames.contains('cache')) {\r\n          const store = db.createObjectStore('cache', { keyPath: 'key' });\r\n          store.createIndex('timestamp', 'timestamp');\r\n          store.createIndex('tags', 'tags', { multiEntry: true });\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Получение данных из IndexedDB\r\n   */\r\n  private async getFromIndexedDB<T>(key: string): Promise<T | null> {\r\n    await this.dbReady;\r\n\r\n    if (!this.indexedDB) return null;\r\n\r\n    return new Promise((resolve) => {\r\n      const transaction = this.indexedDB!.transaction(['cache'], 'readonly');\r\n      const store = transaction.objectStore('cache');\r\n      const request = store.get(key);\r\n\r\n      request.onsuccess = () => {\r\n        const result = request.result;\r\n\r\n        if (!result) {\r\n          resolve(null);\r\n          return;\r\n        }\r\n\r\n        // Проверяем TTL\r\n        if (result.expiresAt && Date.now() > result.expiresAt) {\r\n          // Асинхронно удаляем устаревшую запись\r\n          this.deleteFromIndexedDB(key).catch(console.warn);\r\n          resolve(null);\r\n          return;\r\n        }\r\n\r\n        resolve(result.value);\r\n      };\r\n\r\n      request.onerror = () => {\r\n        console.warn(`IndexedDB get failed for key \"${key}\":`, request.error);\r\n        resolve(null);\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Сохранение данных в IndexedDB\r\n   */\r\n  private async setInIndexedDB<T>(key: string, value: T, options: { ttl?: number; tags?: string[]; compression?: boolean } = {}): Promise<void> {\r\n    await this.dbReady;\r\n\r\n    if (!this.indexedDB) return;\r\n\r\n    const { ttl, tags = [], compression = false } = options;\r\n\r\n    const cacheEntry = {\r\n      key,\r\n      value: compression ? this.compress(value) : value,\r\n      timestamp: Date.now(),\r\n      expiresAt: ttl ? Date.now() + ttl : null,\r\n      tags,\r\n      compressed: compression\r\n    };\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.indexedDB!.transaction(['cache'], 'readwrite');\r\n      const store = transaction.objectStore('cache');\r\n      const request = store.put(cacheEntry);\r\n\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => {\r\n        console.warn(`IndexedDB set failed for key \"${key}\":`, request.error);\r\n        reject(request.error);\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Удаление данных из IndexedDB\r\n   */\r\n  private async deleteFromIndexedDB(key: string): Promise<void> {\r\n    if (!this.indexedDB) return;\r\n\r\n    return new Promise((resolve) => {\r\n      const transaction = this.indexedDB!.transaction(['cache'], 'readwrite');\r\n      const store = transaction.objectStore('cache');\r\n      const request = store.delete(key);\r\n\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => {\r\n        console.warn(`IndexedDB delete failed for key \"${key}\":`, request.error);\r\n        resolve(); // Не прерываем работу при ошибке удаления\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Очистка данных в IndexedDB по паттерну\r\n   */\r\n  private async invalidateIndexedDB(pattern: string): Promise<void> {\r\n    if (!this.indexedDB) return;\r\n\r\n    // Упрощенная реализация - очищаем все если pattern === '*'\r\n    if (pattern === '*') {\r\n      await this.clearIndexedDB();\r\n      return;\r\n    }\r\n\r\n    // Для более сложных паттернов нужна полная реализация\r\n    console.warn('IndexedDB pattern invalidation not fully implemented');\r\n  }\r\n\r\n  /**\r\n   * Полная очистка IndexedDB\r\n   */\r\n  private async clearIndexedDB(): Promise<void> {\r\n    if (!this.indexedDB) return;\r\n\r\n    return new Promise((resolve) => {\r\n      const transaction = this.indexedDB!.transaction(['cache'], 'readwrite');\r\n      const store = transaction.objectStore('cache');\r\n      const request = store.clear();\r\n\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => {\r\n        console.warn('IndexedDB clear failed:', request.error);\r\n        resolve();\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Оптимизация IndexedDB (удаление устаревших записей)\r\n   */\r\n  private async optimizeIndexedDB(): Promise<void> {\r\n    if (!this.indexedDB) return;\r\n\r\n    const now = Date.now();\r\n\r\n    return new Promise((resolve) => {\r\n      const transaction = this.indexedDB!.transaction(['cache'], 'readwrite');\r\n      const store = transaction.objectStore('cache');\r\n      const request = store.openCursor();\r\n\r\n      request.onsuccess = () => {\r\n        const cursor = request.result;\r\n\r\n        if (cursor) {\r\n          const record = cursor.value;\r\n\r\n          // Удаляем устаревшие записи\r\n          if (record.expiresAt && now > record.expiresAt) {\r\n            cursor.delete();\r\n          }\r\n\r\n          cursor.continue();\r\n        } else {\r\n          resolve();\r\n        }\r\n      };\r\n\r\n      request.onerror = () => {\r\n        console.warn('IndexedDB optimization failed:', request.error);\r\n        resolve();\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Заглушки для database operations (будут реализованы при интеграции с worker)\r\n   */\r\n  private async getFromDatabase<T>(key: string): Promise<T | null> {\r\n    // Заглушка - будет реализовано при интеграции с worker\r\n    console.debug(`Database get for key \"${key}\" - not implemented yet`);\r\n    return null;\r\n  }\r\n\r\n  private async setInDatabase<T>(key: string, value: T, options: { ttl?: number; tags?: string[] }): Promise<void> {\r\n    // Заглушка - будет реализовано при интеграции с worker\r\n    console.debug(`Database set for key \"${key}\" - not implemented yet`);\r\n  }\r\n\r\n  private async invalidateDatabase(pattern: string): Promise<void> {\r\n    // Заглушка - будет реализовано при интеграции с worker\r\n    console.debug(`Database invalidation for pattern \"${pattern}\" - not implemented yet`);\r\n  }\r\n\r\n  private async clearDatabase(): Promise<void> {\r\n    // Заглушка - будет реализовано при интеграции с worker\r\n    console.debug('Database clear - not implemented yet');\r\n  }\r\n\r\n  private async optimizeDatabase(): Promise<void> {\r\n    // Заглушка - будет реализовано при интеграции с worker\r\n    console.debug('Database optimization - not implemented yet');\r\n  }\r\n\r\n  /**\r\n   * Вспомогательные методы\r\n   */\r\n  private updateAccessTimeStats(level: CacheLevel, time: number): void {\r\n    const stats = this.stats.levelAccessTimes.get(level)!;\r\n    stats.total += time;\r\n    stats.count++;\r\n  }\r\n\r\n  private estimateIndexedDBUsage(): number {\r\n    // Приблизительная оценка использования IndexedDB в MB\r\n    return 10; // Заглушка\r\n  }\r\n\r\n  private estimateDatabaseUsage(): number {\r\n    // Приблизительная оценка использования SQLite database в MB\r\n    return 50; // Заглушка\r\n  }\r\n\r\n  private hashString(str: string): string {\r\n    // Простая hash функция\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    return Math.abs(hash).toString(36);\r\n  }\r\n\r\n  private compress<T>(data: T): string {\r\n    // Простая реализация сжатия через JSON\r\n    return JSON.stringify(data);\r\n  }\r\n\r\n  private decompress<T>(compressed: string): T {\r\n    return JSON.parse(compressed);\r\n  }\r\n}\r\n\r\n/**\r\n * Фабричная функция для создания CacheManager\r\n */\r\nexport function createCacheManager(options: {\r\n  memorySize?: number;\r\n  indexedDBName?: string;\r\n  dbVersion?: number;\r\n} = {}): CacheManager {\r\n  return new CacheManagerImpl(options);\r\n}"],"names":["message","code","details","DatabaseError","WorkerError","sqliteCode","VectorError","OPFSError","DEFAULT_CONFIG","WorkerRPC","worker","config","event","response","level","error","pending","duration","method","params","resolve","reject","id","startTime","timeout","args","levels","configLevel","result","name","collection","options","avgLatency","WorkerRPCHandler","handler","postError","errorResponse","finalError","createWorkerRPC","workerUrl","EmbeddingError","category","context","recoveryInfo","ProviderError","providerName","modelVersion","ProviderInitializationError","cause","ModelLoadError","modelName","modelSize","NetworkError","networkType","statusCode","url","retryAfter","AuthenticationError","authType","ConfigurationError","parameterName","expectedValue","actualValue","ValidationError","fieldName","validationRule","QuotaExceededError","quotaType","currentValue","maxValue","resetTime","actions","TimeoutError","timeoutMs","operation","CacheError","cacheOperation","cacheKey","workerOperation","workerId","BaseEmbeddingProvider","dimensions","maxBatchSize","maxTextLength","errors","warnings","suggestions","text","estimatedTokens","texts","index","generationTime","embeddingCount","isError","totalTime","ProviderUtils","embedding","norm","i","normalized","a","b","dotProduct","normA","normB","normalize","ExternalProvider","validation","health","lastError","maxRetries","attempt","delay","embeddings","isHealthy","requestsPerMinute","waitTime","baseDelay","exponentialDelay","jitter","requestCount","success","ms","OPENAI_MODELS","OpenAIProvider","model","modelInfo","requestBody","headers","controller","timeoutId","responseData","info","status","errorData","errorMessage","errorType","errorCode","item","baseValidation","createOpenAIProvider","isValidModelDimensionCombo","getRecommendedConfig","requirements","budget","performance","TransformersProvider","results","chunkSize","chunk","chunkResults","t","embData","request","responseTime","type","data","timeoutHandle","createTransformersProvider","isTransformersSupported","getModelInfo","EmbeddingUtils","algorithm","includeTimestamp","salt","includeDebugInfo","hashInput","sortedInput","inputString","processingConfig","input","hashBuffer","hash","obj","sortedKeys","sortedObj","key","firstKey","expectedDimensions","actualDimensions","isValid","supportedDimensions","array","copy","base","override","overrideValue","bytes","k","sizes","milliseconds","seconds","minutes","timer","endTime","prefix","timestamp","random","jsonString","defaultValue","value","func","limit","inThrottle","EmbeddingConstants","CollectionUtils","collectionId","provider","EmbeddingProviderFactoryImpl","supportInfo","models","getTransformersModelInfo","providerType","recommendations","privacy","openaiConfig","providerFactory","createEmbeddingProvider","validateProviderConfig","checkProviderSupport","getProviderRecommendations","getAvailableProviders","getAvailableModels","InternalPipelineImpl","cacheManager","modelManager","query","cached","embeddingPromise","timeoutPromise","_","processingTime","requests","batchSize","concurrency","batches","completedCount","total","processBatch","batch","batchResults","embeddingResult","batchPromises","memoryResult","indexedDBResult","databaseResult","commonQueries","completed","pattern","cacheHitRate","averageGenerationTime","configHash","queryHash","source","current","memoryUsage","createInternalPipeline","ModelManagerImpl","modelId","cachedModel","strategy","loadPromises","maxMemoryUsage","maxModels","idleTimeout","aggressive","currentMemory","currentModelCount","modelsToUnload","scoreA","scoreB","freedMemory","unloadedCount","loadedModels","totalMemoryUsage","activeCount","m","providerStats","stats","cutoffTime","unloadPromises","loadingModel","providerInstance","loadTime","interval","createModelManager","QueryCache","entry","ttl","priority","tags","now","size","deleted","totalHits","totalMisses","keysToDelete","tag","regex","totalRequests","hitRate","averageEntrySize","sum","totalSize","requiredSize","requiredSpace","targetMemory","targetSize","keysToEvict","entries","sortedEntries","remainingMemory","remainingCount","priorityOrder","priorityDiff","priorityScore","frequencyScore","recencyScore","ModelCache","perf","totalInferences","newSuccessful","deletePromises","requiredMemory","ageScore","usageScore","memoryScore","performanceScore","totalMemory","CacheManagerImpl","compression","promises","queries","warmupPromises","placeholder","providers","preloadPromises","avgAccessTime","dbName","version","db","store","cacheEntry","cursor","record","time","str","char","compressed","createCacheManager"],"mappings":"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"}