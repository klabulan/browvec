{"version":3,"file":"worker.js","sources":["../../src/database/worker/core/SQLite3Module.ts","../../src/database/worker/core/SQLiteManager.ts","../../src/database/worker/core/OPFSManager.ts","../../src/database/worker/schema/SchemaManager.ts","../../src/database/worker/embedding/EmbeddingQueue.ts","../../src/database/worker/embedding/ProviderManager.ts","../../src/database/worker/utils/ErrorHandling.ts","../../src/database/worker/utils/TypeGuards.ts","../../src/database/worker/handlers/BaseHandler.ts","../../src/database/worker/handlers/SearchHandler.ts","../../src/llm/errors.ts","../../src/llm/PromptTemplates.ts","../../src/llm/providers/BaseLLMProvider.ts","../../src/llm/providers/OpenAIProvider.ts","../../src/llm/providers/AnthropicProvider.ts","../../src/llm/providers/OpenRouterProvider.ts","../../src/llm/providers/CustomProvider.ts","../../src/database/worker/llm/LLMManager.ts","../../src/database/worker/utils/Logger.ts","../../src/database/worker/core/DatabaseWorker.ts","../../src/database/worker/index.ts"],"sourcesContent":["/**\r\n * SQLite3Module Interface\r\n *\r\n * Type definitions for the SQLite WASM C API module.\r\n * This interface defines all the low-level SQLite functions and utilities\r\n * available through the WASM module.\r\n */\r\n\r\n/**\r\n * SQLite WASM module interface (C API)\r\n *\r\n * This interface provides access to the raw SQLite C API through WASM.\r\n * All functions are direct mappings to the SQLite C API with WASM-specific\r\n * memory management patterns.\r\n */\r\nexport interface SQLite3Module {\r\n  // Memory management\r\n  _malloc(size: number): number;\r\n  _free(ptr: number): void;\r\n\r\n  // String utilities\r\n  stringToUTF8(str: string, outPtr: number, maxBytesToWrite: number): void;\r\n  UTF8ToString(ptr: number): string;\r\n\r\n  // Value getters/setters\r\n  getValue(ptr: number, type: string): number;\r\n  setValue(ptr: number, value: number, type: string): void;\r\n\r\n  // Bulk memory operations\r\n  writeArrayToMemory?(data: Uint8Array, ptr: number): void;\r\n\r\n  // SQLite C API functions\r\n  _sqlite3_open(filename: number, ppDb: number): number;\r\n  _sqlite3_close(db: number): number;\r\n  _sqlite3_exec(db: number, sql: number, callback: number, arg: number, errmsg: number): number;\r\n  _sqlite3_prepare_v2(db: number, sql: number, nByte: number, ppStmt: number, pzTail: number): number;\r\n  _sqlite3_step(stmt: number): number;\r\n  _sqlite3_finalize(stmt: number): number;\r\n  _sqlite3_column_count(stmt: number): number;\r\n  _sqlite3_column_name(stmt: number, iCol: number): number;\r\n  _sqlite3_column_type(stmt: number, iCol: number): number;\r\n  _sqlite3_column_int(stmt: number, iCol: number): number;\r\n  _sqlite3_column_double(stmt: number, iCol: number): number;\r\n  _sqlite3_column_text(stmt: number, iCol: number): number;\r\n  _sqlite3_column_blob(stmt: number, iCol: number): number;\r\n  _sqlite3_column_bytes(stmt: number, iCol: number): number;\r\n  _sqlite3_bind_int(stmt: number, index: number, value: number): number;\r\n  _sqlite3_bind_double(stmt: number, index: number, value: number): number;\r\n  _sqlite3_bind_text(stmt: number, index: number, value: number, length: number, destructor: number): number;\r\n  _sqlite3_bind_blob(stmt: number, index: number, value: number, length: number, destructor: number): number;\r\n  _sqlite3_bind_null(stmt: number, index: number): number;\r\n  _sqlite3_errmsg(db: number): number;\r\n  _sqlite3_libversion(): number;\r\n\r\n  // sqlite-vec extension functions\r\n  _sqlite3_vec_init_manual(db: number): number;\r\n\r\n  // Serialize/deserialize functions\r\n  _sqlite3_serialize(db: number, schema: number, size: number, flags: number): number;\r\n  _sqlite3_deserialize(db: number, schema: number, data: number, szDb: bigint, szBuf: bigint, flags: number): number;\r\n\r\n  // Version info\r\n  version?: string;\r\n}\r\n\r\n// SQLite result codes\r\nexport const SQLITE_OK = 0;\r\nexport const SQLITE_ROW = 100;\r\nexport const SQLITE_DONE = 101;\r\n\r\n// SQLite column types\r\nexport const SQLITE_INTEGER = 1;\r\nexport const SQLITE_FLOAT = 2;\r\nexport const SQLITE_TEXT = 3;\r\nexport const SQLITE_BLOB = 4;\r\nexport const SQLITE_NULL = 5;\r\n\r\n// SQLite bind destructor constants\r\nexport const SQLITE_STATIC = 0;\r\nexport const SQLITE_TRANSIENT = -1;","/**\r\n * SQLiteManager\r\n *\r\n * Handles direct SQLite WASM operations, including database connection management,\r\n * SQL execution, and low-level WASM interactions.\r\n */\r\n\r\nimport type { SQLite3Module } from './SQLite3Module.js';\r\nimport {\r\n  SQLITE_OK,\r\n  SQLITE_ROW,\r\n  SQLITE_DONE,\r\n  SQLITE_INTEGER,\r\n  SQLITE_FLOAT,\r\n  SQLITE_TEXT,\r\n  SQLITE_BLOB,\r\n  SQLITE_NULL,\r\n  SQLITE_TRANSIENT\r\n} from './SQLite3Module.js';\r\nimport type { SQLValue, ExtendedSQLValue, SQLParams, ExtendedSQLParams, QueryResult } from '../../../types/worker.js';\r\nimport { DatabaseError, VectorError } from '../../../types/worker.js';\r\n\r\n/**\r\n * SQLiteManager handles all direct SQLite WASM operations\r\n *\r\n * Responsibilities:\r\n * - WASM module loading and initialization\r\n * - Database connection management\r\n * - SQL statement preparation and execution\r\n * - Parameter binding and result extraction\r\n * - Memory management for WASM operations\r\n * - sqlite-vec extension initialization\r\n * - Database serialization/deserialization\r\n */\r\nexport class SQLiteManager {\r\n  private sqlite3: SQLite3Module | null = null;\r\n  private dbPtr: number = 0;\r\n  private operationCount = 0;\r\n\r\n  constructor(private logger?: { log: (level: string, message: string) => void }) {}\r\n\r\n  /**\r\n   * Load SQLite WASM module\r\n   */\r\n  async loadWASM(): Promise<void> {\r\n    if (this.sqlite3) {\r\n      return; // Already loaded\r\n    }\r\n\r\n    try {\r\n      const sqlite3ModulePath = `${self.location.origin}/sqlite3.mjs`;\r\n      this.log('info', `Loading SQLite WASM from: ${sqlite3ModulePath}`);\r\n\r\n      const sqlite3Module = await import(sqlite3ModulePath);\r\n      this.sqlite3 = await sqlite3Module.default();\r\n\r\n      // Verify essential functions are available\r\n      if (!this.sqlite3?._sqlite3_open || !this.sqlite3?._sqlite3_close) {\r\n        throw new DatabaseError('SQLite WASM module is incomplete - missing core functions');\r\n      }\r\n\r\n      const versionPtr = this.sqlite3?._sqlite3_libversion();\r\n      const version = versionPtr && this.sqlite3?.UTF8ToString ? this.sqlite3.UTF8ToString(versionPtr) : 'unknown';\r\n      this.log('info', `SQLite WASM loaded successfully, version: ${version}`);\r\n\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      this.log('error', `Failed to load SQLite WASM: ${message}`);\r\n      throw new DatabaseError(`Failed to load SQLite WASM: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Open database connection\r\n   */\r\n  async openDatabase(dbPath: string): Promise<void> {\r\n    if (!this.sqlite3) {\r\n      await this.loadWASM();\r\n    }\r\n\r\n    if (this.dbPtr) {\r\n      this.closeDatabase();\r\n    }\r\n\r\n    const filenamePtr = this.sqlite3!._malloc(dbPath.length + 1);\r\n    this.sqlite3!.stringToUTF8(dbPath, filenamePtr, dbPath.length + 1);\r\n\r\n    const dbPtrPtr = this.sqlite3!._malloc(4); // Pointer to pointer\r\n    const result = this.sqlite3!._sqlite3_open(filenamePtr, dbPtrPtr);\r\n\r\n    this.sqlite3!._free(filenamePtr);\r\n\r\n    if (result !== SQLITE_OK) {\r\n      this.sqlite3!._free(dbPtrPtr);\r\n      const errorPtr = (this.sqlite3!._sqlite3_errmsg && this.sqlite3!._sqlite3_errmsg(0)) || 0;\r\n      const errorMsg = errorPtr ? this.sqlite3!.UTF8ToString(errorPtr) : `SQLite error code ${result}`;\r\n      throw new DatabaseError(`Failed to open database: ${errorMsg}`);\r\n    }\r\n\r\n    // Get the database pointer\r\n    this.dbPtr = this.sqlite3!.getValue(dbPtrPtr, 'i32');\r\n    this.sqlite3!._free(dbPtrPtr);\r\n\r\n    if (!this.dbPtr) {\r\n      throw new DatabaseError('Failed to get valid database pointer');\r\n    }\r\n\r\n    this.log('info', `Database opened successfully: ${dbPath}`);\r\n  }\r\n\r\n  /**\r\n   * Close database connection\r\n   */\r\n  closeDatabase(): void {\r\n    if (!this.sqlite3 || !this.dbPtr) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.sqlite3._sqlite3_close(this.dbPtr);\r\n      this.dbPtr = 0;\r\n      this.log('info', 'Database closed successfully');\r\n    } catch (error) {\r\n      this.log('error', `Error closing database: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize sqlite-vec extension\r\n   */\r\n  async initVecExtension(): Promise<void> {\r\n    if (!this.sqlite3 || !this.dbPtr) {\r\n      throw new DatabaseError('Database not initialized');\r\n    }\r\n\r\n    if (!this.sqlite3._sqlite3_vec_init_manual) {\r\n      throw new VectorError('sqlite-vec extension not available');\r\n    }\r\n\r\n    const result = this.sqlite3._sqlite3_vec_init_manual(this.dbPtr);\r\n    if (result !== SQLITE_OK) {\r\n      this.log('error', `sqlite-vec initialization failed with code: ${result}`);\r\n      throw new VectorError(`Failed to initialize sqlite-vec extension (code: ${result})`);\r\n    }\r\n\r\n    this.log('info', 'sqlite-vec extension initialized successfully');\r\n\r\n    // Test the extension with a simple query (using JSON string syntax)\r\n    try {\r\n      const testResults = await this.select(\"SELECT vec_f32('[1.0, 2.0, 3.0]') as test_vector\");\r\n      this.log('info', `vec_f32 function test result: ${JSON.stringify(testResults.rows[0])}`);\r\n    } catch (error) {\r\n      this.log('warn', `vec_f32 test failed: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute SQL statement with optional parameters\r\n   */\r\n  async exec(sql: string, params?: ExtendedSQLParams): Promise<void> {\r\n    if (!this.sqlite3 || !this.dbPtr) {\r\n      throw new DatabaseError('Database not initialized');\r\n    }\r\n\r\n    this.operationCount++;\r\n\r\n    // If no parameters, use simple exec\r\n    if (!params || params.length === 0) {\r\n      const sqlPtr = this.sqlite3._malloc(sql.length + 1);\r\n      this.sqlite3.stringToUTF8(sql, sqlPtr, sql.length + 1);\r\n\r\n      const result = this.sqlite3._sqlite3_exec(this.dbPtr, sqlPtr, 0, 0, 0);\r\n      this.sqlite3._free(sqlPtr);\r\n\r\n      if (result !== SQLITE_OK) {\r\n        const errorPtr = this.sqlite3._sqlite3_errmsg(this.dbPtr);\r\n        const errorMsg = this.sqlite3.UTF8ToString(errorPtr);\r\n        this.log('error', `SQL execution failed: ${sql} - Error: ${errorMsg}`);\r\n        throw new DatabaseError(`SQL execution failed: ${errorMsg}`);\r\n      } else {\r\n        this.log('debug', `SQL executed successfully: ${sql}`);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Use prepared statement for parameterized queries\r\n    const sqlPtr = this.sqlite3._malloc(sql.length + 1);\r\n    this.sqlite3.stringToUTF8(sql, sqlPtr, sql.length + 1);\r\n\r\n    const stmtPtrPtr = this.sqlite3._malloc(4);\r\n    const result = this.sqlite3._sqlite3_prepare_v2(this.dbPtr, sqlPtr, -1, stmtPtrPtr, 0);\r\n\r\n    this.sqlite3._free(sqlPtr);\r\n\r\n    if (result !== SQLITE_OK) {\r\n      this.sqlite3._free(stmtPtrPtr);\r\n      const errorPtr = this.sqlite3._sqlite3_errmsg(this.dbPtr);\r\n      const errorMsg = this.sqlite3.UTF8ToString(errorPtr);\r\n      this.log('error', `SQL preparation failed: ${sql} - Error: ${errorMsg}`);\r\n      throw new DatabaseError(`Failed to prepare statement: ${errorMsg}`);\r\n    }\r\n\r\n    const stmtPtr = this.sqlite3.getValue(stmtPtrPtr, 'i32');\r\n    this.sqlite3._free(stmtPtrPtr);\r\n\r\n    try {\r\n      // Bind parameters\r\n      if (params) {\r\n        if (Array.isArray(params)) {\r\n          for (let i = 0; i < params.length; i++) {\r\n            this.bindParameter(stmtPtr, i + 1, params[i]);\r\n          }\r\n        } else {\r\n          // Handle Record<string, SQLValue>\r\n          const keys = Object.keys(params);\r\n          for (let i = 0; i < keys.length; i++) {\r\n            this.bindParameter(stmtPtr, i + 1, params[keys[i]]);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Execute the statement\r\n      const stepResult = this.sqlite3._sqlite3_step(stmtPtr);\r\n\r\n      if (stepResult !== SQLITE_DONE && stepResult !== SQLITE_ROW) {\r\n        const errorPtr = this.sqlite3._sqlite3_errmsg(this.dbPtr);\r\n        const errorMsg = this.sqlite3.UTF8ToString(errorPtr);\r\n        this.log('error', `SQL execution failed: ${sql} - Error: ${errorMsg}`);\r\n        throw new DatabaseError(`SQL execution failed: ${errorMsg}`);\r\n      }\r\n\r\n      this.log('debug', `SQL executed successfully with parameters: ${sql}`);\r\n    } finally {\r\n      this.sqlite3._sqlite3_finalize(stmtPtr);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute SQL query and return results\r\n   */\r\n  async select(sql: string, params?: ExtendedSQLParams): Promise<QueryResult> {\r\n    if (!this.sqlite3 || !this.dbPtr) {\r\n      throw new DatabaseError('Database not initialized');\r\n    }\r\n\r\n    this.operationCount++;\r\n    const rows = this.executeQuery(this.dbPtr, sql, params);\r\n\r\n    return {\r\n      rows,\r\n      columns: rows.length > 0 ? Object.keys(rows[0]) : []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Execute SQL query with parameters and return results\r\n   */\r\n  private executeQuery(dbPtr: number, sql: string, params?: ExtendedSQLParams): Record<string, any>[] {\r\n    const sqlPtr = this.sqlite3!._malloc(sql.length + 1);\r\n    this.sqlite3!.stringToUTF8(sql, sqlPtr, sql.length + 1);\r\n\r\n    const stmtPtrPtr = this.sqlite3!._malloc(4);\r\n    const result = this.sqlite3!._sqlite3_prepare_v2(dbPtr, sqlPtr, -1, stmtPtrPtr, 0);\r\n    this.sqlite3!._free(sqlPtr);\r\n\r\n    if (result !== SQLITE_OK) {\r\n      this.sqlite3!._free(stmtPtrPtr);\r\n      const errorPtr = this.sqlite3!._sqlite3_errmsg(dbPtr);\r\n      const errorMsg = this.sqlite3!.UTF8ToString(errorPtr);\r\n      throw new DatabaseError(`Failed to prepare statement: ${errorMsg}`);\r\n    }\r\n\r\n    const stmtPtr = this.sqlite3!.getValue(stmtPtrPtr, 'i32');\r\n    this.sqlite3!._free(stmtPtrPtr);\r\n\r\n    // Bind parameters if provided\r\n    if (params) {\r\n      if (Array.isArray(params) && params.length > 0) {\r\n        for (let i = 0; i < params.length; i++) {\r\n          const param = params[i];\r\n          this.bindParameter(stmtPtr, i + 1, param);\r\n        }\r\n      } else if (!Array.isArray(params)) {\r\n        // Handle Record<string, SQLValue>\r\n        const keys = Object.keys(params);\r\n        if (keys.length > 0) {\r\n          for (let i = 0; i < keys.length; i++) {\r\n            this.bindParameter(stmtPtr, i + 1, params[keys[i]]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const rows: Record<string, any>[] = [];\r\n\r\n    try {\r\n      while (this.sqlite3!._sqlite3_step(stmtPtr) === SQLITE_ROW) {\r\n        const colCount = this.sqlite3!._sqlite3_column_count(stmtPtr);\r\n        const row: Record<string, any> = {};\r\n\r\n        for (let i = 0; i < colCount; i++) {\r\n          const colName = this.sqlite3!.UTF8ToString(this.sqlite3!._sqlite3_column_name(stmtPtr, i));\r\n          const colType = this.sqlite3!._sqlite3_column_type(stmtPtr, i);\r\n          row[colName] = this.extractColumnValue(stmtPtr, i, colType);\r\n        }\r\n\r\n        rows.push(row);\r\n      }\r\n    } finally {\r\n      this.sqlite3!._sqlite3_finalize(stmtPtr);\r\n    }\r\n\r\n    return rows;\r\n  }\r\n\r\n  /**\r\n   * Bind parameter to prepared statement\r\n   */\r\n  private bindParameter(stmtPtr: number, index: number, param: ExtendedSQLValue): void {\r\n    if (!this.sqlite3) {\r\n      throw new DatabaseError('SQLite not initialized');\r\n    }\r\n\r\n    if (param === null || param === undefined) {\r\n      this.sqlite3._sqlite3_bind_null(stmtPtr, index);\r\n    } else if (typeof param === 'number') {\r\n      if (Number.isInteger(param)) {\r\n        this.sqlite3._sqlite3_bind_int(stmtPtr, index, param);\r\n      } else {\r\n        this.sqlite3._sqlite3_bind_double(stmtPtr, index, param);\r\n      }\r\n    } else if (typeof param === 'string') {\r\n      const paramPtr = this.sqlite3._malloc(param.length + 1);\r\n      this.sqlite3.stringToUTF8(param, paramPtr, param.length + 1);\r\n      this.sqlite3._sqlite3_bind_text(stmtPtr, index, paramPtr, -1, SQLITE_TRANSIENT);\r\n      this.sqlite3._free(paramPtr);\r\n    } else if (param instanceof Uint8Array) {\r\n      const paramPtr = this.sqlite3._malloc(param.length);\r\n      if (this.sqlite3.writeArrayToMemory) {\r\n        this.sqlite3.writeArrayToMemory(param, paramPtr);\r\n      } else {\r\n        // Fallback for older WASM versions\r\n        for (let j = 0; j < param.length; j++) {\r\n          this.sqlite3.setValue(paramPtr + j, param[j], 'i8');\r\n        }\r\n      }\r\n      this.sqlite3._sqlite3_bind_blob(stmtPtr, index, paramPtr, param.length, SQLITE_TRANSIENT);\r\n      this.sqlite3._free(paramPtr);\r\n    } else if (param instanceof Float32Array) {\r\n      // Special handling for Float32Array (vectors)\r\n      const byteArray = new Uint8Array(param.buffer);\r\n      this.bindParameter(stmtPtr, index, byteArray);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract column value from result set\r\n   */\r\n  private extractColumnValue(stmtPtr: number, columnIndex: number, columnType: number): any {\r\n    if (!this.sqlite3) {\r\n      throw new DatabaseError('SQLite not initialized');\r\n    }\r\n\r\n    switch (columnType) {\r\n      case SQLITE_INTEGER:\r\n        return this.sqlite3._sqlite3_column_int(stmtPtr, columnIndex);\r\n\r\n      case SQLITE_FLOAT:\r\n        return this.sqlite3._sqlite3_column_double(stmtPtr, columnIndex);\r\n\r\n      case SQLITE_TEXT:\r\n        return this.sqlite3.UTF8ToString(this.sqlite3._sqlite3_column_text(stmtPtr, columnIndex));\r\n\r\n      case SQLITE_BLOB:\r\n        const blobPtr = this.sqlite3._sqlite3_column_blob(stmtPtr, columnIndex);\r\n        const blobSize = this.sqlite3._sqlite3_column_bytes(stmtPtr, columnIndex);\r\n        const value = new Uint8Array(blobSize);\r\n        for (let j = 0; j < blobSize; j++) {\r\n          value[j] = this.sqlite3.getValue(blobPtr + j, 'i8');\r\n        }\r\n        return value;\r\n\r\n      case SQLITE_NULL:\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Serialize database to Uint8Array\r\n   */\r\n  async serialize(): Promise<Uint8Array> {\r\n    if (!this.sqlite3 || !this.dbPtr) {\r\n      throw new DatabaseError('Database not initialized');\r\n    }\r\n\r\n    const schemaName = 'main';\r\n    const sizePtr = this.sqlite3._malloc(8); // 64-bit size\r\n    const mainSchemaPtr = this.sqlite3._malloc(schemaName.length + 1);\r\n\r\n    try {\r\n      this.sqlite3.stringToUTF8(schemaName, mainSchemaPtr, schemaName.length + 1);\r\n\r\n      if (typeof this.sqlite3._sqlite3_serialize !== 'function') {\r\n        throw new DatabaseError('sqlite3_serialize function not available');\r\n      }\r\n\r\n      const dataPtr = this.sqlite3._sqlite3_serialize(this.dbPtr, mainSchemaPtr, sizePtr, 0);\r\n      if (!dataPtr) {\r\n        throw new DatabaseError('Failed to serialize database');\r\n      }\r\n\r\n      const size = this.sqlite3.getValue(sizePtr, 'i64');\r\n      const data = new Uint8Array(Number(size));\r\n\r\n      for (let i = 0; i < data.length; i++) {\r\n        data[i] = this.sqlite3.getValue(dataPtr + i, 'i8');\r\n      }\r\n\r\n      this.sqlite3._free(dataPtr);\r\n      this.log('debug', `Database serialized: ${data.length} bytes`);\r\n\r\n      return data;\r\n    } finally {\r\n      this.sqlite3._free(sizePtr);\r\n      this.sqlite3._free(mainSchemaPtr);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deserialize database from Uint8Array\r\n   */\r\n  async deserialize(data: Uint8Array): Promise<void> {\r\n    if (!this.sqlite3 || !this.dbPtr) {\r\n      throw new DatabaseError('Database not initialized');\r\n    }\r\n\r\n    const schemaName = 'main';\r\n    const schemaPtr = this.sqlite3._malloc(schemaName.length + 1);\r\n    const dataPtr = this.sqlite3._malloc(data.length);\r\n\r\n    try {\r\n      this.sqlite3.stringToUTF8(schemaName, schemaPtr, schemaName.length + 1);\r\n\r\n      // Copy data to WASM memory\r\n      if (this.sqlite3.writeArrayToMemory) {\r\n        this.sqlite3.writeArrayToMemory(data, dataPtr);\r\n      } else {\r\n        for (let i = 0; i < data.length; i++) {\r\n          this.sqlite3.setValue(dataPtr + i, data[i], 'i8');\r\n        }\r\n      }\r\n\r\n      if (typeof this.sqlite3._sqlite3_deserialize !== 'function') {\r\n        throw new DatabaseError('sqlite3_deserialize function not available');\r\n      }\r\n\r\n      const result = this.sqlite3._sqlite3_deserialize(\r\n        this.dbPtr,\r\n        schemaPtr,\r\n        dataPtr,\r\n        BigInt(data.length),\r\n        BigInt(data.length),\r\n        0\r\n      );\r\n\r\n      if (result !== SQLITE_OK) {\r\n        throw new DatabaseError(`Failed to deserialize database (SQLite error code: ${result})`);\r\n      }\r\n\r\n      this.log('debug', `Database deserialized: ${data.length} bytes`);\r\n    } finally {\r\n      this.sqlite3._free(schemaPtr);\r\n      // Note: dataPtr is managed by SQLite after deserialize\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get database connection status\r\n   */\r\n  isConnected(): boolean {\r\n    return this.sqlite3 !== null && this.dbPtr !== 0;\r\n  }\r\n\r\n  /**\r\n   * Get SQLite version\r\n   */\r\n  getVersion(): string {\r\n    if (!this.sqlite3) {\r\n      return 'Not loaded';\r\n    }\r\n\r\n    return this.sqlite3.UTF8ToString(this.sqlite3._sqlite3_libversion());\r\n  }\r\n\r\n  /**\r\n   * Get operation count\r\n   */\r\n  getOperationCount(): number {\r\n    return this.operationCount;\r\n  }\r\n\r\n  /**\r\n   * Get database pointer (for advanced operations)\r\n   */\r\n  getDbPtr(): number {\r\n    return this.dbPtr;\r\n  }\r\n\r\n  /**\r\n   * Get SQLite module reference (for advanced operations)\r\n   */\r\n  getSQLite3Module(): SQLite3Module | null {\r\n    return this.sqlite3;\r\n  }\r\n\r\n  private log(level: string, message: string): void {\r\n    if (this.logger) {\r\n      this.logger.log(level, message);\r\n    } else {\r\n      console.log(`[SQLiteManager] ${level.toUpperCase()}: ${message}`);\r\n    }\r\n  }\r\n}","/**\r\n * OPFSManager\r\n *\r\n * Handles Origin Private File System (OPFS) persistence operations.\r\n * Manages database synchronization between in-memory SQLite and OPFS storage.\r\n */\r\n\r\nimport { OPFSError } from '../../../types/worker.js';\r\nimport type { SQLiteManager } from './SQLiteManager.js';\r\n\r\n/**\r\n * Storage quota information\r\n */\r\nexport interface StorageQuota {\r\n  available: number;\r\n  used: number;\r\n  total: number;\r\n}\r\n\r\n/**\r\n * OPFSManager handles all OPFS persistence operations\r\n *\r\n * Responsibilities:\r\n * - OPFS availability checking\r\n * - Database file persistence to OPFS\r\n * - Periodic background synchronization\r\n * - Storage quota management\r\n * - Error handling and fallback strategies\r\n * - Database restoration from OPFS\r\n */\r\nexport class OPFSManager {\r\n  private opfsPath: string | null = null;\r\n  private tempDbName: string | null = null;\r\n  private lastSyncTime = 0;\r\n  private syncInterval = 5000; // Sync every 5 seconds\r\n  private syncTimer: NodeJS.Timeout | null = null;\r\n  private pendingDatabaseData: Uint8Array | null = null;\r\n\r\n  constructor(\r\n    private sqliteManager: SQLiteManager,\r\n    private logger?: { log: (level: string, message: string) => void }\r\n  ) {}\r\n\r\n  /**\r\n   * Initialize OPFS database with persistence support\r\n   * Creates a temporary file that is periodically synced to OPFS\r\n   */\r\n  async initializeDatabase(opfsPath: string): Promise<string> {\r\n    try {\r\n      // Extract the actual file path from opfs:// URL\r\n      const dbPath = opfsPath.replace(/^opfs:\\/\\/?/, '');\r\n\r\n      // Check if OPFS is supported\r\n      if (!this.isOPFSSupported()) {\r\n        this.log('warn', 'OPFS not supported, falling back to memory database');\r\n        return ':memory:';\r\n      }\r\n\r\n      // Use standard in-memory database (SQLite doesn't support custom :name: format)\r\n      // Note: Only \":memory:\" is valid, custom names like \":opfs-xxx:\" cause \"unable to open database file\"\r\n      const tempDbName = ':memory:';\r\n\r\n      // Store the OPFS path for later syncing\r\n      this.opfsPath = dbPath;\r\n      this.tempDbName = tempDbName;\r\n\r\n      // Try to load existing data from OPFS\r\n      try {\r\n        await this.loadDatabaseFromOPFS(dbPath);\r\n        this.log('info', `Loaded existing database from OPFS: ${dbPath}`);\r\n      } catch (error) {\r\n        this.log('info', `Creating new database for OPFS path: ${dbPath}`);\r\n      }\r\n\r\n      return tempDbName;\r\n    } catch (error) {\r\n      this.log('warn', `OPFS initialization failed: ${error instanceof Error ? error.message : String(error)}, using memory database`);\r\n      return ':memory:';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if OPFS is supported by the browser\r\n   */\r\n  isOPFSSupported(): boolean {\r\n    return typeof navigator !== 'undefined' &&\r\n           typeof navigator.storage !== 'undefined' &&\r\n           typeof navigator.storage.getDirectory === 'function';\r\n  }\r\n\r\n  /**\r\n   * Load database from OPFS storage\r\n   */\r\n  async loadDatabaseFromOPFS(dbPath: string): Promise<void> {\r\n    try {\r\n      if (!this.isOPFSSupported()) {\r\n        throw new Error('OPFS not supported');\r\n      }\r\n\r\n      const opfsRoot = await navigator.storage.getDirectory();\r\n      const pathParts = dbPath.split('/').filter(part => part.length > 0);\r\n\r\n      // Navigate to the file\r\n      let currentDir = opfsRoot;\r\n      for (let i = 0; i < pathParts.length - 1; i++) {\r\n        currentDir = await currentDir.getDirectoryHandle(pathParts[i], { create: false });\r\n      }\r\n\r\n      const fileName = pathParts[pathParts.length - 1];\r\n      const fileHandle = await currentDir.getFileHandle(fileName, { create: false });\r\n      const file = await fileHandle.getFile();\r\n      const data = new Uint8Array(await file.arrayBuffer());\r\n\r\n      if (data.length === 0) {\r\n        throw new Error('Empty database file');\r\n      }\r\n\r\n      // Store the data to be applied after the database is created\r\n      this.pendingDatabaseData = data;\r\n      this.log('info', `Loaded ${data.length} bytes from OPFS: ${dbPath}`);\r\n    } catch (error) {\r\n      const opfsError = new OPFSError(`Failed to load from OPFS: ${error instanceof Error ? error.message : String(error)}`);\r\n      this.handleOPFSError(opfsError, 'load');\r\n      throw opfsError;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save database to OPFS storage\r\n   */\r\n  async saveDatabaseToOPFS(): Promise<void> {\r\n    if (!this.opfsPath || !this.sqliteManager.isConnected()) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      if (!this.isOPFSSupported()) {\r\n        throw new Error('OPFS not supported');\r\n      }\r\n\r\n      // Serialize the current database\r\n      const data = await this.sqliteManager.serialize();\r\n\r\n      // Check if we have enough space\r\n      await this.ensureSufficientSpace(data.length * 2); // Conservative estimate with buffer\r\n\r\n      // Get OPFS root directory\r\n      const opfsRoot = await navigator.storage.getDirectory();\r\n      const pathParts = this.opfsPath.split('/').filter(part => part.length > 0);\r\n\r\n      // Create directories as needed\r\n      let currentDir = opfsRoot;\r\n      for (let i = 0; i < pathParts.length - 1; i++) {\r\n        currentDir = await currentDir.getDirectoryHandle(pathParts[i], { create: true });\r\n      }\r\n\r\n      // Create/update the file\r\n      const fileName = pathParts[pathParts.length - 1];\r\n      const fileHandle = await currentDir.getFileHandle(fileName, { create: true });\r\n      const writable = await fileHandle.createWritable();\r\n\r\n      // Convert Uint8Array to ArrayBuffer for OPFS write\r\n      const buffer = new ArrayBuffer(data.length);\r\n      const view = new Uint8Array(buffer);\r\n      view.set(data);\r\n      await writable.write(buffer);\r\n      await writable.close();\r\n\r\n      this.lastSyncTime = Date.now();\r\n      this.log('debug', `Saved ${data.length} bytes to OPFS: ${this.opfsPath}`);\r\n    } catch (error) {\r\n      // Handle OPFS errors gracefully - background sync failures shouldn't crash the app\r\n      this.handleOPFSError(error instanceof Error ? error : new Error(String(error)), 'save');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear OPFS database file\r\n   */\r\n  async clearDatabase(): Promise<void> {\r\n    if (!this.opfsPath) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      if (!this.isOPFSSupported()) {\r\n        this.log('warn', 'OPFS not supported, cannot clear database');\r\n        return;\r\n      }\r\n\r\n      const opfsRoot = await navigator.storage.getDirectory();\r\n      const pathParts = this.opfsPath.split('/').filter(part => part.length > 0);\r\n\r\n      // Navigate to the file\r\n      let currentDir = opfsRoot;\r\n      for (let i = 0; i < pathParts.length - 1; i++) {\r\n        try {\r\n          currentDir = await currentDir.getDirectoryHandle(pathParts[i], { create: false });\r\n        } catch {\r\n          // Directory doesn't exist, nothing to clear\r\n          this.log('debug', `Directory ${pathParts[i]} doesn't exist, nothing to clear`);\r\n          return;\r\n        }\r\n      }\r\n\r\n      const fileName = pathParts[pathParts.length - 1];\r\n      try {\r\n        await currentDir.removeEntry(fileName);\r\n        this.log('info', `Cleared OPFS database: ${this.opfsPath}`);\r\n      } catch {\r\n        // File doesn't exist, nothing to clear\r\n        this.log('debug', `File ${fileName} doesn't exist, nothing to clear`);\r\n      }\r\n    } catch (error) {\r\n      this.handleOPFSError(error instanceof Error ? error : new Error(String(error)), 'clear');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start automatic OPFS synchronization\r\n   */\r\n  startAutoSync(): void {\r\n    if (this.syncTimer) {\r\n      return; // Already started\r\n    }\r\n\r\n    this.syncTimer = setInterval(async () => {\r\n      try {\r\n        await this.saveDatabaseToOPFS();\r\n      } catch (error) {\r\n        this.log('warn', `Auto-sync failed: ${error instanceof Error ? error.message : String(error)}`);\r\n      }\r\n    }, this.syncInterval);\r\n\r\n    this.log('info', `Started OPFS auto-sync with interval: ${this.syncInterval}ms`);\r\n  }\r\n\r\n  /**\r\n   * Stop automatic OPFS synchronization\r\n   */\r\n  stopAutoSync(): void {\r\n    if (this.syncTimer) {\r\n      clearInterval(this.syncTimer);\r\n      this.syncTimer = null;\r\n      this.log('info', 'Stopped OPFS auto-sync');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Force immediate OPFS synchronization\r\n   */\r\n  async forceSync(): Promise<void> {\r\n    if (this.opfsPath && this.sqliteManager.isConnected()) {\r\n      await this.saveDatabaseToOPFS();\r\n      this.log('info', 'Force sync completed');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check OPFS storage quota\r\n   */\r\n  async checkQuota(): Promise<StorageQuota> {\r\n    try {\r\n      if (!this.isOPFSSupported() || !navigator.storage.estimate) {\r\n        return { available: -1, used: -1, total: -1 };\r\n      }\r\n\r\n      const estimate = await navigator.storage.estimate();\r\n      const quota = estimate.quota || 0;\r\n      const usage = estimate.usage || 0;\r\n      const available = quota - usage;\r\n\r\n      return {\r\n        available,\r\n        used: usage,\r\n        total: quota\r\n      };\r\n    } catch (error) {\r\n      this.log('warn', `Failed to check storage quota: ${error instanceof Error ? error.message : String(error)}`);\r\n      return { available: -1, used: -1, total: -1 };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure sufficient storage space is available\r\n   */\r\n  async ensureSufficientSpace(requiredBytes: number): Promise<void> {\r\n    const quota = await this.checkQuota();\r\n\r\n    if (quota.available === -1) {\r\n      this.log('warn', 'Cannot determine storage quota, proceeding with caution');\r\n      return;\r\n    }\r\n\r\n    if (quota.available < requiredBytes) {\r\n      const availableMB = (quota.available / (1024 * 1024)).toFixed(2);\r\n      const requiredMB = (requiredBytes / (1024 * 1024)).toFixed(2);\r\n\r\n      throw new OPFSError(\r\n        `Insufficient storage space. Available: ${availableMB}MB, Required: ${requiredMB}MB. ` +\r\n        'Please clear browser data or use database.export() to backup your data.'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pending database data for restoration\r\n   */\r\n  getPendingDatabaseData(): Uint8Array | null {\r\n    return this.pendingDatabaseData;\r\n  }\r\n\r\n  /**\r\n   * Clear pending database data after restoration\r\n   */\r\n  clearPendingDatabaseData(): void {\r\n    this.pendingDatabaseData = null;\r\n  }\r\n\r\n  /**\r\n   * Get OPFS path\r\n   */\r\n  getOPFSPath(): string | null {\r\n    return this.opfsPath;\r\n  }\r\n\r\n  /**\r\n   * Get temporary database name\r\n   */\r\n  getTempDbName(): string | null {\r\n    return this.tempDbName;\r\n  }\r\n\r\n  /**\r\n   * Get last sync time\r\n   */\r\n  getLastSyncTime(): number {\r\n    return this.lastSyncTime;\r\n  }\r\n\r\n  /**\r\n   * Handle OPFS-specific errors with appropriate logging and user guidance\r\n   */\r\n  private handleOPFSError(error: Error, operation: string): void {\r\n    this.log('error', `OPFS ${operation} failed: ${error.message}`);\r\n\r\n    if (error.message.includes('quota') || error.message.includes('storage')) {\r\n      this.log('warn', 'Storage quota exceeded. Consider clearing data or using export functionality.');\r\n    } else if (error.message.includes('permission') || error.message.includes('access')) {\r\n      this.log('warn', 'OPFS access denied. Browser may not support OPFS or permissions are restricted.');\r\n    } else if (error.message.includes('corrupt') || error.message.includes('invalid')) {\r\n      this.log('warn', 'Database file may be corrupted. Consider recreating the database.');\r\n    } else {\r\n      this.log('warn', 'Unexpected OPFS error. Data may not persist between sessions.');\r\n    }\r\n\r\n    // Suggest mitigation strategies\r\n    this.log('info', 'Mitigation strategies:');\r\n    this.log('info', '1. Use database.export() to backup your data');\r\n    this.log('info', '2. Clear browser storage to free up space');\r\n    this.log('info', '3. Use an in-memory database if persistence is not required');\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  cleanup(): void {\r\n    this.stopAutoSync();\r\n    this.opfsPath = null;\r\n    this.tempDbName = null;\r\n    this.pendingDatabaseData = null;\r\n    this.lastSyncTime = 0;\r\n  }\r\n\r\n  private log(level: string, message: string): void {\r\n    if (this.logger) {\r\n      this.logger.log(level, message);\r\n    } else {\r\n      console.log(`[OPFSManager] ${level.toUpperCase()}: ${message}`);\r\n    }\r\n  }\r\n}","/**\r\n * SchemaManager\r\n *\r\n * Handles database schema initialization, migration, and versioning.\r\n * Manages the creation of all required tables and their relationships.\r\n */\r\n\r\nimport type { SQLiteManager } from '../core/SQLiteManager.js';\r\nimport type { CollectionInfo } from '../../../types/worker.js';\r\nimport { DatabaseError } from '../../../types/worker.js';\r\n\r\n/**\r\n * Database schema version\r\n */\r\nexport const CURRENT_SCHEMA_VERSION = 3;\r\n\r\n/**\r\n * SchemaManager handles all database schema operations\r\n *\r\n * Responsibilities:\r\n * - Schema version management and migrations\r\n * - Initial database schema creation\r\n * - Collection table management\r\n * - Schema validation and consistency checks\r\n * - Migration path coordination\r\n */\r\nexport class SchemaManager {\r\n  constructor(\r\n    private sqliteManager: SQLiteManager,\r\n    private logger?: { log: (level: string, message: string, data?: any) => void }\r\n  ) {}\r\n\r\n  /**\r\n   * Initialize database schema\r\n   */\r\n  async initializeSchema(): Promise<void> {\r\n    if (!this.sqliteManager.isConnected()) {\r\n      throw new DatabaseError('Database not connected');\r\n    }\r\n\r\n    try {\r\n      // Check for existing schema version and handle migrations\r\n      let currentSchemaVersion = 0;\r\n      let hasData = false;\r\n\r\n      try {\r\n        // Check if collections table exists and get schema version\r\n        const versionResult = await this.sqliteManager.select('SELECT MAX(schema_version) as version FROM collections');\r\n        if (versionResult.rows.length > 0 && versionResult.rows[0].version !== null) {\r\n          currentSchemaVersion = versionResult.rows[0].version;\r\n          this.log('info', `Current schema version: ${currentSchemaVersion}`);\r\n        }\r\n\r\n        // Check for data in expected tables\r\n        const docCount = await this.sqliteManager.select('SELECT COUNT(*) as count FROM docs_default');\r\n        hasData = docCount.rows.length > 0 && docCount.rows[0].count > 0;\r\n\r\n        // If we have the latest schema version and data, skip initialization\r\n        if (currentSchemaVersion === CURRENT_SCHEMA_VERSION && hasData) {\r\n          this.log('info', 'Schema is up-to-date, skipping initialization');\r\n          return;\r\n        }\r\n      } catch (error) {\r\n        // Tables don't exist yet, proceed with initialization\r\n        this.log('debug', 'Schema tables do not exist yet, proceeding with initialization');\r\n      }\r\n\r\n      // Handle schema migrations if we have an older version\r\n      if (currentSchemaVersion > 0 && currentSchemaVersion < CURRENT_SCHEMA_VERSION) {\r\n        throw new DatabaseError(\r\n          `Database schema v${currentSchemaVersion} detected. Schema v3 requires database recreation. ` +\r\n          `Please export your data, clear the database (db.clearAsync()), and reimport.`\r\n        );\r\n      }\r\n\r\n      // Check if schema already exists (from restored database)\r\n      await this.validateAndCleanupSchema();\r\n\r\n      // Create the complete schema\r\n      await this.createSchema();\r\n\r\n      this.log('info', 'Schema initialized successfully');\r\n    } catch (error) {\r\n      throw new DatabaseError(`Schema initialization failed: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Migrate schema from older version to current version\r\n   */\r\n  async migrateSchema(currentVersion: number): Promise<void> {\r\n    this.log('info', `Migrating schema from version ${currentVersion} to version ${CURRENT_SCHEMA_VERSION}`);\r\n\r\n    try {\r\n\r\n      // Add future migrations here as needed\r\n\r\n      this.log('info', `Successfully migrated from schema version ${currentVersion} to ${CURRENT_SCHEMA_VERSION}`);\r\n    } catch (error) {\r\n      throw new DatabaseError(`Schema migration failed: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Migrate from schema version 1 to version 2\r\n   */\r\n  private async migrateFromV1ToV2(): Promise<void> {\r\n    // Add new columns to collections table\r\n    await this.sqliteManager.exec(`\r\n      ALTER TABLE collections ADD COLUMN embedding_provider TEXT DEFAULT 'local';\r\n      ALTER TABLE collections ADD COLUMN embedding_dimensions INTEGER DEFAULT 384;\r\n      ALTER TABLE collections ADD COLUMN embedding_status TEXT DEFAULT 'enabled' CHECK(embedding_status IN ('enabled', 'disabled', 'pending'));\r\n      ALTER TABLE collections ADD COLUMN processing_status TEXT DEFAULT 'idle' CHECK(processing_status IN ('idle', 'processing', 'error'));\r\n    `);\r\n\r\n    // Create embedding queue table\r\n    await this.sqliteManager.exec(`\r\n      CREATE TABLE IF NOT EXISTS embedding_queue (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        collection_name TEXT NOT NULL,\r\n        document_id TEXT NOT NULL,\r\n        text_content TEXT NOT NULL,\r\n        priority INTEGER DEFAULT 0,\r\n        status TEXT DEFAULT 'pending' CHECK(status IN ('pending', 'processing', 'completed', 'failed')),\r\n        retry_count INTEGER DEFAULT 0,\r\n        created_at INTEGER DEFAULT (strftime('%s', 'now')),\r\n        started_at INTEGER,\r\n        completed_at INTEGER,\r\n        processed_at INTEGER,\r\n        error_message TEXT,\r\n        FOREIGN KEY(collection_name) REFERENCES collections(name) ON DELETE CASCADE\r\n      );\r\n    `);\r\n\r\n    // Create indexes for embedding queue performance\r\n    await this.sqliteManager.exec(`\r\n      CREATE INDEX IF NOT EXISTS idx_embedding_queue_status ON embedding_queue(status);\r\n      CREATE INDEX IF NOT EXISTS idx_embedding_queue_collection ON embedding_queue(collection_name);\r\n      CREATE INDEX IF NOT EXISTS idx_embedding_queue_priority ON embedding_queue(priority DESC);\r\n      CREATE INDEX IF NOT EXISTS idx_embedding_queue_created ON embedding_queue(created_at);\r\n    `);\r\n\r\n    // Update schema version to 2\r\n    await this.sqliteManager.exec(`\r\n      UPDATE collections SET schema_version = 2, updated_at = strftime('%s', 'now')\r\n    `);\r\n  }\r\n\r\n\r\n  /**\r\n   * Validate existing schema and cleanup incomplete installations\r\n   */\r\n  private async validateAndCleanupSchema(): Promise<void> {\r\n    // Check for all required tables (both regular and virtual)\r\n    const allTables = await this.sqliteManager.select(`\r\n      SELECT name FROM sqlite_master\r\n      WHERE name IN ('docs_default', 'collections', 'fts_default', 'vec_default_dense', 'embedding_queue')\r\n      ORDER BY name\r\n    `);\r\n\r\n    this.log('info', `Raw table query results:`, allTables.rows);\r\n\r\n    const foundTableNames = allTables.rows.map(row => row.name);\r\n    const requiredTables = ['docs_default', 'collections', 'fts_default', 'vec_default_dense'];\r\n\r\n    // Check if we have a partial schema (some but not all required tables)\r\n    const hasAllRequired = requiredTables.every(table => foundTableNames.includes(table));\r\n    const hasSomeRequired = requiredTables.some(table => foundTableNames.includes(table));\r\n\r\n    if (hasSomeRequired && !hasAllRequired) {\r\n      this.log('warn', 'Detected incomplete schema - cleaning up and recreating');\r\n      await this.cleanupIncompleteSchema(foundTableNames);\r\n    } else if (hasAllRequired) {\r\n      this.log('info', 'Complete schema detected, skipping initialization');\r\n      return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up incomplete schema installation\r\n   */\r\n  private async cleanupIncompleteSchema(tableNames: string[]): Promise<void> {\r\n    // Drop virtual tables first (FTS and vector tables)\r\n    const virtualTables = ['fts_default', 'vec_default_dense'];\r\n    for (const virtualTable of virtualTables) {\r\n      if (tableNames.includes(virtualTable)) {\r\n        try {\r\n          await this.sqliteManager.exec(`DROP TABLE IF EXISTS ${virtualTable}`);\r\n          this.log('info', `Dropped virtual table: ${virtualTable}`);\r\n        } catch (error) {\r\n          this.log('warn', `Failed to drop virtual table ${virtualTable}: ${error}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Drop remaining regular tables\r\n    const regularTablesToClean = ['docs_default', 'collections', 'embedding_queue'];\r\n    for (const regularTable of regularTablesToClean) {\r\n      if (tableNames.includes(regularTable)) {\r\n        try {\r\n          await this.sqliteManager.exec(`DROP TABLE IF EXISTS ${regularTable}`);\r\n          this.log('info', `Dropped regular table: ${regularTable}`);\r\n        } catch (error) {\r\n          this.log('warn', `Failed to drop regular table ${regularTable}: ${error}`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create complete database schema\r\n   */\r\n  private async createSchema(): Promise<void> {\r\n    await this.sqliteManager.exec(`\r\n      -- Base documents table (v3 schema with separate collection column)\r\n      CREATE TABLE IF NOT EXISTS docs_default (\r\n        id TEXT PRIMARY KEY,\r\n        title TEXT,\r\n        content TEXT NOT NULL,\r\n        collection TEXT NOT NULL DEFAULT 'default',\r\n        metadata JSON,\r\n        created_at INTEGER DEFAULT (strftime('%s', 'now')),\r\n        updated_at INTEGER DEFAULT (strftime('%s', 'now'))\r\n      );\r\n\r\n      -- Index for efficient collection filtering\r\n      CREATE INDEX IF NOT EXISTS idx_docs_collection ON docs_default(collection);\r\n\r\n      -- Full-text search table\r\n      CREATE VIRTUAL TABLE IF NOT EXISTS fts_default USING fts5(\r\n        title, content, metadata,\r\n        content=docs_default,\r\n        content_rowid=rowid\r\n      );\r\n\r\n      -- Vector search table (384-dimensional dense vectors)\r\n      CREATE VIRTUAL TABLE IF NOT EXISTS vec_default_dense USING vec0(\r\n        embedding float[384]\r\n      );\r\n\r\n      -- Collections metadata with embedding configuration\r\n      CREATE TABLE IF NOT EXISTS collections (\r\n        name TEXT PRIMARY KEY,\r\n        created_at INTEGER DEFAULT (strftime('%s', 'now')),\r\n        updated_at INTEGER DEFAULT (strftime('%s', 'now')),\r\n        schema_version INTEGER DEFAULT ${CURRENT_SCHEMA_VERSION},\r\n        config JSON,\r\n        embedding_provider TEXT DEFAULT 'local',\r\n        embedding_dimensions INTEGER DEFAULT 384,\r\n        embedding_status TEXT DEFAULT 'enabled' CHECK(embedding_status IN ('enabled', 'disabled', 'pending')),\r\n        processing_status TEXT DEFAULT 'idle' CHECK(processing_status IN ('idle', 'processing', 'error'))\r\n      );\r\n\r\n      -- Embedding queue for background processing\r\n      CREATE TABLE IF NOT EXISTS embedding_queue (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        collection_name TEXT NOT NULL,\r\n        document_id TEXT NOT NULL,\r\n        text_content TEXT NOT NULL,\r\n        priority INTEGER DEFAULT 0,\r\n        status TEXT DEFAULT 'pending' CHECK(status IN ('pending', 'processing', 'completed', 'failed')),\r\n        retry_count INTEGER DEFAULT 0,\r\n        created_at INTEGER DEFAULT (strftime('%s', 'now')),\r\n        started_at INTEGER,\r\n        completed_at INTEGER,\r\n        processed_at INTEGER,\r\n        error_message TEXT,\r\n        FOREIGN KEY(collection_name) REFERENCES collections(name) ON DELETE CASCADE\r\n      );\r\n\r\n      -- Create indexes for embedding queue performance\r\n      CREATE INDEX IF NOT EXISTS idx_embedding_queue_status ON embedding_queue(status);\r\n      CREATE INDEX IF NOT EXISTS idx_embedding_queue_collection ON embedding_queue(collection_name);\r\n      CREATE INDEX IF NOT EXISTS idx_embedding_queue_priority ON embedding_queue(priority DESC);\r\n      CREATE INDEX IF NOT EXISTS idx_embedding_queue_created ON embedding_queue(created_at);\r\n\r\n      -- Insert default collection info\r\n      INSERT OR IGNORE INTO collections (name, config)\r\n      VALUES ('default', '{\"vectorDim\": 384, \"metric\": \"cosine\"}');\r\n    `);\r\n  }\r\n\r\n  /**\r\n   * Get collection information\r\n   */\r\n  async getCollectionInfo(name: string): Promise<CollectionInfo> {\r\n    try {\r\n      const collectionResult = await this.sqliteManager.select(\r\n        'SELECT * FROM collections WHERE name = ?',\r\n        [name]\r\n      );\r\n\r\n      if (collectionResult.rows.length === 0) {\r\n        throw new DatabaseError(`Collection '${name}' not found`);\r\n      }\r\n\r\n      const collection = collectionResult.rows[0];\r\n\r\n      // Get document count (using collection column in v3+)\r\n      const countResult = await this.sqliteManager.select(\r\n        `SELECT COUNT(*) as count FROM docs_default WHERE collection = ?`,\r\n        [name]\r\n      );\r\n\r\n      let config;\r\n      try {\r\n        config = JSON.parse(collection.config || '{}');\r\n      } catch {\r\n        config = {};\r\n      }\r\n\r\n      return {\r\n        name: collection.name,\r\n        createdAt: collection.created_at,\r\n        schemaVersion: collection.schema_version,\r\n        vectorDimensions: config.vectorDim || 384,\r\n        documentCount: countResult.rows[0]?.count || 0\r\n      };\r\n    } catch (error) {\r\n      throw new DatabaseError(`Failed to get collection info: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new collection\r\n   */\r\n  async createCollection(\r\n    name: string,\r\n    dimensions: number = 384,\r\n    config: Record<string, any> = {}\r\n  ): Promise<void> {\r\n    try {\r\n      // Check if collection already exists\r\n      const existing = await this.sqliteManager.select(\r\n        'SELECT name FROM collections WHERE name = ?',\r\n        [name]\r\n      );\r\n\r\n      if (existing.rows.length > 0) {\r\n        throw new DatabaseError(`Collection '${name}' already exists`);\r\n      }\r\n\r\n      const collectionMetadata = {\r\n        vectorDim: dimensions,\r\n        metric: 'cosine',\r\n        ...config\r\n      };\r\n\r\n      await this.sqliteManager.exec(`\r\n        INSERT INTO collections (name, config, schema_version, created_at, updated_at)\r\n        VALUES (?, ?, ?, ?, ?)\r\n      `);\r\n\r\n      // Use select to avoid parameter binding issues\r\n      const timestamp = Math.floor(Date.now() / 1000);\r\n      const result = await this.sqliteManager.select(\r\n        `SELECT ? as name, ? as config, ? as schema_version, ? as created_at, ? as updated_at`,\r\n        [\r\n          name,\r\n          JSON.stringify(collectionMetadata),\r\n          CURRENT_SCHEMA_VERSION,\r\n          timestamp,\r\n          timestamp\r\n        ]\r\n      );\r\n\r\n      // Insert the data\r\n      await this.sqliteManager.exec(\r\n        `INSERT INTO collections (name, config, schema_version, created_at, updated_at)\r\n         VALUES ('${name}', '${JSON.stringify(collectionMetadata)}', ${CURRENT_SCHEMA_VERSION}, ${timestamp}, ${timestamp})`\r\n      );\r\n\r\n      this.log('info', `Collection '${name}' created with ${dimensions} dimensions`);\r\n    } catch (error) {\r\n      throw new DatabaseError(`Failed to create collection: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if collection exists\r\n   */\r\n  async collectionExists(name: string): Promise<boolean> {\r\n    try {\r\n      const result = await this.sqliteManager.select(\r\n        'SELECT name FROM collections WHERE name = ?',\r\n        [name]\r\n      );\r\n      return result.rows.length > 0;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current schema version\r\n   */\r\n  async getSchemaVersion(): Promise<number> {\r\n    try {\r\n      const result = await this.sqliteManager.select('SELECT MAX(schema_version) as version FROM collections');\r\n      return result.rows[0]?.version || 0;\r\n    } catch (error) {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate schema integrity\r\n   */\r\n  async validateSchema(): Promise<boolean> {\r\n    try {\r\n      const requiredTables = ['docs_default', 'collections', 'fts_default', 'vec_default_dense'];\r\n\r\n      for (const table of requiredTables) {\r\n        const result = await this.sqliteManager.select(\r\n          \"SELECT name FROM sqlite_master WHERE type='table' AND name = ?\",\r\n          [table]\r\n        );\r\n        if (result.rows.length === 0) {\r\n          this.log('error', `Required table '${table}' is missing`);\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      this.log('error', `Schema validation failed: ${error instanceof Error ? error.message : String(error)}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private log(level: string, message: string, data?: any): void {\r\n    if (this.logger) {\r\n      this.logger.log(level, message, data);\r\n    } else {\r\n      console.log(`[SchemaManager] ${level.toUpperCase()}: ${message}`, data ? data : '');\r\n    }\r\n  }\r\n}","/**\r\n * EmbeddingQueue\r\n *\r\n * Manages background embedding processing queue operations.\r\n * Handles queuing, batch processing, and status tracking of embedding generation tasks.\r\n */\r\n\r\nimport type { SQLiteManager } from '../core/SQLiteManager.js';\r\nimport type {\r\n  EnqueueEmbeddingParams,\r\n  ProcessEmbeddingQueueParams,\r\n  ProcessEmbeddingQueueResult,\r\n  QueueStatusResult,\r\n  ClearEmbeddingQueueParams\r\n} from '../../../types/worker.js';\r\nimport { DatabaseError } from '../../../types/worker.js';\r\nimport { EmbeddingError } from '../../../embedding/errors.js';\r\n\r\n/**\r\n * Queue item structure\r\n */\r\nexport interface QueueItem {\r\n  id: number;\r\n  collection_name: string;\r\n  document_id: string;\r\n  content: string;\r\n  metadata?: any;\r\n  status: 'pending' | 'processing' | 'completed' | 'failed';\r\n  priority: number;\r\n  retry_count: number;\r\n  created_at: number;\r\n  started_at?: number;\r\n  completed_at?: number;\r\n  processed_at?: number;\r\n  error_message?: string;\r\n}\r\n\r\n/**\r\n * Queue processing statistics\r\n */\r\nexport interface QueueStats {\r\n  pending: number;\r\n  processing: number;\r\n  completed: number;\r\n  failed: number;\r\n  total: number;\r\n  avgProcessingTime?: number;\r\n}\r\n\r\n/**\r\n * EmbeddingQueue manages background embedding processing\r\n *\r\n * Responsibilities:\r\n * - Queue document embedding requests\r\n * - Batch processing of embedding tasks\r\n * - Priority-based task scheduling\r\n * - Status tracking and reporting\r\n * - Error handling and retry logic\r\n * - Queue maintenance and cleanup\r\n */\r\nexport class EmbeddingQueue {\r\n  constructor(\r\n    private sqliteManager: SQLiteManager,\r\n    private logger?: { log: (level: string, message: string, data?: any) => void }\r\n  ) {}\r\n\r\n  /**\r\n   * Enqueue a document for embedding generation\r\n   */\r\n  async enqueue(params: EnqueueEmbeddingParams): Promise<number> {\r\n    const { collection, documentId, textContent, priority = 0 } = params;\r\n\r\n    try {\r\n      // Verify collection exists\r\n      await this.verifyCollectionExists(collection);\r\n\r\n      // Insert into queue with INSERT OR REPLACE to handle duplicates\r\n      const result = await this.sqliteManager.select(`\r\n        INSERT OR REPLACE INTO embedding_queue\r\n        (collection_name, document_id, text_content, priority, status, created_at)\r\n        VALUES (?, ?, ?, ?, 'pending', strftime('%s', 'now'))\r\n        RETURNING id\r\n      `, [collection, documentId, textContent, priority]);\r\n\r\n      const queueId = result.rows[0]?.id;\r\n      if (!queueId) {\r\n        // Fallback for databases that don't support RETURNING\r\n        const lastInsertResult = await this.sqliteManager.select('SELECT last_insert_rowid() as id');\r\n        const fallbackId = lastInsertResult.rows[0]?.id;\r\n\r\n        if (!fallbackId) {\r\n          throw new DatabaseError('Failed to get queue item ID');\r\n        }\r\n\r\n        this.log('info', `Enqueued embedding for document '${documentId}' in collection '${collection}' with priority ${priority} (ID: ${fallbackId})`);\r\n        return fallbackId;\r\n      }\r\n\r\n      this.log('info', `Enqueued embedding for document '${documentId}' in collection '${collection}' with priority ${priority} (ID: ${queueId})`);\r\n      return queueId;\r\n    } catch (error) {\r\n      throw new DatabaseError(`Failed to enqueue embedding: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process pending items in the queue\r\n   */\r\n  async processQueue(params: ProcessEmbeddingQueueParams, embeddingGenerator: (collection: string, content: string) => Promise<Float32Array>): Promise<ProcessEmbeddingQueueResult> {\r\n    const { collection, batchSize = 10, maxRetries = 3 } = params;\r\n\r\n    try {\r\n      // Get pending queue items\r\n      const queueItems = await this.getPendingItems(collection, batchSize);\r\n\r\n      if (queueItems.length === 0) {\r\n        this.log('info', `No pending items in embedding queue${collection ? ' for collection ' + collection : ''}`);\r\n        return { processed: 0, failed: 0, remainingInQueue: 0, errors: [] };\r\n      }\r\n\r\n      this.log('info', `Processing ${queueItems.length} items from embedding queue`);\r\n\r\n      const result: ProcessEmbeddingQueueResult = {\r\n        processed: 0,\r\n        failed: 0,\r\n        remainingInQueue: 0,\r\n        errors: []\r\n      };\r\n\r\n      // Process each item in the batch\r\n      for (const item of queueItems) {\r\n        result.processed++;\r\n\r\n        try {\r\n          // Mark as processing\r\n          await this.markAsProcessing(item.id);\r\n\r\n          // Generate embedding\r\n          const embedding = await embeddingGenerator(item.collection_name, item.content);\r\n\r\n          // Store the embedding in vector table\r\n          await this.storeEmbedding(item.collection_name, item.document_id, embedding);\r\n\r\n          // Mark as completed\r\n          await this.markAsCompleted(item.id);\r\n\r\n          this.log('debug', `Successfully processed embedding for document '${item.document_id}' in collection '${item.collection_name}'`);\r\n        } catch (error) {\r\n          const errorMessage = error instanceof Error ? error.message : String(error);\r\n\r\n          // Handle retry logic\r\n          if (item.retry_count < maxRetries) {\r\n            await this.markForRetry(item.id, item.retry_count + 1);\r\n            this.log('warn', `Embedding processing failed for document '${item.document_id}', will retry (attempt ${item.retry_count + 1}/${maxRetries}): ${errorMessage}`);\r\n          } else {\r\n            // Mark as failed after max retries\r\n            await this.markAsFailed(item.id, errorMessage);\r\n            result.failed++;\r\n            result.errors.push({\r\n              documentId: item.document_id,\r\n              error: errorMessage\r\n            });\r\n            this.log('error', `Embedding processing failed permanently for document '${item.document_id}' after ${maxRetries} retries: ${errorMessage}`);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Calculate remaining items in queue\r\n      const remainingResult = await this.sqliteManager.select(`\r\n        SELECT COUNT(*) as count FROM embedding_queue\r\n        WHERE status = 'pending'${collection ? ' AND collection_name = ?' : ''}\r\n      `, collection ? [collection] : []);\r\n      result.remainingInQueue = remainingResult.rows[0]?.count || 0;\r\n\r\n      this.log('info', `Queue processing completed: ${result.processed - result.failed} successful, ${result.failed} failed, ${result.remainingInQueue} remaining`);\r\n      return result;\r\n    } catch (error) {\r\n      throw new DatabaseError(`Failed to process embedding queue: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get queue status statistics\r\n   */\r\n  async getStatus(collection?: string): Promise<QueueStatusResult> {\r\n    try {\r\n      let baseQuery = `\r\n        SELECT\r\n          status,\r\n          COUNT(*) as count,\r\n          AVG(CASE\r\n            WHEN status = 'completed' AND processed_at IS NOT NULL AND started_at IS NOT NULL\r\n            THEN processed_at - started_at\r\n            ELSE NULL\r\n          END) as avg_processing_time\r\n        FROM embedding_queue\r\n      `;\r\n\r\n      let queryParams: any[] = [];\r\n      if (collection) {\r\n        baseQuery += ' WHERE collection_name = ?';\r\n        queryParams.push(collection);\r\n      }\r\n\r\n      baseQuery += ' GROUP BY status';\r\n\r\n      const result = await this.sqliteManager.select(baseQuery, queryParams);\r\n\r\n      // Initialize counters\r\n      const stats: QueueStats = {\r\n        pending: 0,\r\n        processing: 0,\r\n        completed: 0,\r\n        failed: 0,\r\n        total: 0\r\n      };\r\n\r\n      let totalProcessingTime = 0;\r\n      let completedWithTime = 0;\r\n\r\n      // Process results\r\n      for (const row of result.rows) {\r\n        const status = row.status as keyof QueueStats;\r\n        const count = row.count as number;\r\n\r\n        if (status in stats) {\r\n          (stats as any)[status] = count;\r\n          stats.total += count;\r\n        }\r\n\r\n        if (status === 'completed' && row.avg_processing_time) {\r\n          totalProcessingTime += row.avg_processing_time * count;\r\n          completedWithTime += count;\r\n        }\r\n      }\r\n\r\n      // Calculate average processing time\r\n      if (completedWithTime > 0) {\r\n        stats.avgProcessingTime = Math.round(totalProcessingTime / completedWithTime);\r\n      }\r\n\r\n      // Get collection-specific information if requested\r\n      let collections: string[] = [];\r\n      if (!collection) {\r\n        const collectionsResult = await this.sqliteManager.select(`\r\n          SELECT DISTINCT collection_name\r\n          FROM embedding_queue\r\n          ORDER BY collection_name\r\n        `);\r\n        collections = collectionsResult.rows.map(row => row.collection_name);\r\n      }\r\n\r\n      return {\r\n        collection: collection || 'global',\r\n        pendingCount: stats.pending,\r\n        processingCount: stats.processing,\r\n        completedCount: stats.completed,\r\n        failedCount: stats.failed,\r\n        totalCount: stats.total,\r\n        averageProcessingTime: stats.avgProcessingTime\r\n      };\r\n    } catch (error) {\r\n      throw new DatabaseError(`Failed to get queue status: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear queue items based on criteria\r\n   */\r\n  async clearQueue(params: ClearEmbeddingQueueParams = {}): Promise<number> {\r\n    const { collection, status } = params;\r\n\r\n    try {\r\n      let deleteQuery = 'DELETE FROM embedding_queue WHERE 1=1';\r\n      const queryParams: any[] = [];\r\n\r\n      if (collection) {\r\n        deleteQuery += ' AND collection_name = ?';\r\n        queryParams.push(collection);\r\n      }\r\n\r\n      if (status) {\r\n        deleteQuery += ' AND status = ?';\r\n        queryParams.push(status);\r\n      }\r\n\r\n      await this.sqliteManager.exec(deleteQuery);\r\n\r\n      // Get the number of deleted rows (approximation since exec doesn't return rowsAffected)\r\n      const countQuery = deleteQuery.replace('DELETE FROM embedding_queue', 'SELECT COUNT(*) as count FROM embedding_queue');\r\n      const beforeCount = await this.sqliteManager.select('SELECT COUNT(*) as count FROM embedding_queue');\r\n      const deletedCount = beforeCount.rows[0]?.count || 0;\r\n\r\n      this.log('info', `Cleared ${deletedCount} items from embedding queue`);\r\n      return deletedCount;\r\n    } catch (error) {\r\n      throw new DatabaseError(`Failed to clear embedding queue: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pending queue items with priority ordering\r\n   */\r\n  private async getPendingItems(collection?: string, limit: number = 10): Promise<QueueItem[]> {\r\n    let query = `\r\n      SELECT id, collection_name, document_id, text_content as content, status, priority,\r\n             retry_count, created_at, started_at, completed_at, processed_at, error_message\r\n      FROM embedding_queue\r\n      WHERE status = 'pending'\r\n    `;\r\n\r\n    const queryParams: any[] = [];\r\n    if (collection) {\r\n      query += ' AND collection_name = ?';\r\n      queryParams.push(collection);\r\n    }\r\n\r\n    query += ' ORDER BY priority DESC, created_at ASC LIMIT ?';\r\n    queryParams.push(limit);\r\n\r\n    const result = await this.sqliteManager.select(query, queryParams);\r\n\r\n    return result.rows.map(row => ({\r\n      id: row.id,\r\n      collection_name: row.collection_name,\r\n      document_id: row.document_id,\r\n      content: row.content,\r\n      status: row.status,\r\n      priority: row.priority,\r\n      retry_count: row.retry_count,\r\n      created_at: row.created_at,\r\n      started_at: row.started_at,\r\n      completed_at: row.completed_at,\r\n      processed_at: row.processed_at,\r\n      error_message: row.error_message\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Mark queue item as processing\r\n   */\r\n  private async markAsProcessing(queueId: number): Promise<void> {\r\n    await this.sqliteManager.exec(`\r\n      UPDATE embedding_queue\r\n      SET status = 'processing', started_at = strftime('%s', 'now')\r\n      WHERE id = ?\r\n    `);\r\n    // Note: exec doesn't support parameters, so we use select instead\r\n    await this.sqliteManager.select(\r\n      \"UPDATE embedding_queue SET status = 'processing', started_at = strftime('%s', 'now') WHERE id = ? RETURNING id\",\r\n      [queueId]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Mark queue item as completed\r\n   */\r\n  private async markAsCompleted(queueId: number): Promise<void> {\r\n    await this.sqliteManager.select(\r\n      \"UPDATE embedding_queue SET status = 'completed', completed_at = strftime('%s', 'now'), processed_at = strftime('%s', 'now') WHERE id = ? RETURNING id\",\r\n      [queueId]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Mark queue item as failed\r\n   */\r\n  private async markAsFailed(queueId: number, errorMessage: string): Promise<void> {\r\n    await this.sqliteManager.select(\r\n      \"UPDATE embedding_queue SET status = 'failed', error_message = ?, processed_at = strftime('%s', 'now') WHERE id = ? RETURNING id\",\r\n      [errorMessage, queueId]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Mark queue item for retry\r\n   */\r\n  private async markForRetry(queueId: number, retryCount: number): Promise<void> {\r\n    await this.sqliteManager.select(\r\n      \"UPDATE embedding_queue SET status = 'pending', retry_count = ?, processed_at = strftime('%s', 'now') WHERE id = ? RETURNING id\",\r\n      [retryCount, queueId]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Store embedding in vector table\r\n   */\r\n  private async storeEmbedding(collection: string, documentId: string, embedding: Float32Array): Promise<void> {\r\n    // Get the rowid for the document (using collection column in schema v3+)\r\n    const docResult = await this.sqliteManager.select(\r\n      `SELECT rowid FROM docs_default WHERE id = ? AND collection = ?`,\r\n      [documentId, collection]\r\n    );\r\n\r\n    if (docResult.rows.length === 0) {\r\n      throw new DatabaseError(`Document '${documentId}' not found in collection '${collection}'`);\r\n    }\r\n\r\n    const rowid = docResult.rows[0].rowid;\r\n\r\n    // Convert Float32Array to blob\r\n    const embeddingBlob = new Uint8Array(embedding.buffer);\r\n\r\n    // Insert into vector table\r\n    await this.sqliteManager.select(\r\n      `INSERT OR REPLACE INTO vec_default_dense (rowid, embedding) VALUES (?, ?)`,\r\n      [rowid, embeddingBlob]\r\n    );\r\n\r\n    this.log('debug', `Stored embedding for document '${documentId}' (rowid: ${rowid}) with ${embedding.length} dimensions`);\r\n  }\r\n\r\n  /**\r\n   * Verify collection exists\r\n   */\r\n  private async verifyCollectionExists(collection: string): Promise<void> {\r\n    const result = await this.sqliteManager.select(\r\n      'SELECT name FROM collections WHERE name = ?',\r\n      [collection]\r\n    );\r\n\r\n    if (result.rows.length === 0) {\r\n      throw new DatabaseError(`Collection '${collection}' does not exist`);\r\n    }\r\n  }\r\n\r\n  private log(level: string, message: string, data?: any): void {\r\n    if (this.logger) {\r\n      this.logger.log(level, message, data);\r\n    } else {\r\n      console.log(`[EmbeddingQueue] ${level.toUpperCase()}: ${message}`, data ? data : '');\r\n    }\r\n  }\r\n}","/**\r\n * ProviderManager\r\n *\r\n * Manages embedding providers for different collections.\r\n * Handles provider initialization, caching, and lifecycle management.\r\n */\r\n\r\nimport type { EmbeddingProvider } from '../../../embedding/providers/BaseProvider.js';\r\nimport type { CollectionEmbeddingConfig } from '../../../embedding/types.js';\r\nimport { providerFactory } from '../../../embedding/ProviderFactory.js';\r\nimport { EmbeddingError } from '../../../embedding/errors.js';\r\nimport type { SQLiteManager } from '../core/SQLiteManager.js';\r\n\r\n/**\r\n * Provider cache entry\r\n */\r\ninterface ProviderCacheEntry {\r\n  provider: EmbeddingProvider;\r\n  config: CollectionEmbeddingConfig;\r\n  lastUsed: number;\r\n  initPromise?: Promise<EmbeddingProvider>;\r\n}\r\n\r\n/**\r\n * ProviderManager manages embedding providers for collections\r\n *\r\n * Responsibilities:\r\n * - Provider initialization and configuration\r\n * - Provider caching and lifecycle management\r\n * - Collection-specific provider resolution\r\n * - Resource cleanup and disposal\r\n * - Provider health monitoring\r\n */\r\nexport class ProviderManager {\r\n  private providers = new Map<string, ProviderCacheEntry>();\r\n  private initPromises = new Map<string, Promise<EmbeddingProvider>>();\r\n  private cleanupTimer: NodeJS.Timeout | null = null;\r\n  private readonly maxCacheAge = 30 * 60 * 1000; // 30 minutes\r\n  private readonly cleanupInterval = 5 * 60 * 1000; // 5 minutes\r\n\r\n  constructor(\r\n    private sqliteManager: SQLiteManager,\r\n    private logger?: { log: (level: string, message: string, data?: any) => void }\r\n  ) {\r\n    this.startCleanupTimer();\r\n  }\r\n\r\n  /**\r\n   * Get or create embedding provider for a collection\r\n   */\r\n  async getProvider(collection: string): Promise<EmbeddingProvider | null> {\r\n    try {\r\n      // Check cache first\r\n      const cached = this.providers.get(collection);\r\n      if (cached) {\r\n        cached.lastUsed = Date.now();\r\n        return cached.provider;\r\n      }\r\n\r\n      // Check if initialization is already in progress\r\n      const initPromise = this.initPromises.get(collection);\r\n      if (initPromise) {\r\n        return await initPromise;\r\n      }\r\n\r\n      // Start new initialization\r\n      const promise = this.initializeProvider(collection);\r\n      this.initPromises.set(collection, promise);\r\n\r\n      try {\r\n        const provider = await promise;\r\n        this.cacheProvider(collection, provider);\r\n        this.initPromises.delete(collection);\r\n        return provider;\r\n      } catch (error) {\r\n        this.initPromises.delete(collection);\r\n        throw error;\r\n      }\r\n    } catch (error) {\r\n      this.log('error', `Failed to get embedding provider for collection '${collection}': ${error instanceof Error ? error.message : String(error)}`);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize embedding provider for a collection\r\n   */\r\n  private async initializeProvider(collection: string): Promise<EmbeddingProvider> {\r\n    try {\r\n      // Get collection configuration\r\n      const collectionResult = await this.sqliteManager.select(\r\n        'SELECT config FROM collections WHERE name = ?',\r\n        [collection]\r\n      );\r\n\r\n      if (collectionResult.rows.length === 0) {\r\n        throw new EmbeddingError(`Collection '${collection}' not found`);\r\n      }\r\n\r\n      const config = JSON.parse(collectionResult.rows[0].config || '{}');\r\n      const embeddingConfig: CollectionEmbeddingConfig = config.embeddingConfig;\r\n\r\n      if (!embeddingConfig) {\r\n        throw new EmbeddingError(`Collection '${collection}' has no embedding configuration`);\r\n      }\r\n\r\n      // Create provider using factory\r\n      const provider = await providerFactory.createProvider(embeddingConfig);\r\n\r\n      // Initialize the provider\r\n      if (typeof provider.initialize === 'function') {\r\n        // Convert CollectionEmbeddingConfig to EmbeddingConfig\r\n        const globalConfig = {\r\n          defaultProvider: embeddingConfig.provider,\r\n          defaultDimensions: embeddingConfig.dimensions,\r\n          provider: embeddingConfig.provider,\r\n          defaultModel: embeddingConfig.model,\r\n          apiKey: embeddingConfig.apiKey,\r\n          batchSize: embeddingConfig.batchSize,\r\n          timeout: embeddingConfig.timeout,\r\n          enabled: embeddingConfig.autoGenerate !== false\r\n        };\r\n        await provider.initialize(globalConfig);\r\n      }\r\n\r\n      this.log('info', `Initialized embedding provider '${embeddingConfig.provider}' for collection '${collection}'`);\r\n      return provider;\r\n    } catch (error) {\r\n      throw new EmbeddingError(`Failed to initialize embedding provider for collection '${collection}': ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cache provider with metadata\r\n   */\r\n  private cacheProvider(collection: string, provider: EmbeddingProvider): void {\r\n    // Get the config again for caching\r\n    this.sqliteManager.select(\r\n      'SELECT config FROM collections WHERE name = ?',\r\n      [collection]\r\n    ).then(result => {\r\n      if (result.rows.length > 0) {\r\n        const config = JSON.parse(result.rows[0].config || '{}');\r\n        const embeddingConfig: CollectionEmbeddingConfig = config.embeddingConfig;\r\n\r\n        this.providers.set(collection, {\r\n          provider,\r\n          config: embeddingConfig,\r\n          lastUsed: Date.now()\r\n        });\r\n      }\r\n    }).catch(error => {\r\n      this.log('warn', `Failed to cache provider config for collection '${collection}': ${error instanceof Error ? error.message : String(error)}`);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove provider from cache\r\n   */\r\n  async removeProvider(collection: string): Promise<void> {\r\n    const cached = this.providers.get(collection);\r\n    if (cached) {\r\n      try {\r\n        if (typeof (cached.provider as any).dispose === 'function') {\r\n          await (cached.provider as any).dispose();\r\n        }\r\n      } catch (error) {\r\n        this.log('warn', `Error disposing provider for collection '${collection}': ${error instanceof Error ? error.message : String(error)}`);\r\n      }\r\n\r\n      this.providers.delete(collection);\r\n      this.log('debug', `Removed provider for collection '${collection}' from cache`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update provider configuration\r\n   */\r\n  async updateProviderConfig(collection: string, config: CollectionEmbeddingConfig): Promise<void> {\r\n    // Remove existing provider\r\n    await this.removeProvider(collection);\r\n\r\n    // Clear any pending initialization\r\n    this.initPromises.delete(collection);\r\n\r\n    this.log('info', `Updated provider configuration for collection '${collection}'`);\r\n  }\r\n\r\n  /**\r\n   * Get provider health status\r\n   */\r\n  async getProviderHealth(collection: string): Promise<{ healthy: boolean; error?: string }> {\r\n    try {\r\n      const provider = await this.getProvider(collection);\r\n      if (!provider) {\r\n        return { healthy: false, error: 'Provider not available' };\r\n      }\r\n\r\n      // Check if provider has health check method\r\n      if (typeof (provider as any).healthCheck === 'function') {\r\n        try {\r\n          const healthStatus = await (provider as any).healthCheck();\r\n          return { healthy: healthStatus.isHealthy };\r\n        } catch (error) {\r\n          return { healthy: false, error: error instanceof Error ? error.message : String(error) };\r\n        }\r\n      }\r\n\r\n      // Basic health check - try to generate a small embedding\r\n      try {\r\n        const testResult = await provider.generateEmbedding('test');\r\n        return { healthy: testResult.length > 0 };\r\n      } catch (error) {\r\n        return { healthy: false, error: error instanceof Error ? error.message : String(error) };\r\n      }\r\n    } catch (error) {\r\n      return { healthy: false, error: error instanceof Error ? error.message : String(error) };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all cached providers\r\n   */\r\n  getCachedProviders(): string[] {\r\n    return Array.from(this.providers.keys());\r\n  }\r\n\r\n  /**\r\n   * Get provider statistics\r\n   */\r\n  getProviderStats(): { collection: string; type: string; lastUsed: number }[] {\r\n    return Array.from(this.providers.entries()).map(([collection, entry]) => ({\r\n      collection,\r\n      type: entry.config.provider,\r\n      lastUsed: entry.lastUsed\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Cleanup expired providers\r\n   */\r\n  private async cleanupExpiredProviders(): Promise<void> {\r\n    const now = Date.now();\r\n    const expiredCollections: string[] = [];\r\n\r\n    for (const [collection, entry] of this.providers.entries()) {\r\n      if (now - entry.lastUsed > this.maxCacheAge) {\r\n        expiredCollections.push(collection);\r\n      }\r\n    }\r\n\r\n    if (expiredCollections.length > 0) {\r\n      this.log('debug', `Cleaning up ${expiredCollections.length} expired providers`);\r\n\r\n      for (const collection of expiredCollections) {\r\n        await this.removeProvider(collection);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start cleanup timer for expired providers\r\n   */\r\n  private startCleanupTimer(): void {\r\n    if (this.cleanupTimer) {\r\n      return;\r\n    }\r\n\r\n    this.cleanupTimer = setInterval(async () => {\r\n      try {\r\n        await this.cleanupExpiredProviders();\r\n      } catch (error) {\r\n        this.log('warn', `Provider cleanup error: ${error instanceof Error ? error.message : String(error)}`);\r\n      }\r\n    }, this.cleanupInterval);\r\n\r\n    this.log('debug', `Started provider cleanup timer with interval: ${this.cleanupInterval}ms`);\r\n  }\r\n\r\n  /**\r\n   * Stop cleanup timer\r\n   */\r\n  private stopCleanupTimer(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = null;\r\n      this.log('debug', 'Stopped provider cleanup timer');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dispose all providers and cleanup resources\r\n   */\r\n  async dispose(): Promise<void> {\r\n    this.log('info', `Disposing ${this.providers.size} embedding providers`);\r\n\r\n    // Stop cleanup timer\r\n    this.stopCleanupTimer();\r\n\r\n    // Dispose all providers\r\n    const disposePromises = Array.from(this.providers.keys()).map(collection =>\r\n      this.removeProvider(collection)\r\n    );\r\n\r\n    try {\r\n      await Promise.all(disposePromises);\r\n      this.log('info', 'All embedding providers disposed successfully');\r\n    } catch (error) {\r\n      this.log('error', `Error during provider disposal: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n\r\n    // Clear all caches\r\n    this.providers.clear();\r\n    this.initPromises.clear();\r\n  }\r\n\r\n  /**\r\n   * Force refresh all providers (reload configurations)\r\n   */\r\n  async refreshAll(): Promise<void> {\r\n    this.log('info', 'Refreshing all embedding providers');\r\n\r\n    const collections = Array.from(this.providers.keys());\r\n\r\n    // Remove all current providers\r\n    for (const collection of collections) {\r\n      await this.removeProvider(collection);\r\n    }\r\n\r\n    this.log('info', `Refreshed ${collections.length} embedding providers`);\r\n  }\r\n\r\n  private log(level: string, message: string, data?: any): void {\r\n    if (this.logger) {\r\n      this.logger.log(level, message, data);\r\n    } else {\r\n      console.log(`[ProviderManager] ${level.toUpperCase()}: ${message}`, data ? data : '');\r\n    }\r\n  }\r\n}","/**\r\n * ErrorHandling\r\n *\r\n * Centralized error handling utilities with enhanced error classification,\r\n * context preservation, and recovery strategies.\r\n */\r\n\r\nimport { DatabaseError, VectorError, OPFSError } from '../../../types/worker.js';\r\nimport { EmbeddingError } from '../../../embedding/errors.js';\r\n\r\n/**\r\n * Error context for enhanced error reporting\r\n */\r\nexport interface ErrorContext {\r\n  operation: string;\r\n  component: string;\r\n  params?: Record<string, any>;\r\n  timestamp: number;\r\n  stackTrace?: string;\r\n}\r\n\r\n/**\r\n * Enhanced error with additional context\r\n */\r\nexport class ContextualError extends Error {\r\n  public readonly context: ErrorContext;\r\n  public readonly originalError?: Error;\r\n\r\n  constructor(message: string, context: ErrorContext, originalError?: Error) {\r\n    super(message);\r\n    this.name = 'ContextualError';\r\n    this.context = context;\r\n    this.originalError = originalError;\r\n\r\n    // Maintain proper stack trace\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, ContextualError);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get full error message with context\r\n   */\r\n  getFullMessage(): string {\r\n    const parts = [\r\n      `[${this.context.component}:${this.context.operation}]`,\r\n      this.message\r\n    ];\r\n\r\n    if (this.originalError) {\r\n      parts.push(`Original: ${this.originalError.message}`);\r\n    }\r\n\r\n    return parts.join(' ');\r\n  }\r\n\r\n  /**\r\n   * Convert to plain object for serialization\r\n   */\r\n  toJSON(): Record<string, any> {\r\n    return {\r\n      name: this.name,\r\n      message: this.message,\r\n      context: this.context,\r\n      originalError: this.originalError ? {\r\n        name: this.originalError.name,\r\n        message: this.originalError.message,\r\n        stack: this.originalError.stack\r\n      } : null,\r\n      stack: this.stack\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Error recovery strategy\r\n */\r\nexport type RecoveryStrategy = 'retry' | 'fallback' | 'abort' | 'ignore';\r\n\r\n/**\r\n * Recovery options for error handling\r\n */\r\nexport interface RecoveryOptions {\r\n  strategy: RecoveryStrategy;\r\n  maxRetries?: number;\r\n  retryDelay?: number;\r\n  fallbackValue?: any;\r\n  onRetry?: (attempt: number, error: Error) => void;\r\n  onFallback?: (error: Error) => void;\r\n}\r\n\r\n/**\r\n * Error classification result\r\n */\r\nexport interface ErrorClassification {\r\n  category: 'database' | 'vector' | 'opfs' | 'embedding' | 'network' | 'validation' | 'unknown';\r\n  severity: 'low' | 'medium' | 'high' | 'critical';\r\n  recoverable: boolean;\r\n  userMessage: string;\r\n  suggestedAction?: string;\r\n}\r\n\r\n/**\r\n * Enhanced error handling utilities\r\n */\r\nexport class ErrorHandler {\r\n  private static errorHistory: ContextualError[] = [];\r\n  private static maxHistorySize = 100;\r\n\r\n  /**\r\n   * Wrap an operation with error handling and context\r\n   */\r\n  static async withContext<T>(\r\n    operation: string,\r\n    component: string,\r\n    fn: () => Promise<T>,\r\n    params?: Record<string, any>\r\n  ): Promise<T> {\r\n    try {\r\n      return await fn();\r\n    } catch (error) {\r\n      const context: ErrorContext = {\r\n        operation,\r\n        component,\r\n        params,\r\n        timestamp: Date.now(),\r\n        stackTrace: error instanceof Error ? error.stack : undefined\r\n      };\r\n\r\n      const contextualError = new ContextualError(\r\n        error instanceof Error ? error.message : String(error),\r\n        context,\r\n        error instanceof Error ? error : undefined\r\n      );\r\n\r\n      this.addToHistory(contextualError);\r\n      throw contextualError;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute operation with retry logic\r\n   */\r\n  static async withRetry<T>(\r\n    operation: () => Promise<T>,\r\n    options: RecoveryOptions\r\n  ): Promise<T> {\r\n    const maxRetries = options.maxRetries || 3;\r\n    const retryDelay = options.retryDelay || 1000;\r\n\r\n    let lastError: Error | null = null;\r\n\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        return await operation();\r\n      } catch (error) {\r\n        lastError = error instanceof Error ? error : new Error(String(error));\r\n\r\n        if (options.onRetry) {\r\n          options.onRetry(attempt, lastError);\r\n        }\r\n\r\n        if (attempt === maxRetries) {\r\n          break;\r\n        }\r\n\r\n        // Wait before retrying\r\n        await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));\r\n      }\r\n    }\r\n\r\n    // All retries failed\r\n    if (options.strategy === 'fallback' && options.fallbackValue !== undefined) {\r\n      if (options.onFallback) {\r\n        options.onFallback(lastError!);\r\n      }\r\n      return options.fallbackValue;\r\n    }\r\n\r\n    throw lastError || new Error('Operation failed after retries');\r\n  }\r\n\r\n  /**\r\n   * Classify error for appropriate handling\r\n   */\r\n  static classifyError(error: Error): ErrorClassification {\r\n    if (error instanceof DatabaseError) {\r\n      return this.classifyDatabaseError(error);\r\n    }\r\n\r\n    if (error instanceof VectorError) {\r\n      return {\r\n        category: 'vector',\r\n        severity: 'high',\r\n        recoverable: false,\r\n        userMessage: 'Vector search functionality is not available',\r\n        suggestedAction: 'Check if sqlite-vec extension is properly loaded'\r\n      };\r\n    }\r\n\r\n    if (error instanceof OPFSError) {\r\n      return {\r\n        category: 'opfs',\r\n        severity: 'medium',\r\n        recoverable: true,\r\n        userMessage: 'Data persistence may not work properly',\r\n        suggestedAction: 'Check browser storage settings or clear storage'\r\n      };\r\n    }\r\n\r\n    if (error instanceof EmbeddingError) {\r\n      return {\r\n        category: 'embedding',\r\n        severity: 'medium',\r\n        recoverable: true,\r\n        userMessage: 'Embedding generation failed',\r\n        suggestedAction: 'Check embedding provider configuration or try again'\r\n      };\r\n    }\r\n\r\n    // Network-related errors\r\n    if (error.message.includes('fetch') || error.message.includes('network')) {\r\n      return {\r\n        category: 'network',\r\n        severity: 'medium',\r\n        recoverable: true,\r\n        userMessage: 'Network operation failed',\r\n        suggestedAction: 'Check internet connection and try again'\r\n      };\r\n    }\r\n\r\n    // Validation errors\r\n    if (error.message.includes('invalid') || error.message.includes('validation')) {\r\n      return {\r\n        category: 'validation',\r\n        severity: 'low',\r\n        recoverable: false,\r\n        userMessage: 'Invalid input provided',\r\n        suggestedAction: 'Check your input data and try again'\r\n      };\r\n    }\r\n\r\n    // Unknown error\r\n    return {\r\n      category: 'unknown',\r\n      severity: 'medium',\r\n      recoverable: false,\r\n      userMessage: 'An unexpected error occurred',\r\n      suggestedAction: 'Try refreshing the page or contact support'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Classify database-specific errors\r\n   */\r\n  private static classifyDatabaseError(error: DatabaseError): ErrorClassification {\r\n    const message = error.message.toLowerCase();\r\n\r\n    if (message.includes('sqlite') && message.includes('corrupt')) {\r\n      return {\r\n        category: 'database',\r\n        severity: 'critical',\r\n        recoverable: false,\r\n        userMessage: 'Database is corrupted',\r\n        suggestedAction: 'Clear browser storage and reimport your data'\r\n      };\r\n    }\r\n\r\n    if (message.includes('disk') || message.includes('space')) {\r\n      return {\r\n        category: 'database',\r\n        severity: 'high',\r\n        recoverable: true,\r\n        userMessage: 'Storage space is full',\r\n        suggestedAction: 'Clear browser storage or export data to free space'\r\n      };\r\n    }\r\n\r\n    if (message.includes('locked') || message.includes('busy')) {\r\n      return {\r\n        category: 'database',\r\n        severity: 'medium',\r\n        recoverable: true,\r\n        userMessage: 'Database is temporarily busy',\r\n        suggestedAction: 'Wait a moment and try again'\r\n      };\r\n    }\r\n\r\n    if (message.includes('permission') || message.includes('access')) {\r\n      return {\r\n        category: 'database',\r\n        severity: 'high',\r\n        recoverable: false,\r\n        userMessage: 'Database access denied',\r\n        suggestedAction: 'Check browser permissions and security settings'\r\n      };\r\n    }\r\n\r\n    return {\r\n      category: 'database',\r\n      severity: 'medium',\r\n      recoverable: false,\r\n      userMessage: 'Database operation failed',\r\n      suggestedAction: 'Try refreshing the page'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create user-friendly error message with recovery suggestions\r\n   */\r\n  static createUserMessage(error: Error): string {\r\n    const classification = this.classifyError(error);\r\n\r\n    let message = classification.userMessage;\r\n\r\n    if (classification.suggestedAction) {\r\n      message += `. ${classification.suggestedAction}`;\r\n    }\r\n\r\n    return message;\r\n  }\r\n\r\n  /**\r\n   * Add error to history for debugging\r\n   */\r\n  private static addToHistory(error: ContextualError): void {\r\n    this.errorHistory.push(error);\r\n\r\n    // Trim history if it exceeds max size\r\n    if (this.errorHistory.length > this.maxHistorySize) {\r\n      this.errorHistory = this.errorHistory.slice(-this.maxHistorySize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get recent error history\r\n   */\r\n  static getErrorHistory(maxEntries?: number): ContextualError[] {\r\n    if (maxEntries && maxEntries > 0) {\r\n      return this.errorHistory.slice(-maxEntries);\r\n    }\r\n    return [...this.errorHistory];\r\n  }\r\n\r\n  /**\r\n   * Clear error history\r\n   */\r\n  static clearHistory(): void {\r\n    this.errorHistory = [];\r\n  }\r\n\r\n  /**\r\n   * Check if an error is recoverable\r\n   */\r\n  static isRecoverable(error: Error): boolean {\r\n    return this.classifyError(error).recoverable;\r\n  }\r\n\r\n  /**\r\n   * Get error severity level\r\n   */\r\n  static getSeverity(error: Error): string {\r\n    return this.classifyError(error).severity;\r\n  }\r\n\r\n  /**\r\n   * Create a standardized error response for RPC\r\n   */\r\n  static createErrorResponse(error: Error, requestId?: string): Record<string, any> {\r\n    const classification = this.classifyError(error);\r\n\r\n    return {\r\n      success: false,\r\n      error: {\r\n        message: error.message,\r\n        userMessage: classification.userMessage,\r\n        category: classification.category,\r\n        severity: classification.severity,\r\n        recoverable: classification.recoverable,\r\n        suggestedAction: classification.suggestedAction,\r\n        timestamp: Date.now(),\r\n        requestId\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Sanitize error for logging (remove sensitive data)\r\n   */\r\n  static sanitizeError(error: Error, sensitiveKeys: string[] = []): Record<string, any> {\r\n    const defaultSensitiveKeys = ['password', 'token', 'key', 'secret', 'auth'];\r\n    const allSensitiveKeys = [...defaultSensitiveKeys, ...sensitiveKeys];\r\n\r\n    const sanitize = (obj: any): any => {\r\n      if (typeof obj !== 'object' || obj === null) {\r\n        return obj;\r\n      }\r\n\r\n      if (Array.isArray(obj)) {\r\n        return obj.map(sanitize);\r\n      }\r\n\r\n      const sanitized: any = {};\r\n      for (const [key, value] of Object.entries(obj)) {\r\n        if (allSensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive))) {\r\n          sanitized[key] = '[REDACTED]';\r\n        } else if (typeof value === 'object') {\r\n          sanitized[key] = sanitize(value);\r\n        } else {\r\n          sanitized[key] = value;\r\n        }\r\n      }\r\n\r\n      return sanitized;\r\n    };\r\n\r\n    return {\r\n      name: error.name,\r\n      message: error.message,\r\n      stack: error.stack,\r\n      context: error instanceof ContextualError ? sanitize(error.context) : undefined\r\n    };\r\n  }\r\n}","/**\r\n * TypeGuards\r\n *\r\n * Runtime type validation utilities for ensuring data integrity and type safety\r\n * in worker operations.\r\n */\r\n\r\nimport type {\r\n  SQLValue,\r\n  SQLParams,\r\n  OpenDatabaseParams,\r\n  ExecParams,\r\n  SelectParams,\r\n  BulkInsertParams,\r\n  SearchRequest,\r\n  CreateCollectionParams,\r\n  InsertDocumentWithEmbeddingParams,\r\n  SemanticSearchParams,\r\n  ExportParams,\r\n  ImportParams,\r\n  GenerateEmbeddingRequest,\r\n  BatchEmbeddingRequest,\r\n  EnqueueEmbeddingParams,\r\n  ProcessEmbeddingQueueParams,\r\n  ClearEmbeddingQueueParams\r\n} from '../../../types/worker.js';\r\n\r\n/**\r\n * Type guard for SQLValue\r\n */\r\nexport function isSQLValue(value: any): value is SQLValue {\r\n  return value === null ||\r\n         value === undefined ||\r\n         typeof value === 'string' ||\r\n         typeof value === 'number' ||\r\n         value instanceof Uint8Array ||\r\n         value instanceof Float32Array;\r\n}\r\n\r\n/**\r\n * Type guard for SQLParams array\r\n */\r\nexport function isSQLParams(params: any): params is SQLParams {\r\n  return Array.isArray(params) && params.every(isSQLValue);\r\n}\r\n\r\n/**\r\n * Type guard for OpenDatabaseParams\r\n */\r\nexport function isOpenDatabaseParams(params: any): params is OpenDatabaseParams {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         typeof params.filename === 'string' &&\r\n         (params.path === undefined || typeof params.path === 'string') &&\r\n         (params.vfs === undefined || params.vfs === 'opfs' || params.vfs === 'opfs-sahpool') &&\r\n         (params.pragmas === undefined || (typeof params.pragmas === 'object' && params.pragmas !== null));\r\n}\r\n\r\n/**\r\n * Type guard for ExecParams\r\n */\r\nexport function isExecParams(params: any): params is ExecParams {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         typeof params.sql === 'string' &&\r\n         (params.params === undefined || isSQLParams(params.params));\r\n}\r\n\r\n/**\r\n * Type guard for SelectParams\r\n */\r\nexport function isSelectParams(params: any): params is SelectParams {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         typeof params.sql === 'string' &&\r\n         (params.params === undefined || isSQLParams(params.params));\r\n}\r\n\r\n/**\r\n * Type guard for BulkInsertParams\r\n */\r\nexport function isBulkInsertParams(params: any): params is BulkInsertParams {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         typeof params.tableName === 'string' &&\r\n         Array.isArray(params.data) &&\r\n         params.data.every((row: any) =>\r\n           typeof row === 'object' &&\r\n           row !== null &&\r\n           !Array.isArray(row)\r\n         );\r\n}\r\n\r\n/**\r\n * Type guard for SearchRequest\r\n */\r\nexport function isSearchRequest(params: any): params is SearchRequest {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         (typeof params.query === 'string' || typeof params.vector === 'object') &&\r\n         (params.collection === undefined || typeof params.collection === 'string') &&\r\n         (params.limit === undefined || typeof params.limit === 'number') &&\r\n         (params.threshold === undefined || typeof params.threshold === 'number') &&\r\n         (params.hybrid === undefined || typeof params.hybrid === 'boolean');\r\n}\r\n\r\n/**\r\n * Type guard for CreateCollectionParams\r\n */\r\nexport function isCreateCollectionParams(params: any): params is CreateCollectionParams {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         typeof params.name === 'string' &&\r\n         (params.dimensions === undefined || typeof params.dimensions === 'number') &&\r\n         (params.config === undefined || (typeof params.config === 'object' && params.config !== null));\r\n}\r\n\r\n/**\r\n * Type guard for InsertDocumentWithEmbeddingParams\r\n */\r\nexport function isInsertDocumentWithEmbeddingParams(params: any): params is InsertDocumentWithEmbeddingParams {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         typeof params.collection === 'string' &&\r\n         // Validate nested document object\r\n         typeof params.document === 'object' &&\r\n         params.document !== null &&\r\n         (params.document.id === undefined || typeof params.document.id === 'string') &&\r\n         typeof params.document.content === 'string' &&\r\n         (params.document.title === undefined || typeof params.document.title === 'string') &&\r\n         (params.document.metadata === undefined || (typeof params.document.metadata === 'object' && params.document.metadata !== null)) &&\r\n         // Validate optional options object\r\n         (params.options === undefined || (typeof params.options === 'object' && params.options !== null));\r\n}\r\n\r\n/**\r\n * Type guard for SemanticSearchParams\r\n */\r\nexport function isSemanticSearchParams(params: any): params is SemanticSearchParams {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         typeof params.collection === 'string' &&\r\n         typeof params.query === 'string' &&\r\n         (params.limit === undefined || typeof params.limit === 'number') &&\r\n         (params.threshold === undefined || typeof params.threshold === 'number');\r\n}\r\n\r\n/**\r\n * Type guard for ExportParams\r\n */\r\nexport function isExportParams(params: any): params is ExportParams {\r\n  return params === undefined ||\r\n         (typeof params === 'object' &&\r\n          params !== null &&\r\n          (params.format === undefined || typeof params.format === 'string'));\r\n}\r\n\r\n/**\r\n * Type guard for ImportParams\r\n */\r\nexport function isImportParams(params: any): params is ImportParams {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         (params.data instanceof Uint8Array || params.data instanceof ArrayBuffer) &&\r\n         (params.overwrite === undefined || typeof params.overwrite === 'boolean');\r\n}\r\n\r\n/**\r\n * Type guard for GenerateEmbeddingRequest\r\n */\r\nexport function isGenerateEmbeddingRequest(params: any): params is GenerateEmbeddingRequest {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         typeof params.collection === 'string' &&\r\n         typeof params.content === 'string' &&\r\n         (params.options === undefined || (typeof params.options === 'object' && params.options !== null));\r\n}\r\n\r\n/**\r\n * Type guard for BatchEmbeddingRequest\r\n */\r\nexport function isBatchEmbeddingRequest(params: any): params is BatchEmbeddingRequest {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         typeof params.collection === 'string' &&\r\n         Array.isArray(params.documents) &&\r\n         params.documents.every((doc: any) =>\r\n           typeof doc === 'object' &&\r\n           doc !== null &&\r\n           typeof doc.id === 'string' &&\r\n           typeof doc.content === 'string'\r\n         ) &&\r\n         (params.options === undefined || (typeof params.options === 'object' && params.options !== null));\r\n}\r\n\r\n/**\r\n * Type guard for EnqueueEmbeddingParams\r\n */\r\nexport function isEnqueueEmbeddingParams(params: any): params is EnqueueEmbeddingParams {\r\n  return typeof params === 'object' &&\r\n         params !== null &&\r\n         typeof params.collection === 'string' &&\r\n         typeof params.documentId === 'string' &&\r\n         typeof params.textContent === 'string' &&\r\n         (params.priority === undefined || typeof params.priority === 'number');\r\n}\r\n\r\n/**\r\n * Type guard for ProcessEmbeddingQueueParams\r\n */\r\nexport function isProcessEmbeddingQueueParams(params: any): params is ProcessEmbeddingQueueParams {\r\n  return params === undefined ||\r\n         (typeof params === 'object' &&\r\n          params !== null &&\r\n          (params.collection === undefined || typeof params.collection === 'string') &&\r\n          (params.batchSize === undefined || typeof params.batchSize === 'number') &&\r\n          (params.onProgress === undefined || typeof params.onProgress === 'function'));\r\n}\r\n\r\n/**\r\n * Type guard for ClearEmbeddingQueueParams\r\n */\r\nexport function isClearEmbeddingQueueParams(params: any): params is ClearEmbeddingQueueParams {\r\n  return params === undefined ||\r\n         (typeof params === 'object' &&\r\n          params !== null &&\r\n          (params.collection === undefined || typeof params.collection === 'string') &&\r\n          (params.status === undefined || typeof params.status === 'string'));\r\n}\r\n\r\n/**\r\n * Type guard for Float32Array\r\n */\r\nexport function isFloat32Array(value: any): value is Float32Array {\r\n  return value instanceof Float32Array;\r\n}\r\n\r\n/**\r\n * Type guard for valid collection name\r\n */\r\nexport function isValidCollectionName(name: any): name is string {\r\n  return typeof name === 'string' &&\r\n         name.length > 0 &&\r\n         name.length <= 255 &&\r\n         /^[a-zA-Z0-9_-]+$/.test(name);\r\n}\r\n\r\n/**\r\n * Type guard for valid document ID\r\n */\r\nexport function isValidDocumentId(id: any): id is string {\r\n  return typeof id === 'string' &&\r\n         id.length > 0 &&\r\n         id.length <= 255;\r\n}\r\n\r\n/**\r\n * Type guard for valid embedding vector\r\n */\r\nexport function isValidEmbedding(embedding: any): embedding is Float32Array {\r\n  return embedding instanceof Float32Array &&\r\n         embedding.length > 0 &&\r\n         embedding.length <= 2048; // Reasonable upper limit\r\n}\r\n\r\n/**\r\n * Type guard for JSON-serializable object\r\n */\r\nexport function isJSONSerializable(value: any): boolean {\r\n  try {\r\n    JSON.stringify(value);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Type guard for valid SQL identifier (table/column names)\r\n */\r\nexport function isValidSQLIdentifier(identifier: any): identifier is string {\r\n  return typeof identifier === 'string' &&\r\n         identifier.length > 0 &&\r\n         identifier.length <= 128 &&\r\n         /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(identifier);\r\n}\r\n\r\n/**\r\n * Type guard for valid limit parameter\r\n */\r\nexport function isValidLimit(limit: any): limit is number {\r\n  return typeof limit === 'number' &&\r\n         Number.isInteger(limit) &&\r\n         limit > 0 &&\r\n         limit <= 10000; // Reasonable upper limit\r\n}\r\n\r\n/**\r\n * Type guard for valid threshold parameter\r\n */\r\nexport function isValidThreshold(threshold: any): threshold is number {\r\n  return typeof threshold === 'number' &&\r\n         threshold >= 0 &&\r\n         threshold <= 1;\r\n}\r\n\r\n/**\r\n * Runtime validation for worker method parameters\r\n */\r\nexport class ParameterValidator {\r\n  /**\r\n   * Validate and sanitize parameters for a worker method\r\n   */\r\n  static validate<T>(\r\n    params: any,\r\n    typeGuard: (params: any) => params is T,\r\n    methodName: string\r\n  ): T {\r\n    if (!typeGuard(params)) {\r\n      throw new Error(`Invalid parameters for ${methodName}: ${JSON.stringify(params)}`);\r\n    }\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Validate collection name with additional business rules\r\n   */\r\n  static validateCollectionName(name: any, methodName: string): string {\r\n    if (!isValidCollectionName(name)) {\r\n      throw new Error(`Invalid collection name for ${methodName}: must be a non-empty alphanumeric string with underscores/hyphens, max 255 characters`);\r\n    }\r\n\r\n    // Additional business rules\r\n    const reservedNames = ['sqlite_master', 'sqlite_temp_master', 'sqlite_sequence'];\r\n    if (reservedNames.includes(name.toLowerCase())) {\r\n      throw new Error(`Collection name '${name}' is reserved`);\r\n    }\r\n\r\n    return name;\r\n  }\r\n\r\n  /**\r\n   * Validate document ID with additional business rules\r\n   */\r\n  static validateDocumentId(id: any, methodName: string): string {\r\n    if (!isValidDocumentId(id)) {\r\n      throw new Error(`Invalid document ID for ${methodName}: must be a non-empty string, max 255 characters`);\r\n    }\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * Validate and sanitize SQL parameters\r\n   */\r\n  static validateSQLParams(params: any, methodName: string): SQLParams | undefined {\r\n    if (params === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    if (!isSQLParams(params)) {\r\n      throw new Error(`Invalid SQL parameters for ${methodName}: must be an array of SQL values`);\r\n    }\r\n\r\n    // Additional validation for parameter safety\r\n    if (Array.isArray(params)) {\r\n      params.forEach((param: any, index: number) => {\r\n        if (typeof param === 'string' && param.length > 100000) {\r\n          throw new Error(`SQL parameter ${index} too large (${param.length} chars) for ${methodName}`);\r\n        }\r\n        if (param instanceof Uint8Array && param.length > 10000000) { // 10MB limit\r\n          throw new Error(`SQL parameter ${index} blob too large (${param.length} bytes) for ${methodName}`);\r\n        }\r\n      });\r\n    } else {\r\n      // Handle object-style parameters\r\n      Object.entries(params).forEach(([key, value]) => {\r\n        if (typeof value === 'string' && value.length > 100000) {\r\n          throw new Error(`SQL parameter ${key} too large (${value.length} chars) for ${methodName}`);\r\n        }\r\n        if (value instanceof Uint8Array && value.length > 10000000) { // 10MB limit\r\n          throw new Error(`SQL parameter ${key} blob too large (${value.length} bytes) for ${methodName}`);\r\n        }\r\n      });\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Validate embedding dimensions\r\n   */\r\n  static validateEmbeddingDimensions(dimensions: any, methodName: string): number {\r\n    if (typeof dimensions !== 'number' || !Number.isInteger(dimensions) || dimensions <= 0) {\r\n      throw new Error(`Invalid embedding dimensions for ${methodName}: must be a positive integer`);\r\n    }\r\n\r\n    if (dimensions > 4096) { // Reasonable upper limit\r\n      throw new Error(`Embedding dimensions too large for ${methodName}: maximum 4096 dimensions supported`);\r\n    }\r\n\r\n    return dimensions;\r\n  }\r\n\r\n  /**\r\n   * Validate search limit parameter\r\n   */\r\n  static validateLimit(limit: any, methodName: string, defaultValue: number = 10): number {\r\n    if (limit === undefined) {\r\n      return defaultValue;\r\n    }\r\n\r\n    if (!isValidLimit(limit)) {\r\n      throw new Error(`Invalid limit for ${methodName}: must be a positive integer between 1 and 10000`);\r\n    }\r\n\r\n    return limit;\r\n  }\r\n\r\n  /**\r\n   * Validate search threshold parameter\r\n   */\r\n  static validateThreshold(threshold: any, methodName: string): number | undefined {\r\n    if (threshold === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    if (!isValidThreshold(threshold)) {\r\n      throw new Error(`Invalid threshold for ${methodName}: must be a number between 0 and 1`);\r\n    }\r\n\r\n    return threshold;\r\n  }\r\n}","/**\r\n * BaseHandler\r\n *\r\n * Base class for all RPC handlers with common functionality.\r\n * Provides shared utilities, error handling, and context management.\r\n */\r\n\r\nimport type { SQLiteManager } from '../core/SQLiteManager.js';\r\nimport type { SchemaManager } from '../schema/SchemaManager.js';\r\nimport type { OPFSManager } from '../core/OPFSManager.js';\r\nimport { ErrorHandler, ContextualError } from '../utils/ErrorHandling.js';\r\nimport { ParameterValidator } from '../utils/TypeGuards.js';\r\n\r\n/**\r\n * Handler dependencies injected during construction\r\n */\r\nexport interface HandlerDependencies {\r\n  sqliteManager: SQLiteManager;\r\n  schemaManager: SchemaManager;\r\n  opfsManager: OPFSManager;\r\n  logger?: { log: (level: string, message: string, data?: any) => void };\r\n}\r\n\r\n/**\r\n * Base handler class providing common functionality for all RPC handlers\r\n *\r\n * Features:\r\n * - Dependency injection and management\r\n * - Consistent error handling and context tracking\r\n * - Parameter validation utilities\r\n * - Logging with component identification\r\n * - Database connection verification\r\n * - Performance monitoring hooks\r\n */\r\nexport abstract class BaseHandler {\r\n  protected sqliteManager: SQLiteManager;\r\n  protected schemaManager: SchemaManager;\r\n  protected opfsManager: OPFSManager;\r\n  protected logger?: { log: (level: string, message: string, data?: any) => void };\r\n\r\n  constructor(dependencies: HandlerDependencies) {\r\n    this.sqliteManager = dependencies.sqliteManager;\r\n    this.schemaManager = dependencies.schemaManager;\r\n    this.opfsManager = dependencies.opfsManager;\r\n    this.logger = dependencies.logger;\r\n  }\r\n\r\n  /**\r\n   * Execute an operation with error handling and context\r\n   */\r\n  protected async withContext<T>(\r\n    operation: string,\r\n    fn: () => Promise<T>,\r\n    params?: Record<string, any>\r\n  ): Promise<T> {\r\n    return ErrorHandler.withContext(\r\n      operation,\r\n      this.getComponentName(),\r\n      fn,\r\n      params\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Execute an operation with retry logic\r\n   */\r\n  protected async withRetry<T>(\r\n    operation: () => Promise<T>,\r\n    maxRetries: number = 3,\r\n    retryDelay: number = 1000\r\n  ): Promise<T> {\r\n    return ErrorHandler.withRetry(operation, {\r\n      strategy: 'retry',\r\n      maxRetries,\r\n      retryDelay,\r\n      onRetry: (attempt, error) => {\r\n        this.log('warn', `Operation retry ${attempt}/${maxRetries}: ${error.message}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validate parameters using type guards\r\n   */\r\n  protected validateParams<T>(\r\n    params: any,\r\n    typeGuard: (params: any) => params is T,\r\n    methodName: string\r\n  ): T {\r\n    return ParameterValidator.validate(params, typeGuard, `${this.getComponentName()}.${methodName}`);\r\n  }\r\n\r\n  /**\r\n   * Ensure database is initialized before operations\r\n   */\r\n  protected ensureInitialized(): void {\r\n    if (!this.sqliteManager.isConnected()) {\r\n      throw new Error('Database not initialized - call open() first');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Measure operation performance\r\n   */\r\n  protected async measurePerformance<T>(\r\n    operation: string,\r\n    fn: () => Promise<T>\r\n  ): Promise<T> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const result = await fn();\r\n      const duration = Date.now() - startTime;\r\n      this.log('debug', `${operation} completed in ${duration}ms`);\r\n      return result;\r\n    } catch (error) {\r\n      const duration = Date.now() - startTime;\r\n      this.log('debug', `${operation} failed after ${duration}ms`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get component name for logging and error context\r\n   */\r\n  protected abstract getComponentName(): string;\r\n\r\n  /**\r\n   * Log message with component context\r\n   */\r\n  protected log(level: string, message: string, data?: any): void {\r\n    if (this.logger) {\r\n      this.logger.log(level, `[${this.getComponentName()}] ${message}`, data);\r\n    } else {\r\n      console.log(`[${this.getComponentName()}] ${level.toUpperCase()}: ${message}`, data ? data : '');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create standardized error response for RPC\r\n   */\r\n  protected createErrorResponse(error: Error, requestId?: string): Record<string, any> {\r\n    return ErrorHandler.createErrorResponse(error, requestId);\r\n  }\r\n\r\n  /**\r\n   * Check if error is recoverable\r\n   */\r\n  protected isRecoverableError(error: Error): boolean {\r\n    return ErrorHandler.isRecoverable(error);\r\n  }\r\n\r\n  /**\r\n   * Create user-friendly error message\r\n   */\r\n  protected createUserMessage(error: Error): string {\r\n    return ErrorHandler.createUserMessage(error);\r\n  }\r\n\r\n  /**\r\n   * Sanitize sensitive data from parameters for logging\r\n   */\r\n  protected sanitizeParams(params: any, sensitiveKeys: string[] = []): any {\r\n    const defaultSensitive = ['password', 'token', 'key', 'secret'];\r\n    const allSensitive = [...defaultSensitive, ...sensitiveKeys];\r\n\r\n    if (typeof params !== 'object' || params === null) {\r\n      return params;\r\n    }\r\n\r\n    const sanitized: any = {};\r\n    for (const [key, value] of Object.entries(params)) {\r\n      if (allSensitive.some(sensitive => key.toLowerCase().includes(sensitive))) {\r\n        sanitized[key] = '[REDACTED]';\r\n      } else if (typeof value === 'object') {\r\n        sanitized[key] = this.sanitizeParams(value, sensitiveKeys);\r\n      } else {\r\n        sanitized[key] = value;\r\n      }\r\n    }\r\n\r\n    return sanitized;\r\n  }\r\n\r\n  /**\r\n   * Validate collection name with business rules\r\n   */\r\n  protected validateCollectionName(name: any, methodName: string): string {\r\n    return ParameterValidator.validateCollectionName(name, `${this.getComponentName()}.${methodName}`);\r\n  }\r\n\r\n  /**\r\n   * Validate document ID with business rules\r\n   */\r\n  protected validateDocumentId(id: any, methodName: string): string {\r\n    return ParameterValidator.validateDocumentId(id, `${this.getComponentName()}.${methodName}`);\r\n  }\r\n\r\n  /**\r\n   * Validate search limit parameter\r\n   */\r\n  protected validateLimit(limit: any, methodName: string, defaultValue: number = 10): number {\r\n    return ParameterValidator.validateLimit(limit, `${this.getComponentName()}.${methodName}`, defaultValue);\r\n  }\r\n\r\n  /**\r\n   * Validate search threshold parameter\r\n   */\r\n  protected validateThreshold(threshold: any, methodName: string): number | undefined {\r\n    return ParameterValidator.validateThreshold(threshold, `${this.getComponentName()}.${methodName}`);\r\n  }\r\n\r\n  /**\r\n   * Convert Float32Array to database-compatible blob\r\n   */\r\n  protected embeddingToBlob(embedding: Float32Array): Uint8Array {\r\n    return new Uint8Array(embedding.buffer);\r\n  }\r\n\r\n  /**\r\n   * Convert database blob to Float32Array\r\n   */\r\n  protected blobToEmbedding(blob: Uint8Array): Float32Array {\r\n    return new Float32Array(blob.buffer);\r\n  }\r\n\r\n  /**\r\n   * Format SQL query for logging (remove sensitive data)\r\n   */\r\n  protected formatSQLForLog(sql: string, params?: any[]): string {\r\n    let formattedSQL = sql.replace(/\\s+/g, ' ').trim();\r\n\r\n    if (params && params.length > 0) {\r\n      // Replace first few parameters for context, but don't include all data\r\n      const safeParams = params.slice(0, 3).map(p => {\r\n        if (typeof p === 'string') {\r\n          return p.length > 50 ? `\"${p.substring(0, 50)}...\"` : `\"${p}\"`;\r\n        } else if (p instanceof Uint8Array || p instanceof Float32Array) {\r\n          return `[${p.constructor.name} ${p.length}]`;\r\n        } else {\r\n          return String(p);\r\n        }\r\n      });\r\n\r\n      const paramStr = params.length > 3 ?\r\n        `[${safeParams.join(', ')}, ...${params.length - 3} more]` :\r\n        `[${safeParams.join(', ')}]`;\r\n\r\n      formattedSQL += ` -- params: ${paramStr}`;\r\n    }\r\n\r\n    return formattedSQL;\r\n  }\r\n\r\n  /**\r\n   * Execute SQL with logging and error handling\r\n   */\r\n  protected async executeSQLWithLogging<T>(\r\n    operation: string,\r\n    sql: string,\r\n    params?: any[],\r\n    executor?: (sql: string, params?: any[]) => Promise<T>\r\n  ): Promise<T> {\r\n    const formattedSQL = this.formatSQLForLog(sql, params);\r\n    this.log('debug', `${operation}: ${formattedSQL}`);\r\n\r\n    try {\r\n      const result = executor ?\r\n        await executor(sql, params) :\r\n        await this.sqliteManager.select(sql, params);\r\n\r\n      return result as T;\r\n    } catch (error) {\r\n      this.log('error', `${operation} failed: ${error instanceof Error ? error.message : String(error)}`);\r\n      throw error;\r\n    }\r\n  }\r\n}","/**\r\n * Simple and robust SearchHandler for LocalRetrieve Worker\r\n * Handles embedding generation for advanced search mode using existing infrastructure\r\n */\r\n\r\nimport { BaseHandler, type HandlerDependencies } from './BaseHandler.js';\r\nimport type { QueryResult } from '../../../types/worker.js';\r\n\r\n/**\r\n * Simple search handler with embedding generation capability\r\n * Uses DatabaseWorker's existing ProviderManager instead of creating its own\r\n */\r\nexport class SearchHandler extends BaseHandler {\r\n  getComponentName(): string {\r\n    return 'SearchHandler';\r\n  }\r\n\r\n  constructor(dependencies: HandlerDependencies) {\r\n    super(dependencies);\r\n  }\r\n\r\n  /**\r\n   * Generate query embedding using DatabaseWorker's ProviderManager\r\n   * This method should be called by DatabaseWorker, not used standalone\r\n   */\r\n  async generateEmbeddingWithProvider(providerManager: any, query: string, collection: string = 'default'): Promise<Float32Array> {\r\n    try {\r\n      this.logger.info('Generating query embedding', { query: query.substring(0, 50), collection });\r\n\r\n      const provider = await providerManager.getProvider(collection);\r\n      if (!provider) {\r\n        throw new Error('No embedding provider available for collection');\r\n      }\r\n\r\n      const embedding = await provider.generateEmbedding(query);\r\n\r\n      this.logger.info('Query embedding generated successfully', {\r\n        query: query.substring(0, 50),\r\n        dimensions: embedding.length\r\n      });\r\n\r\n      return embedding;\r\n\r\n    } catch (error) {\r\n      this.logger.error('Failed to generate query embedding', { query, error });\r\n      throw error;\r\n    }\r\n  }\r\n}","/**\r\n * LLM Error Classes\r\n *\r\n * Error types for LLM operations.\r\n */\r\n\r\n/**\r\n * LLM Error Codes\r\n */\r\nexport type LLMErrorCode =\r\n  | 'INVALID_CONFIG'\r\n  | 'INVALID_API_KEY'\r\n  | 'PROVIDER_ERROR'\r\n  | 'TIMEOUT'\r\n  | 'RATE_LIMIT'\r\n  | 'NETWORK_ERROR'\r\n  | 'PARSE_ERROR'\r\n  | 'UNKNOWN_ERROR';\r\n\r\n/**\r\n * Base LLM Error\r\n */\r\nexport class LLMError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly code: LLMErrorCode,\r\n    public readonly statusCode?: number,\r\n    public readonly provider?: string,\r\n    public readonly details?: any\r\n  ) {\r\n    super(message);\r\n    this.name = 'LLMError';\r\n    Object.setPrototypeOf(this, LLMError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * LLM Configuration Error\r\n */\r\nexport class LLMConfigError extends LLMError {\r\n  constructor(message: string, details?: any) {\r\n    super(message, 'INVALID_CONFIG', undefined, undefined, details);\r\n    this.name = 'LLMConfigError';\r\n    Object.setPrototypeOf(this, LLMConfigError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * LLM Provider Error (API errors)\r\n */\r\nexport class LLMProviderError extends LLMError {\r\n  constructor(message: string, statusCode: number, provider: string, details?: any) {\r\n    super(message, 'PROVIDER_ERROR', statusCode, provider, details);\r\n    this.name = 'LLMProviderError';\r\n    Object.setPrototypeOf(this, LLMProviderError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * LLM Timeout Error\r\n */\r\nexport class LLMTimeoutError extends LLMError {\r\n  constructor(provider: string, timeout: number) {\r\n    super(`LLM request timeout after ${timeout}ms`, 'TIMEOUT', undefined, provider);\r\n    this.name = 'LLMTimeoutError';\r\n    Object.setPrototypeOf(this, LLMTimeoutError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * LLM Parse Error\r\n */\r\nexport class LLMParseError extends LLMError {\r\n  constructor(message: string, provider: string, details?: any) {\r\n    super(message, 'PARSE_ERROR', undefined, provider, details);\r\n    this.name = 'LLMParseError';\r\n    Object.setPrototypeOf(this, LLMParseError.prototype);\r\n  }\r\n}\r\n","/**\r\n * Prompt Templates\r\n *\r\n * Reusable prompt templates for LLM operations.\r\n */\r\n\r\n/**\r\n * Build prompt for query enhancement\r\n */\r\nexport function buildEnhanceQueryPrompt(query: string): string {\r\n  return `You are a search query expert. Analyze and enhance this search query.\r\n\r\nOriginal query: \"${query}\"\r\n\r\nProvide:\r\n1. Enhanced query (expanded with relevant terms)\r\n2. 3 alternative query suggestions\r\n3. User's likely search intent\r\n4. Confidence score (0-1)\r\n\r\nFormat response as JSON:\r\n{\r\n  \"enhancedQuery\": \"...\",\r\n  \"suggestions\": [\"...\", \"...\", \"...\"],\r\n  \"intent\": \"...\",\r\n  \"confidence\": 0.85\r\n}`;\r\n}\r\n\r\n/**\r\n * Build prompt for result summarization\r\n */\r\nexport function buildSummarizeResultsPrompt(results: any[]): string {\r\n  const resultsText = results\r\n    .map((r, i) => {\r\n      const title = r.title || 'Untitled';\r\n      const content = r.content ? r.content.substring(0, 200) : 'No content';\r\n      return `${i + 1}. ${title}: ${content}...`;\r\n    })\r\n    .join('\\n\\n');\r\n\r\n  return `You are a search result summarizer. Analyze these search results and provide a concise summary.\r\n\r\nSearch Results:\r\n${resultsText}\r\n\r\nProvide:\r\n1. Executive summary (2-3 sentences)\r\n2. Key points (3-5 bullet points)\r\n3. Main themes\r\n4. Confidence score (0-1)\r\n\r\nFormat response as JSON:\r\n{\r\n  \"summary\": \"...\",\r\n  \"keyPoints\": [\"...\", \"...\", \"...\"],\r\n  \"themes\": [\"...\", \"...\"],\r\n  \"confidence\": 0.9\r\n}`;\r\n}\r\n\r\n/**\r\n * Validate prompt length\r\n */\r\nexport function validatePromptLength(prompt: string, maxLength: number = 4000): boolean {\r\n  return prompt.length <= maxLength;\r\n}\r\n","/**\r\n * Base LLM Provider\r\n *\r\n * Abstract base class for all LLM provider implementations.\r\n * Provides common functionality for HTTP requests, error handling, and retries.\r\n */\r\n\r\nimport type { Logger } from '../../database/worker/utils/Logger.js';\r\nimport type { LLMProviderConfig, LLMRequestOptions, LLMResponse } from '../types.js';\r\nimport { LLMError, LLMConfigError, LLMProviderError, LLMTimeoutError, LLMParseError } from '../errors.js';\r\nimport { buildEnhanceQueryPrompt, buildSummarizeResultsPrompt } from '../PromptTemplates.js';\r\n\r\nexport abstract class BaseLLMProvider {\r\n  protected config: LLMProviderConfig;\r\n  protected logger: Logger;\r\n\r\n  constructor(config: LLMProviderConfig, logger: Logger) {\r\n    this.config = config;\r\n    this.logger = logger;\r\n    this.validateConfig();\r\n  }\r\n\r\n  /**\r\n   * Abstract methods to be implemented by specific providers\r\n   */\r\n  protected abstract buildRequestURL(): string;\r\n  protected abstract buildRequestHeaders(): Record<string, string>;\r\n  protected abstract buildRequestBody(prompt: string, options?: LLMRequestOptions): any;\r\n  protected abstract parseResponse(response: any): LLMResponse;\r\n\r\n  /**\r\n   * Validate provider configuration\r\n   */\r\n  protected validateConfig(): void {\r\n    if (!this.config.provider) {\r\n      throw new LLMConfigError('Provider is required');\r\n    }\r\n    if (!this.config.model) {\r\n      throw new LLMConfigError('Model is required');\r\n    }\r\n    if (!this.config.apiKey && this.config.provider !== 'custom') {\r\n      throw new LLMConfigError(`API key required for provider: ${this.config.provider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute HTTP request to LLM API\r\n   */\r\n  protected async executeRequest(\r\n    prompt: string,\r\n    options?: LLMRequestOptions\r\n  ): Promise<LLMResponse> {\r\n    const url = this.buildRequestURL();\r\n    const headers = this.buildRequestHeaders();\r\n    const body = this.buildRequestBody(prompt, options);\r\n\r\n    const timeout = options?.timeout || this.config.timeout || 10000;\r\n    const controller = new AbortController();\r\n    const signal = options?.signal || controller.signal;\r\n\r\n    // Setup timeout\r\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n\r\n    try {\r\n      this.logger.debug(`LLM Request to ${this.config.provider}`, {\r\n        provider: this.config.provider,\r\n        model: this.config.model,\r\n        promptLength: prompt.length\r\n      });\r\n\r\n      const response = await fetch(url, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          ...headers\r\n        },\r\n        body: JSON.stringify(body),\r\n        signal\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      if (!response.ok) {\r\n        const errorBody = await response.json().catch(() => ({}));\r\n        throw new LLMProviderError(\r\n          errorBody.error?.message || response.statusText,\r\n          response.status,\r\n          this.config.provider,\r\n          errorBody\r\n        );\r\n      }\r\n\r\n      const data = await response.json();\r\n      const llmResponse = this.parseResponse(data);\r\n\r\n      this.logger.debug(`LLM Response from ${this.config.provider}`, {\r\n        provider: this.config.provider,\r\n        model: this.config.model,\r\n        finishReason: llmResponse.finishReason,\r\n        textLength: llmResponse.text.length\r\n      });\r\n\r\n      return llmResponse;\r\n\r\n    } catch (error: any) {\r\n      clearTimeout(timeoutId);\r\n\r\n      if (error.name === 'AbortError') {\r\n        throw new LLMTimeoutError(this.config.provider, timeout);\r\n      }\r\n      if (error instanceof LLMError) {\r\n        throw error;\r\n      }\r\n      throw new LLMError(\r\n        `LLM request failed: ${error.message}`,\r\n        'NETWORK_ERROR',\r\n        undefined,\r\n        this.config.provider,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute request with retry logic\r\n   */\r\n  protected async executeRequestWithRetry(\r\n    prompt: string,\r\n    options?: LLMRequestOptions\r\n  ): Promise<LLMResponse> {\r\n    const maxRetries = this.config.maxRetries || 2;\r\n    let lastError: Error;\r\n\r\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        return await this.executeRequest(prompt, options);\r\n      } catch (error: any) {\r\n        lastError = error;\r\n\r\n        // Don't retry on config errors or timeouts\r\n        if (error instanceof LLMConfigError || error instanceof LLMTimeoutError) {\r\n          throw error;\r\n        }\r\n\r\n        // Don't retry on 4xx errors (client errors)\r\n        if (error instanceof LLMProviderError && error.statusCode && error.statusCode < 500) {\r\n          throw error;\r\n        }\r\n\r\n        // Wait before retry (exponential backoff)\r\n        if (attempt < maxRetries) {\r\n          const delay = Math.pow(2, attempt) * 1000;\r\n          this.logger.warn(`LLM request failed, retrying in ${delay}ms`, {\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error.message\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n        }\r\n      }\r\n    }\r\n\r\n    throw lastError!;\r\n  }\r\n\r\n  /**\r\n   * Public API: Generic LLM call with arbitrary prompt (SCRUM-17)\r\n   *\r\n   * This method provides direct access to the LLM with any custom prompt.\r\n   * Use this for custom use cases beyond query enhancement or summarization.\r\n   *\r\n   * @param prompt - The prompt to send to the LLM\r\n   * @param options - Optional request configuration\r\n   * @returns Raw LLM response with text and metadata\r\n   */\r\n  async call(prompt: string, options?: LLMRequestOptions): Promise<LLMResponse> {\r\n    return await this.executeRequestWithRetry(prompt, options);\r\n  }\r\n\r\n  /**\r\n   * Public API: Enhance query\r\n   */\r\n  async enhanceQuery(query: string, options?: LLMRequestOptions): Promise<LLMResponse> {\r\n    const prompt = buildEnhanceQueryPrompt(query);\r\n    return await this.executeRequestWithRetry(prompt, options);\r\n  }\r\n\r\n  /**\r\n   * Public API: Summarize results\r\n   */\r\n  async summarizeResults(results: any[], options?: LLMRequestOptions): Promise<LLMResponse> {\r\n    const prompt = buildSummarizeResultsPrompt(results);\r\n    return await this.executeRequestWithRetry(prompt, options);\r\n  }\r\n}\r\n","/**\r\n * OpenAI Provider\r\n *\r\n * LLM provider implementation for OpenAI's GPT models.\r\n * Supports GPT-4, GPT-4-turbo, and GPT-3.5-turbo.\r\n */\r\n\r\nimport { BaseLLMProvider } from './BaseLLMProvider.js';\r\nimport type { LLMRequestOptions, LLMResponse } from '../types.js';\r\nimport { LLMParseError } from '../errors.js';\r\n\r\nexport class OpenAIProvider extends BaseLLMProvider {\r\n  /**\r\n   * Build OpenAI API endpoint URL\r\n   */\r\n  protected buildRequestURL(): string {\r\n    return this.config.endpoint || 'https://api.openai.com/v1/chat/completions';\r\n  }\r\n\r\n  /**\r\n   * Build OpenAI request headers\r\n   */\r\n  protected buildRequestHeaders(): Record<string, string> {\r\n    return {\r\n      'Authorization': `Bearer ${this.config.apiKey}`,\r\n      ...this.config.headers\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build OpenAI request body\r\n   */\r\n  protected buildRequestBody(prompt: string, options?: LLMRequestOptions): any {\r\n    return {\r\n      model: this.config.model,\r\n      messages: [\r\n        {\r\n          role: 'system',\r\n          content: 'You are a helpful search assistant. Always respond with valid JSON.'\r\n        },\r\n        {\r\n          role: 'user',\r\n          content: prompt\r\n        }\r\n      ],\r\n      temperature: options?.temperature ?? this.config.temperature ?? 0.7,\r\n      max_tokens: options?.maxTokens ?? this.config.maxTokens ?? 500,\r\n      response_format: { type: 'json_object' }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Parse OpenAI API response\r\n   */\r\n  protected parseResponse(data: any): LLMResponse {\r\n    try {\r\n      if (!data.choices || !data.choices[0]) {\r\n        throw new Error('Invalid response structure: missing choices');\r\n      }\r\n\r\n      const choice = data.choices[0];\r\n      const messageContent = choice.message?.content;\r\n\r\n      if (!messageContent) {\r\n        throw new Error('Invalid response structure: missing message content');\r\n      }\r\n\r\n      return {\r\n        text: messageContent,\r\n        finishReason: choice.finish_reason === 'stop' ? 'stop' : 'length',\r\n        usage: data.usage ? {\r\n          promptTokens: data.usage.prompt_tokens,\r\n          completionTokens: data.usage.completion_tokens,\r\n          totalTokens: data.usage.total_tokens\r\n        } : undefined,\r\n        model: data.model,\r\n        provider: 'openai'\r\n      };\r\n    } catch (error: any) {\r\n      throw new LLMParseError(\r\n        `Failed to parse OpenAI response: ${error.message}`,\r\n        'openai',\r\n        { data, error: error.message }\r\n      );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Anthropic Provider\r\n *\r\n * LLM provider implementation for Anthropic's Claude models.\r\n * Supports Claude 3 Opus, Sonnet, and Haiku.\r\n */\r\n\r\nimport { BaseLLMProvider } from './BaseLLMProvider.js';\r\nimport type { LLMRequestOptions, LLMResponse } from '../types.js';\r\nimport { LLMParseError } from '../errors.js';\r\n\r\nexport class AnthropicProvider extends BaseLLMProvider {\r\n  /**\r\n   * Build Anthropic API endpoint URL\r\n   */\r\n  protected buildRequestURL(): string {\r\n    return this.config.endpoint || 'https://api.anthropic.com/v1/messages';\r\n  }\r\n\r\n  /**\r\n   * Build Anthropic request headers\r\n   */\r\n  protected buildRequestHeaders(): Record<string, string> {\r\n    return {\r\n      'x-api-key': this.config.apiKey!,\r\n      'anthropic-version': '2023-06-01',\r\n      ...this.config.headers\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build Anthropic request body\r\n   */\r\n  protected buildRequestBody(prompt: string, options?: LLMRequestOptions): any {\r\n    return {\r\n      model: this.config.model,\r\n      messages: [\r\n        {\r\n          role: 'user',\r\n          content: prompt\r\n        }\r\n      ],\r\n      temperature: options?.temperature ?? this.config.temperature ?? 0.7,\r\n      max_tokens: options?.maxTokens ?? this.config.maxTokens ?? 500,\r\n      system: 'You are a helpful search assistant. Always respond with valid JSON.'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Parse Anthropic API response\r\n   */\r\n  protected parseResponse(data: any): LLMResponse {\r\n    try {\r\n      if (!data.content || !Array.isArray(data.content) || data.content.length === 0) {\r\n        throw new Error('Invalid response structure: missing content array');\r\n      }\r\n\r\n      const content = data.content[0];\r\n      if (!content.text) {\r\n        throw new Error('Invalid response structure: missing text in content');\r\n      }\r\n\r\n      return {\r\n        text: content.text,\r\n        finishReason: data.stop_reason === 'end_turn' ? 'stop' : 'length',\r\n        usage: data.usage ? {\r\n          promptTokens: data.usage.input_tokens,\r\n          completionTokens: data.usage.output_tokens,\r\n          totalTokens: data.usage.input_tokens + data.usage.output_tokens\r\n        } : undefined,\r\n        model: data.model,\r\n        provider: 'anthropic'\r\n      };\r\n    } catch (error: any) {\r\n      throw new LLMParseError(\r\n        `Failed to parse Anthropic response: ${error.message}`,\r\n        'anthropic',\r\n        { data, error: error.message }\r\n      );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * OpenRouter Provider\r\n *\r\n * LLM provider implementation for OpenRouter's unified API.\r\n * Provides access to 100+ models from OpenAI, Anthropic, Meta, Mistral, and more.\r\n * See: https://openrouter.ai/docs\r\n */\r\n\r\nimport { BaseLLMProvider } from './BaseLLMProvider.js';\r\nimport type { LLMRequestOptions, LLMResponse } from '../types.js';\r\nimport { LLMParseError } from '../errors.js';\r\n\r\nexport class OpenRouterProvider extends BaseLLMProvider {\r\n  /**\r\n   * Build OpenRouter API endpoint URL\r\n   */\r\n  protected buildRequestURL(): string {\r\n    return this.config.endpoint || 'https://openrouter.ai/api/v1/chat/completions';\r\n  }\r\n\r\n  /**\r\n   * Build OpenRouter request headers\r\n   * Includes optional HTTP-Referer and X-Title for usage tracking\r\n   */\r\n  protected buildRequestHeaders(): Record<string, string> {\r\n    const headers: Record<string, string> = {\r\n      'Authorization': `Bearer ${this.config.apiKey}`,\r\n      ...this.config.headers\r\n    };\r\n\r\n    // OpenRouter recommends these headers for better analytics and ranking\r\n    // https://openrouter.ai/docs#requests\r\n    if (!headers['HTTP-Referer']) {\r\n      headers['HTTP-Referer'] = typeof window !== 'undefined'\r\n        ? window.location.origin\r\n        : 'https://localretrieve.dev';\r\n    }\r\n\r\n    if (!headers['X-Title']) {\r\n      headers['X-Title'] = 'LocalRetrieve';\r\n    }\r\n\r\n    return headers;\r\n  }\r\n\r\n  /**\r\n   * Build OpenRouter request body (OpenAI-compatible format)\r\n   */\r\n  protected buildRequestBody(prompt: string, options?: LLMRequestOptions): any {\r\n    return {\r\n      model: this.config.model,\r\n      messages: [\r\n        {\r\n          role: 'system',\r\n          content: 'You are a helpful search assistant. Always respond with valid JSON.'\r\n        },\r\n        {\r\n          role: 'user',\r\n          content: prompt\r\n        }\r\n      ],\r\n      temperature: options?.temperature ?? this.config.temperature ?? 0.7,\r\n      max_tokens: options?.maxTokens ?? this.config.maxTokens ?? 500,\r\n      // OpenRouter supports response_format for compatible models\r\n      response_format: { type: 'json_object' }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Parse OpenRouter API response\r\n   * OpenRouter uses OpenAI-compatible response format\r\n   */\r\n  protected parseResponse(data: any): LLMResponse {\r\n    try {\r\n      if (!data.choices || !data.choices[0]) {\r\n        throw new Error('Invalid response structure: missing choices');\r\n      }\r\n\r\n      const choice = data.choices[0];\r\n      const messageContent = choice.message?.content;\r\n\r\n      if (!messageContent) {\r\n        throw new Error('Invalid response structure: missing message content');\r\n      }\r\n\r\n      return {\r\n        text: messageContent,\r\n        finishReason: choice.finish_reason === 'stop' ? 'stop' : 'length',\r\n        usage: data.usage ? {\r\n          promptTokens: data.usage.prompt_tokens,\r\n          completionTokens: data.usage.completion_tokens,\r\n          totalTokens: data.usage.total_tokens\r\n        } : undefined,\r\n        model: data.model || this.config.model,\r\n        provider: 'openrouter'\r\n      };\r\n    } catch (error: any) {\r\n      throw new LLMParseError(\r\n        `Failed to parse OpenRouter response: ${error.message}`,\r\n        'openrouter',\r\n        { data, error: error.message }\r\n      );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Custom Provider\r\n *\r\n * Generic LLM provider implementation for OpenAI-compatible endpoints.\r\n * Works with OpenRouter, Ollama, and other custom API endpoints.\r\n */\r\n\r\nimport { BaseLLMProvider } from './BaseLLMProvider.js';\r\nimport type { LLMRequestOptions, LLMResponse } from '../types.js';\r\nimport { LLMConfigError, LLMParseError } from '../errors.js';\r\n\r\nexport class CustomProvider extends BaseLLMProvider {\r\n  /**\r\n   * Validate custom provider configuration\r\n   */\r\n  protected validateConfig(): void {\r\n    super.validateConfig();\r\n    if (!this.config.endpoint) {\r\n      throw new LLMConfigError('Endpoint is required for custom provider');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build custom API endpoint URL\r\n   */\r\n  protected buildRequestURL(): string {\r\n    return this.config.endpoint!;\r\n  }\r\n\r\n  /**\r\n   * Build custom request headers\r\n   */\r\n  protected buildRequestHeaders(): Record<string, string> {\r\n    const headers: Record<string, string> = { ...this.config.headers };\r\n\r\n    // Add authorization header if API key provided\r\n    if (this.config.apiKey) {\r\n      headers['Authorization'] = `Bearer ${this.config.apiKey}`;\r\n    }\r\n\r\n    return headers;\r\n  }\r\n\r\n  /**\r\n   * Build custom request body (OpenAI-compatible format)\r\n   */\r\n  protected buildRequestBody(prompt: string, options?: LLMRequestOptions): any {\r\n    return {\r\n      model: this.config.model,\r\n      messages: [\r\n        {\r\n          role: 'system',\r\n          content: 'You are a helpful search assistant. Always respond with valid JSON.'\r\n        },\r\n        {\r\n          role: 'user',\r\n          content: prompt\r\n        }\r\n      ],\r\n      temperature: options?.temperature ?? this.config.temperature ?? 0.7,\r\n      max_tokens: options?.maxTokens ?? this.config.maxTokens ?? 500\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Parse custom API response (try multiple formats)\r\n   */\r\n  protected parseResponse(data: any): LLMResponse {\r\n    try {\r\n      // Try OpenAI format first\r\n      if (data.choices && Array.isArray(data.choices) && data.choices[0]) {\r\n        const choice = data.choices[0];\r\n        const text = choice.message?.content || choice.text || '';\r\n\r\n        return {\r\n          text,\r\n          finishReason: choice.finish_reason === 'stop' ? 'stop' : 'length',\r\n          usage: data.usage ? {\r\n            promptTokens: data.usage.prompt_tokens || 0,\r\n            completionTokens: data.usage.completion_tokens || 0,\r\n            totalTokens: data.usage.total_tokens || 0\r\n          } : undefined,\r\n          model: data.model || this.config.model,\r\n          provider: 'custom'\r\n        };\r\n      }\r\n\r\n      // Try Anthropic-like format\r\n      if (data.content && Array.isArray(data.content) && data.content[0]) {\r\n        return {\r\n          text: data.content[0].text || '',\r\n          finishReason: 'stop',\r\n          model: data.model || this.config.model,\r\n          provider: 'custom'\r\n        };\r\n      }\r\n\r\n      // Fallback: try to extract text from any response\r\n      const text = data.text || data.content || data.response || JSON.stringify(data);\r\n\r\n      return {\r\n        text,\r\n        finishReason: 'stop',\r\n        model: this.config.model,\r\n        provider: 'custom'\r\n      };\r\n    } catch (error: any) {\r\n      throw new LLMParseError(\r\n        `Failed to parse custom provider response: ${error.message}`,\r\n        'custom',\r\n        { data, error: error.message }\r\n      );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * LLM Manager\r\n *\r\n * Manages LLM provider instances and operations in the worker context.\r\n * Handles provider creation, caching, and LLM operations.\r\n */\r\n\r\nimport type { Logger } from '../utils/Logger.js';\r\nimport { BaseLLMProvider } from '../../../llm/providers/BaseLLMProvider.js';\r\nimport { OpenAIProvider } from '../../../llm/providers/OpenAIProvider.js';\r\nimport { AnthropicProvider } from '../../../llm/providers/AnthropicProvider.js';\r\nimport { OpenRouterProvider } from '../../../llm/providers/OpenRouterProvider.js';\r\nimport { CustomProvider } from '../../../llm/providers/CustomProvider.js';\r\nimport type { LLMProviderConfig, EnhancedQuery, ResultSummary } from '../../../llm/types.js';\r\nimport { LLMError, LLMParseError } from '../../../llm/errors.js';\r\n\r\nexport class LLMManager {\r\n  private logger: Logger;\r\n  private providerCache = new Map<string, BaseLLMProvider>();\r\n\r\n  constructor(logger: Logger) {\r\n    this.logger = logger;\r\n  }\r\n\r\n  /**\r\n   * Get or create provider instance\r\n   */\r\n  private getProvider(config: LLMProviderConfig): BaseLLMProvider {\r\n    // Create cache key from provider, model, and first 8 chars of API key\r\n    const apiKeyPrefix = config.apiKey ? config.apiKey.substring(0, 8) : 'none';\r\n    const cacheKey = `${config.provider}:${config.model}:${apiKeyPrefix}`;\r\n\r\n    let provider = this.providerCache.get(cacheKey);\r\n    if (!provider) {\r\n      provider = this.createProvider(config);\r\n      this.providerCache.set(cacheKey, provider);\r\n      this.logger.info(`Created LLM provider: ${config.provider}/${config.model}`);\r\n    }\r\n\r\n    return provider;\r\n  }\r\n\r\n  /**\r\n   * Create provider instance based on configuration\r\n   */\r\n  private createProvider(config: LLMProviderConfig): BaseLLMProvider {\r\n    switch (config.provider) {\r\n      case 'openai':\r\n        return new OpenAIProvider(config, this.logger);\r\n\r\n      case 'anthropic':\r\n        return new AnthropicProvider(config, this.logger);\r\n\r\n      case 'openrouter':\r\n        return new OpenRouterProvider(config, this.logger);\r\n\r\n      case 'custom':\r\n        return new CustomProvider(config, this.logger);\r\n\r\n      default:\r\n        throw new LLMError(\r\n          `Unknown provider: ${config.provider}`,\r\n          'INVALID_CONFIG',\r\n          undefined,\r\n          config.provider\r\n        );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generic LLM call with arbitrary prompt (SCRUM-17)\r\n   *\r\n   * Provides direct access to LLM for custom use cases.\r\n   * Returns raw LLM response without JSON parsing.\r\n   */\r\n  async callLLM(\r\n    prompt: string,\r\n    config: LLMProviderConfig,\r\n    options?: any\r\n  ): Promise<{ text: string; finishReason: string; usage?: any; model: string; provider: string; processingTime: number }> {\r\n    const startTime = Date.now();\r\n    const provider = this.getProvider(config);\r\n\r\n    try {\r\n      this.logger.debug(`Generic LLM call`, {\r\n        provider: config.provider,\r\n        promptLength: prompt.length\r\n      });\r\n\r\n      const response = await provider.call(prompt, options);\r\n\r\n      const result = {\r\n        text: response.text,\r\n        finishReason: response.finishReason,\r\n        usage: response.usage,\r\n        model: response.model || config.model,\r\n        provider: response.provider || config.provider,\r\n        processingTime: Date.now() - startTime\r\n      };\r\n\r\n      this.logger.debug('Generic LLM call complete', {\r\n        provider: config.provider,\r\n        processingTime: result.processingTime,\r\n        textLength: result.text.length\r\n      });\r\n\r\n      return result;\r\n\r\n    } catch (error: any) {\r\n      this.logger.error('Generic LLM call failed', {\r\n        error: error.message,\r\n        provider: config.provider,\r\n        promptLength: prompt.length\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enhance query using LLM\r\n   */\r\n  async enhanceQuery(\r\n    query: string,\r\n    config: LLMProviderConfig,\r\n    options?: any\r\n  ): Promise<EnhancedQuery> {\r\n    const startTime = Date.now();\r\n    const provider = this.getProvider(config);\r\n\r\n    try {\r\n      this.logger.debug(`Enhancing query: \"${query}\"`, { provider: config.provider });\r\n\r\n      const response = await provider.enhanceQuery(query, options);\r\n      const result = JSON.parse(response.text);\r\n\r\n      const enhancedQuery: EnhancedQuery = {\r\n        originalQuery: query,\r\n        enhancedQuery: result.enhancedQuery || query,\r\n        suggestions: Array.isArray(result.suggestions) ? result.suggestions : [],\r\n        intent: result.intent,\r\n        confidence: typeof result.confidence === 'number' ? result.confidence : 0.5,\r\n        provider: config.provider,\r\n        model: config.model,\r\n        processingTime: Date.now() - startTime\r\n      };\r\n\r\n      this.logger.debug('Query enhancement complete', {\r\n        provider: config.provider,\r\n        enhancedQuery: enhancedQuery.enhancedQuery,\r\n        processingTime: enhancedQuery.processingTime\r\n      });\r\n\r\n      return enhancedQuery;\r\n\r\n    } catch (error: any) {\r\n      this.logger.error('Query enhancement failed', {\r\n        error: error.message,\r\n        query,\r\n        provider: config.provider\r\n      });\r\n\r\n      // If JSON parsing fails, try to extract data manually\r\n      if (error instanceof SyntaxError) {\r\n        throw new LLMParseError(\r\n          'Failed to parse LLM JSON response',\r\n          config.provider,\r\n          { error: error.message }\r\n        );\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Summarize search results using LLM\r\n   */\r\n  async summarizeResults(\r\n    results: any[],\r\n    config: LLMProviderConfig,\r\n    options?: any\r\n  ): Promise<ResultSummary> {\r\n    const startTime = Date.now();\r\n    const provider = this.getProvider(config);\r\n\r\n    try {\r\n      this.logger.debug(`Summarizing ${results.length} results`, { provider: config.provider });\r\n\r\n      const response = await provider.summarizeResults(results, options);\r\n      const result = JSON.parse(response.text);\r\n\r\n      const summary: ResultSummary = {\r\n        summary: result.summary || '',\r\n        keyPoints: Array.isArray(result.keyPoints) ? result.keyPoints : [],\r\n        themes: Array.isArray(result.themes) ? result.themes : [],\r\n        confidence: typeof result.confidence === 'number' ? result.confidence : 0.5,\r\n        provider: config.provider,\r\n        model: config.model,\r\n        processingTime: Date.now() - startTime\r\n      };\r\n\r\n      this.logger.debug('Result summarization complete', {\r\n        provider: config.provider,\r\n        processingTime: summary.processingTime\r\n      });\r\n\r\n      return summary;\r\n\r\n    } catch (error: any) {\r\n      this.logger.error('Result summarization failed', {\r\n        error: error.message,\r\n        resultCount: results.length,\r\n        provider: config.provider\r\n      });\r\n\r\n      // If JSON parsing fails, try to extract data manually\r\n      if (error instanceof SyntaxError) {\r\n        throw new LLMParseError(\r\n          'Failed to parse LLM JSON response',\r\n          config.provider,\r\n          { error: error.message }\r\n        );\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear provider cache\r\n   */\r\n  clearCache(): void {\r\n    this.providerCache.clear();\r\n    this.logger.info('LLM provider cache cleared');\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getCacheStats() {\r\n    return {\r\n      providers: this.providerCache.size,\r\n      keys: Array.from(this.providerCache.keys())\r\n    };\r\n  }\r\n}\r\n","/**\r\n * Logger\r\n *\r\n * Centralized logging utility for worker components with level-based filtering\r\n * and structured message formatting.\r\n */\r\n\r\n/**\r\n * Available log levels\r\n */\r\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\r\n\r\n/**\r\n * Log entry structure\r\n */\r\nexport interface LogEntry {\r\n  level: LogLevel;\r\n  message: string;\r\n  timestamp: number;\r\n  component?: string;\r\n  data?: any;\r\n}\r\n\r\n/**\r\n * Logger configuration options\r\n */\r\nexport interface LoggerConfig {\r\n  level: LogLevel;\r\n  component?: string;\r\n  enableTimestamp?: boolean;\r\n  enableColors?: boolean;\r\n}\r\n\r\n/**\r\n * Centralized logger for worker components\r\n *\r\n * Provides structured logging with level filtering, component identification,\r\n * and optional data attachment. Supports different output formats for\r\n * development and production environments.\r\n */\r\nexport class Logger {\r\n  private config: Required<LoggerConfig>;\r\n  private logHistory: LogEntry[] = [];\r\n  private maxHistorySize = 1000;\r\n\r\n  // Log level priorities for filtering\r\n  private static readonly LEVEL_PRIORITY: Record<LogLevel, number> = {\r\n    debug: 0,\r\n    info: 1,\r\n    warn: 2,\r\n    error: 3\r\n  };\r\n\r\n  // Console colors for different log levels\r\n  private static readonly LEVEL_COLORS: Record<LogLevel, string> = {\r\n    debug: '\\x1b[36m', // Cyan\r\n    info: '\\x1b[32m',  // Green\r\n    warn: '\\x1b[33m',  // Yellow\r\n    error: '\\x1b[31m'  // Red\r\n  };\r\n\r\n  private static readonly RESET_COLOR = '\\x1b[0m';\r\n\r\n  constructor(config: Partial<LoggerConfig> = {}) {\r\n    this.config = {\r\n      level: config.level || 'info',\r\n      component: config.component || 'Worker',\r\n      enableTimestamp: config.enableTimestamp !== false,\r\n      enableColors: config.enableColors !== false\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Log a debug message\r\n   */\r\n  debug(message: string, data?: any): void {\r\n    this.log('debug', message, data);\r\n  }\r\n\r\n  /**\r\n   * Log an info message\r\n   */\r\n  info(message: string, data?: any): void {\r\n    this.log('info', message, data);\r\n  }\r\n\r\n  /**\r\n   * Log a warning message\r\n   */\r\n  warn(message: string, data?: any): void {\r\n    this.log('warn', message, data);\r\n  }\r\n\r\n  /**\r\n   * Log an error message\r\n   */\r\n  error(message: string, data?: any): void {\r\n    this.log('error', message, data);\r\n  }\r\n\r\n  /**\r\n   * Core logging method\r\n   */\r\n  log(level: LogLevel | string, message: string, data?: any): void {\r\n    // Check if this log level should be output\r\n    if (!this.shouldLog(level)) {\r\n      return;\r\n    }\r\n\r\n    const timestamp = Date.now();\r\n    const logEntry: LogEntry = {\r\n      level: level as LogLevel,\r\n      message,\r\n      timestamp,\r\n      component: this.config.component,\r\n      data\r\n    };\r\n\r\n    // Add to history\r\n    this.addToHistory(logEntry);\r\n\r\n    // Output to console\r\n    this.outputToConsole(logEntry);\r\n  }\r\n\r\n  /**\r\n   * Check if a log level should be output based on configuration\r\n   */\r\n  private shouldLog(level: LogLevel | string): boolean {\r\n    const normalizedLevel = level as LogLevel;\r\n    return Logger.LEVEL_PRIORITY[normalizedLevel] >= Logger.LEVEL_PRIORITY[this.config.level];\r\n  }\r\n\r\n  /**\r\n   * Add log entry to history buffer\r\n   */\r\n  private addToHistory(entry: LogEntry): void {\r\n    this.logHistory.push(entry);\r\n\r\n    // Trim history if it exceeds max size\r\n    if (this.logHistory.length > this.maxHistorySize) {\r\n      this.logHistory = this.logHistory.slice(-this.maxHistorySize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Output log entry to console with formatting\r\n   */\r\n  private outputToConsole(entry: LogEntry): void {\r\n    const parts: string[] = [];\r\n\r\n    // Add timestamp if enabled\r\n    if (this.config.enableTimestamp) {\r\n      const timestamp = new Date(entry.timestamp).toISOString();\r\n      parts.push(`[${timestamp}]`);\r\n    }\r\n\r\n    // Add component\r\n    if (entry.component) {\r\n      parts.push(`[${entry.component}]`);\r\n    }\r\n\r\n    // Add level with color if enabled\r\n    const levelStr = entry.level.toUpperCase();\r\n    if (this.config.enableColors && typeof window === 'undefined') {\r\n      // Only use colors in Node.js/Worker environment\r\n      const color = Logger.LEVEL_COLORS[entry.level];\r\n      parts.push(`${color}${levelStr}${Logger.RESET_COLOR}`);\r\n    } else {\r\n      parts.push(levelStr);\r\n    }\r\n\r\n    // Add message\r\n    parts.push(entry.message);\r\n\r\n    const logMessage = parts.join(' ');\r\n\r\n    // Choose appropriate console method\r\n    switch (entry.level) {\r\n      case 'debug':\r\n        console.debug(logMessage, entry.data);\r\n        break;\r\n      case 'info':\r\n        console.info(logMessage, entry.data);\r\n        break;\r\n      case 'warn':\r\n        console.warn(logMessage, entry.data);\r\n        break;\r\n      case 'error':\r\n        console.error(logMessage, entry.data);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get recent log history\r\n   */\r\n  getHistory(maxEntries?: number): LogEntry[] {\r\n    if (maxEntries && maxEntries > 0) {\r\n      return this.logHistory.slice(-maxEntries);\r\n    }\r\n    return [...this.logHistory];\r\n  }\r\n\r\n  /**\r\n   * Clear log history\r\n   */\r\n  clearHistory(): void {\r\n    this.logHistory = [];\r\n  }\r\n\r\n  /**\r\n   * Update logger configuration\r\n   */\r\n  updateConfig(config: Partial<LoggerConfig>): void {\r\n    this.config = { ...this.config, ...config };\r\n  }\r\n\r\n  /**\r\n   * Get current configuration\r\n   */\r\n  getConfig(): LoggerConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Create a child logger with a specific component name\r\n   */\r\n  child(component: string): Logger {\r\n    return new Logger({\r\n      ...this.config,\r\n      component\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create a simple log function compatible with existing code\r\n   */\r\n  createLogFunction(): (level: string, message: string, data?: any) => void {\r\n    return (level: string, message: string, data?: any) => {\r\n      // Map string levels to LogLevel type\r\n      const mappedLevel = this.mapStringToLogLevel(level);\r\n      this.log(mappedLevel, message, data);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Map string level to LogLevel type\r\n   */\r\n  private mapStringToLogLevel(level: string): LogLevel {\r\n    const normalizedLevel = level.toLowerCase();\r\n    if (normalizedLevel in Logger.LEVEL_PRIORITY) {\r\n      return normalizedLevel as LogLevel;\r\n    }\r\n    // Default to info for unknown levels\r\n    return 'info';\r\n  }\r\n\r\n  /**\r\n   * Static method to create a default logger instance\r\n   */\r\n  static create(component?: string, level: LogLevel = 'info'): Logger {\r\n    return new Logger({ component, level });\r\n  }\r\n}","/**\r\n * DatabaseWorker\r\n *\r\n * Main coordinator class for the refactored database worker.\r\n * Manages all worker components and coordinates RPC operations.\r\n */\r\n\r\nimport { WorkerRPCHandler } from '../../../utils/rpc.js';\r\nimport { SQLiteManager } from './SQLiteManager.js';\r\nimport { OPFSManager } from './OPFSManager.js';\r\nimport { SchemaManager } from '../schema/SchemaManager.js';\r\nimport { EmbeddingQueue } from '../embedding/EmbeddingQueue.js';\r\nimport { ProviderManager } from '../embedding/ProviderManager.js';\r\nimport { SearchHandler } from '../handlers/SearchHandler.js';\r\nimport { LLMManager } from '../llm/LLMManager.js';\r\nimport { Logger } from '../utils/Logger.js';\r\nimport { ErrorHandler } from '../utils/ErrorHandling.js';\r\n\r\nimport type {\r\n  OpenDatabaseParams,\r\n  ExecParams,\r\n  SelectParams,\r\n  BulkInsertParams,\r\n  SearchRequest,\r\n  SearchResponse,\r\n  CollectionInfo,\r\n  QueryResult,\r\n  ExportParams,\r\n  ImportParams,\r\n  CreateCollectionParams,\r\n  InsertDocumentWithEmbeddingParams,\r\n  SemanticSearchParams,\r\n  CollectionEmbeddingStatusResult,\r\n  GenerateEmbeddingRequest,\r\n  GenerateEmbeddingResult,\r\n  BatchEmbeddingRequest,\r\n  BatchEmbeddingResult,\r\n  EnqueueEmbeddingParams,\r\n  ProcessEmbeddingQueueParams,\r\n  ProcessEmbeddingQueueResult,\r\n  QueueStatusResult,\r\n  ClearEmbeddingQueueParams,\r\n  TextSearchParams,\r\n  AdvancedSearchParams,\r\n  GlobalSearchParams,\r\n  EnhancedSearchResponse,\r\n  GlobalSearchResponse,\r\n  // Task 6.2: Internal Embedding Pipeline types\r\n  GenerateQueryEmbeddingParams,\r\n  BatchGenerateQueryEmbeddingsParams,\r\n  WarmEmbeddingCacheParams,\r\n  ClearEmbeddingCacheParams,\r\n  PreloadModelsParams,\r\n  OptimizeModelMemoryParams,\r\n  QueryEmbeddingResult,\r\n  BatchQueryEmbeddingResult,\r\n  PipelinePerformanceStats,\r\n  ModelStatusResult,\r\n  // SCRUM-17: LLM Integration types\r\n  EnhanceQueryParams,\r\n  EnhancedQueryResult,\r\n  SummarizeResultsParams,\r\n  ResultSummaryResult,\r\n  SearchWithLLMParams,\r\n  LLMSearchResponseResult\r\n} from '../../../types/worker.js';\r\n\r\nimport {\r\n  isOpenDatabaseParams,\r\n  isExecParams,\r\n  isSelectParams,\r\n  isBulkInsertParams,\r\n  isSearchRequest,\r\n  isCreateCollectionParams,\r\n  isInsertDocumentWithEmbeddingParams,\r\n  isSemanticSearchParams,\r\n  isExportParams,\r\n  isImportParams,\r\n  isGenerateEmbeddingRequest,\r\n  isBatchEmbeddingRequest,\r\n  isEnqueueEmbeddingParams,\r\n  isProcessEmbeddingQueueParams,\r\n  isClearEmbeddingQueueParams\r\n} from '../utils/TypeGuards.js';\r\n\r\n/**\r\n * Main DatabaseWorker coordinator class\r\n *\r\n * This class replaces the monolithic worker implementation with a modular,\r\n * well-organized architecture. It coordinates between different components\r\n * and provides a clean RPC interface.\r\n *\r\n * Architecture:\r\n * - SQLiteManager: Direct SQLite WASM operations\r\n * - OPFSManager: Persistence and file operations\r\n * - SchemaManager: Schema initialization and migrations\r\n * - EmbeddingQueue: Background embedding processing\r\n * - ProviderManager: Embedding provider management\r\n * - Logger: Centralized logging\r\n * - ErrorHandler: Enhanced error handling\r\n */\r\nexport class DatabaseWorker {\r\n  // Core components\r\n  private sqliteManager: SQLiteManager;\r\n  private opfsManager: OPFSManager;\r\n  private schemaManager: SchemaManager;\r\n  private embeddingQueue: EmbeddingQueue;\r\n  private providerManager: ProviderManager;\r\n  private searchHandler: SearchHandler;\r\n  private llmManager: LLMManager;\r\n  private logger: Logger;\r\n\r\n  // RPC handler\r\n  private rpcHandler: WorkerRPCHandler;\r\n\r\n  // Worker state\r\n  private isInitialized = false;\r\n  private startTime = Date.now();\r\n\r\n  constructor() {\r\n    // Initialize logger first\r\n    this.logger = new Logger({\r\n      level: 'debug',\r\n      component: 'DatabaseWorker'\r\n    });\r\n\r\n    // Initialize core components\r\n    this.sqliteManager = new SQLiteManager(this.logger);\r\n    this.opfsManager = new OPFSManager(this.sqliteManager, this.logger);\r\n    this.schemaManager = new SchemaManager(this.sqliteManager, this.logger);\r\n    this.embeddingQueue = new EmbeddingQueue(this.sqliteManager, this.logger);\r\n    this.providerManager = new ProviderManager(this.sqliteManager, this.logger);\r\n    this.searchHandler = new SearchHandler({\r\n      sqliteManager: this.sqliteManager,\r\n      schemaManager: this.schemaManager,\r\n      opfsManager: this.opfsManager,\r\n      logger: this.logger\r\n    });\r\n    this.llmManager = new LLMManager(this.logger);\r\n\r\n    // Initialize RPC handler\r\n    this.rpcHandler = new WorkerRPCHandler({\r\n      logLevel: 'debug',\r\n      operationTimeout: 30000\r\n    });\r\n\r\n    this.setupRPCHandlers();\r\n    this.logger.info('DatabaseWorker initialized with modular architecture + LLM support');\r\n  }\r\n\r\n  /**\r\n   * Setup all RPC handlers\r\n   */\r\n  private setupRPCHandlers(): void {\r\n    // Core database operations\r\n    this.rpcHandler.register('open', this.handleOpen.bind(this));\r\n    this.rpcHandler.register('close', this.handleClose.bind(this));\r\n    this.rpcHandler.register('exec', this.handleExec.bind(this));\r\n    this.rpcHandler.register('select', this.handleSelect.bind(this));\r\n    this.rpcHandler.register('bulkInsert', this.handleBulkInsert.bind(this));\r\n\r\n    // WASM-specific operations\r\n    this.rpcHandler.register('initVecExtension', this.handleInitVecExtension.bind(this));\r\n\r\n    // Schema management\r\n    this.rpcHandler.register('initializeSchema', this.handleInitializeSchema.bind(this));\r\n    this.rpcHandler.register('getCollectionInfo', this.handleGetCollectionInfo.bind(this));\r\n\r\n    // Collection management\r\n    this.rpcHandler.register('createCollection', this.handleCreateCollection.bind(this));\r\n    this.rpcHandler.register('getCollectionEmbeddingStatus', this.handleGetCollectionEmbeddingStatus.bind(this));\r\n\r\n    // Document operations with embedding support\r\n    this.rpcHandler.register('insertDocumentWithEmbedding', this.handleInsertDocumentWithEmbedding.bind(this));\r\n\r\n    // Embedding generation operations\r\n    this.rpcHandler.register('generateEmbedding', this.handleGenerateEmbedding.bind(this));\r\n    this.rpcHandler.register('batchGenerateEmbeddings', this.handleBatchGenerateEmbeddings.bind(this));\r\n    this.rpcHandler.register('regenerateCollectionEmbeddings', this.handleRegenerateCollectionEmbeddings.bind(this));\r\n\r\n    // Embedding queue management\r\n    this.rpcHandler.register('enqueueEmbedding', this.handleEnqueueEmbedding.bind(this));\r\n    this.rpcHandler.register('processEmbeddingQueue', this.handleProcessEmbeddingQueue.bind(this));\r\n    this.rpcHandler.register('getQueueStatus', this.handleGetQueueStatus.bind(this));\r\n    this.rpcHandler.register('clearEmbeddingQueue', this.handleClearEmbeddingQueue.bind(this));\r\n\r\n    // Search operations\r\n    this.rpcHandler.register('search', this.handleSearch.bind(this));\r\n    this.rpcHandler.register('searchSemantic', this.handleSearchSemantic.bind(this));\r\n    // Enhanced search API (Task 6.1)\r\n    this.rpcHandler.register('searchText', this.handleSearchText.bind(this));\r\n    this.rpcHandler.register('searchAdvanced', this.handleSearchAdvanced.bind(this));\r\n    this.rpcHandler.register('searchGlobal', this.handleSearchGlobal.bind(this));\r\n\r\n    // LLM operations (SCRUM-17)\r\n    this.rpcHandler.register('enhanceQuery', this.handleEnhanceQuery.bind(this));\r\n    this.rpcHandler.register('summarizeResults', this.handleSummarizeResults.bind(this));\r\n    this.rpcHandler.register('searchWithLLM', this.handleSearchWithLLM.bind(this));\r\n    this.rpcHandler.register('callLLM', this.handleCallLLM.bind(this));\r\n\r\n    // Task 6.2: Internal Embedding Pipeline Operations\r\n    this.rpcHandler.register('generateQueryEmbedding', this.handleGenerateQueryEmbedding.bind(this));\r\n    this.rpcHandler.register('batchGenerateQueryEmbeddings', this.handleBatchGenerateQueryEmbeddings.bind(this));\r\n    this.rpcHandler.register('warmEmbeddingCache', this.handleWarmEmbeddingCache.bind(this));\r\n    this.rpcHandler.register('clearEmbeddingCache', this.handleClearEmbeddingCache.bind(this));\r\n    this.rpcHandler.register('getPipelineStats', this.handleGetPipelineStats.bind(this));\r\n    this.rpcHandler.register('getModelStatus', this.handleGetModelStatus.bind(this));\r\n    this.rpcHandler.register('preloadModels', this.handlePreloadModels.bind(this));\r\n    this.rpcHandler.register('optimizeModelMemory', this.handleOptimizeModelMemory.bind(this));\r\n\r\n    // Data export/import\r\n    this.rpcHandler.register('export', this.handleExport.bind(this));\r\n    this.rpcHandler.register('import', this.handleImport.bind(this));\r\n    this.rpcHandler.register('clear', this.handleClear.bind(this));\r\n\r\n    // Utility operations\r\n    this.rpcHandler.register('ping', this.handlePing.bind(this));\r\n    this.rpcHandler.register('getVersion', this.handleGetVersion.bind(this));\r\n    this.rpcHandler.register('getStats', this.handleGetStats.bind(this));\r\n  }\r\n\r\n  // =============================================================================\r\n  // Core Database Operations\r\n  // =============================================================================\r\n\r\n  private async handleOpen(params: OpenDatabaseParams): Promise<void> {\r\n    const validParams = this.validateParams(params, isOpenDatabaseParams, 'handleOpen');\r\n\r\n    return this.withContext('open', async () => {\r\n      // Use filename as the primary path, fall back to path if provided\r\n      const dbFilename = validParams.filename || validParams.path || ':memory:';\r\n      this.logger.info(`Opening database with filename: ${dbFilename}, vfs: ${validParams.vfs}`);\r\n\r\n      // Initialize OPFS if using opfs:/ path\r\n      let dbPath = dbFilename;\r\n      if (dbFilename.startsWith('opfs:/')) {\r\n        this.logger.info(`Initializing OPFS database: ${dbFilename}`);\r\n        dbPath = await this.opfsManager.initializeDatabase(dbFilename);\r\n        this.logger.info(`OPFS database path resolved to: ${dbPath}`);\r\n      }\r\n\r\n      // Open database connection\r\n      this.logger.info(`Opening SQLite database at path: ${dbPath}`);\r\n      await this.sqliteManager.openDatabase(dbPath);\r\n\r\n      // Initialize sqlite-vec extension\r\n      await this.sqliteManager.initVecExtension();\r\n\r\n      // Apply pending OPFS data if available\r\n      const pendingData = this.opfsManager.getPendingDatabaseData();\r\n      if (pendingData) {\r\n        this.logger.info('Restoring database from OPFS data');\r\n        await this.sqliteManager.deserialize(pendingData);\r\n        this.opfsManager.clearPendingDatabaseData();\r\n        this.logger.info('Database restored from OPFS successfully');\r\n\r\n        // Verify database integrity after deserialization\r\n        try {\r\n          await this.sqliteManager.exec('SELECT 1');\r\n          this.logger.info('Database connection verified after restore');\r\n        } catch (error) {\r\n          this.logger.error('Database connection invalid after restore, reopening...', { error });\r\n          // Close and reopen the connection\r\n          this.sqliteManager.closeDatabase();\r\n          await this.sqliteManager.openDatabase(dbPath);\r\n          await this.sqliteManager.initVecExtension();\r\n          this.logger.info('Database connection re-established');\r\n        }\r\n      }\r\n\r\n      // Start OPFS auto-sync if using OPFS\r\n      if (dbFilename.startsWith('opfs:/')) {\r\n        this.opfsManager.startAutoSync();\r\n      }\r\n\r\n      this.isInitialized = true;\r\n      this.logger.info(`Database opened successfully: ${dbFilename}`);\r\n    });\r\n  }\r\n\r\n  private async handleClose(): Promise<void> {\r\n    return this.withContext('close', async () => {\r\n      if (!this.isInitialized) {\r\n        return;\r\n      }\r\n\r\n      try {\r\n        // Cleanup embedding providers\r\n        await this.providerManager.dispose();\r\n\r\n        // Force final sync to OPFS\r\n        await this.opfsManager.forceSync();\r\n\r\n        // Stop auto-sync\r\n        this.opfsManager.stopAutoSync();\r\n\r\n        // Close database\r\n        this.sqliteManager.closeDatabase();\r\n\r\n        // Cleanup OPFS manager\r\n        this.opfsManager.cleanup();\r\n\r\n        this.isInitialized = false;\r\n        this.logger.info('Database closed successfully');\r\n      } catch (error) {\r\n        this.logger.error(`Error during database close: ${error instanceof Error ? error.message : String(error)}`);\r\n        throw error;\r\n      }\r\n    });\r\n  }\r\n\r\n  private async handleExec(params: ExecParams): Promise<QueryResult | void> {\r\n    const validParams = this.validateParams(params, isExecParams, 'handleExec');\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('exec', async () => {\r\n      await this.sqliteManager.exec(validParams.sql, validParams.params);\r\n      this.logger.debug(`Executed SQL: ${validParams.sql.substring(0, 100)}...`);\r\n    });\r\n  }\r\n\r\n  private async handleSelect(params: SelectParams): Promise<QueryResult> {\r\n    const validParams = this.validateParams(params, isSelectParams, 'handleSelect');\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('select', async () => {\r\n      const result = await this.sqliteManager.select(validParams.sql, validParams.params);\r\n      this.logger.debug(`Selected ${result.rows.length} rows`);\r\n      return result;\r\n    });\r\n  }\r\n\r\n  private async handleBulkInsert(params: BulkInsertParams): Promise<void> {\r\n    const validParams = this.validateParams(params, isBulkInsertParams, 'handleBulkInsert');\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('bulkInsert', async () => {\r\n      // TODO: Implement efficient bulk insert\r\n      // For now, use individual inserts\r\n      for (const row of validParams.data) {\r\n        const columns = Object.keys(row);\r\n        const values = Object.values(row);\r\n        const placeholders = columns.map(() => '?').join(', ');\r\n\r\n        const sql = `INSERT INTO ${validParams.tableName} (${columns.join(', ')}) VALUES (${placeholders})`;\r\n        await this.sqliteManager.select(sql, values);\r\n      }\r\n\r\n      this.logger.info(`Bulk inserted ${validParams.data.length} rows into ${validParams.tableName}`);\r\n    });\r\n  }\r\n\r\n  // =============================================================================\r\n  // Schema and Extension Operations\r\n  // =============================================================================\r\n\r\n  private async handleInitVecExtension(): Promise<void> {\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('initVecExtension', async () => {\r\n      await this.sqliteManager.initVecExtension();\r\n    });\r\n  }\r\n\r\n  private async handleInitializeSchema(): Promise<void> {\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('initializeSchema', async () => {\r\n      await this.schemaManager.initializeSchema();\r\n    });\r\n  }\r\n\r\n  private async handleGetCollectionInfo(name: string): Promise<CollectionInfo> {\r\n    this.ensureInitialized();\r\n    const collectionName = this.validateCollectionName(name, 'getCollectionInfo');\r\n\r\n    return this.withContext('getCollectionInfo', async () => {\r\n      return await this.schemaManager.getCollectionInfo(collectionName);\r\n    });\r\n  }\r\n\r\n  private async handleCreateCollection(params: CreateCollectionParams): Promise<void> {\r\n    const validParams = this.validateParams(params, isCreateCollectionParams, 'handleCreateCollection');\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('createCollection', async () => {\r\n      await this.schemaManager.createCollection(\r\n        validParams.name,\r\n        validParams.dimensions || 384,\r\n        validParams.config || {}\r\n      );\r\n    });\r\n  }\r\n\r\n  // =============================================================================\r\n  // Embedding Operations (Simplified for demo)\r\n  // =============================================================================\r\n\r\n  private async handleGetCollectionEmbeddingStatus(collection: string): Promise<CollectionEmbeddingStatusResult> {\r\n    // Simplified implementation\r\n    return {\r\n      collection,\r\n      collectionId: collection,\r\n      provider: 'local',\r\n      model: 'all-MiniLM-L6-v2',\r\n      dimensions: 384,\r\n      documentsWithEmbeddings: 0,\r\n      totalDocuments: 0,\r\n      isReady: true,\r\n      generationProgress: 1.0,\r\n      lastUpdated: new Date(),\r\n      configErrors: []\r\n    };\r\n  }\r\n\r\n  private async handleInsertDocumentWithEmbedding(params: InsertDocumentWithEmbeddingParams): Promise<{ id: string; embeddingGenerated: boolean }> {\r\n    const validParams = this.validateParams(params, isInsertDocumentWithEmbeddingParams, 'handleInsertDocumentWithEmbedding');\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('insertDocumentWithEmbedding', async () => {\r\n      // STEP 1: Validate document structure\r\n      const { validateDocument, generateDocumentId, sanitizeDocumentId } = await import('../utils/Validation.js');\r\n      const { DocumentInsertError } = await import('../utils/Errors.js');\r\n\r\n      validateDocument(validParams.document, validParams.collection);\r\n\r\n      // STEP 2: Generate or sanitize document ID\r\n      const documentId = validParams.document.id\r\n        ? sanitizeDocumentId(validParams.document.id)\r\n        : generateDocumentId();\r\n\r\n      // STEP 3: Prepare user metadata (NO INJECTION - pure user data)\r\n      const userMetadata = validParams.document.metadata || {};\r\n\r\n      // STEP 4: Insert document with collection in separate column\r\n      const sql = `\r\n        INSERT OR REPLACE INTO docs_default (id, title, content, collection, metadata, created_at, updated_at)\r\n        VALUES (?, ?, ?, ?, ?, strftime('%s', 'now'), strftime('%s', 'now'))\r\n      `;\r\n\r\n      try {\r\n        await this.sqliteManager.exec(sql, [\r\n          documentId,\r\n          validParams.document.title || '',\r\n          validParams.document.content || '',\r\n          validParams.collection,           //  Separate column for collection\r\n          JSON.stringify(userMetadata)       //  Pure user metadata\r\n        ]);\r\n      } catch (error) {\r\n        throw new DocumentInsertError(\r\n          `Failed to insert document into collection '${validParams.collection}'`,\r\n          {\r\n            collection: validParams.collection,\r\n            documentId,\r\n            providedFields: Object.keys(validParams.document),\r\n            originalError: error instanceof Error ? error : undefined,\r\n            suggestion: 'Check that document structure matches schema and ID is unique'\r\n          }\r\n        );\r\n      }\r\n\r\n      // STEP 5: Verify insertion (post-insert verification)\r\n      const verifyResult = await this.sqliteManager.select(\r\n        'SELECT COUNT(*) as count FROM docs_default WHERE id = ? AND collection = ?',\r\n        [documentId, validParams.collection]\r\n      );\r\n\r\n      const insertedCount = verifyResult.rows[0]?.count || 0;\r\n      if (insertedCount === 0) {\r\n        throw new DocumentInsertError(\r\n          `Document insertion verification failed: id='${documentId}' was not found in database`,\r\n          {\r\n            collection: validParams.collection,\r\n            documentId,\r\n            providedFields: Object.keys(validParams.document),\r\n            suggestion:\r\n              'This may be caused by:\\n' +\r\n              '  1) Unique constraint violation (duplicate ID)\\n' +\r\n              '  2) Database connection issue\\n' +\r\n              '  3) Transaction rollback\\n' +\r\n              'Check database logs for details.'\r\n          }\r\n        );\r\n      }\r\n\r\n      this.logger.info(`Document inserted successfully: ${documentId} in collection ${validParams.collection}`);\r\n\r\n      // STEP 6: Return accurate result\r\n      return { id: documentId, embeddingGenerated: false };\r\n    });\r\n  }\r\n\r\n  private async handleGenerateEmbedding(params: GenerateEmbeddingRequest): Promise<GenerateEmbeddingResult> {\r\n    // Simplified implementation\r\n    const validParams = this.validateParams(params, isGenerateEmbeddingRequest, 'handleGenerateEmbedding');\r\n\r\n    return {\r\n      embedding: new Float32Array(384).fill(0.1), // Mock embedding\r\n      dimensions: 384,\r\n      generationTime: 100,\r\n      cached: false,\r\n      provider: 'local'\r\n    };\r\n  }\r\n\r\n  private async handleBatchGenerateEmbeddings(params: BatchEmbeddingRequest): Promise<BatchEmbeddingResult> {\r\n    // Simplified implementation\r\n    const validParams = this.validateParams(params, isBatchEmbeddingRequest, 'handleBatchGenerateEmbeddings');\r\n\r\n    return {\r\n      success: validParams.documents.length,\r\n      failed: 0,\r\n      errors: [],\r\n      processingTime: 100\r\n    };\r\n  }\r\n\r\n  private async handleRegenerateCollectionEmbeddings(params: { collection: string; options?: any }): Promise<BatchEmbeddingResult> {\r\n    // Simplified implementation\r\n    return {\r\n      success: 0,\r\n      failed: 0,\r\n      errors: [],\r\n      processingTime: 0\r\n    };\r\n  }\r\n\r\n  // =============================================================================\r\n  // Queue Operations\r\n  // =============================================================================\r\n\r\n  private async handleEnqueueEmbedding(params: EnqueueEmbeddingParams): Promise<number> {\r\n    const validParams = this.validateParams(params, isEnqueueEmbeddingParams, 'handleEnqueueEmbedding');\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('enqueueEmbedding', async () => {\r\n      return await this.embeddingQueue.enqueue(validParams);\r\n    });\r\n  }\r\n\r\n  private async handleProcessEmbeddingQueue(params: ProcessEmbeddingQueueParams = {}): Promise<ProcessEmbeddingQueueResult> {\r\n    const validParams = this.validateParams(params, isProcessEmbeddingQueueParams, 'handleProcessEmbeddingQueue');\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('processEmbeddingQueue', async () => {\r\n      // Simple mock embedding generator\r\n      const embeddingGenerator = async (collection: string, content: string): Promise<Float32Array> => {\r\n        return new Float32Array(384).fill(0.1);\r\n      };\r\n\r\n      return await this.embeddingQueue.processQueue(validParams, embeddingGenerator);\r\n    });\r\n  }\r\n\r\n  private async handleGetQueueStatus(collection?: string): Promise<QueueStatusResult> {\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('getQueueStatus', async () => {\r\n      return await this.embeddingQueue.getStatus(collection);\r\n    });\r\n  }\r\n\r\n  private async handleClearEmbeddingQueue(params: ClearEmbeddingQueueParams = {}): Promise<number> {\r\n    const validParams = this.validateParams(params, isClearEmbeddingQueueParams, 'handleClearEmbeddingQueue');\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('clearEmbeddingQueue', async () => {\r\n      return await this.embeddingQueue.clearQueue(validParams);\r\n    });\r\n  }\r\n\r\n  // =============================================================================\r\n  // Search Operations (Simplified)\r\n  // =============================================================================\r\n\r\n  private async handleSearch(params: SearchRequest): Promise<SearchResponse> {\r\n    this.ensureInitialized();\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const {\r\n        query,\r\n        collection = 'default',\r\n        limit = 10,\r\n        fusionMethod = 'rrf',\r\n        fusionWeights = { fts: 0.6, vec: 0.4 }\r\n      } = params;\r\n\r\n      // Generate embedding if advanced mode enabled but no vector provided\r\n      let searchQuery = { ...query };\r\n      if (params.options?.enableEmbedding && query.text && !query.vector) {\r\n        try {\r\n          this.logger.info('Generating embedding for advanced search', { text: query.text });\r\n          const embedding = await this.handleGenerateQueryEmbedding({\r\n            query: query.text,\r\n            collection\r\n          });\r\n          if (embedding.embedding) {\r\n            searchQuery.vector = embedding.embedding;\r\n            this.logger.info('Successfully generated query embedding');\r\n          }\r\n        } catch (embeddingError) {\r\n          this.logger.warn('Failed to generate embedding, using text-only search', { embeddingError });\r\n        }\r\n      }\r\n\r\n      this.logger.info(`Starting search - text: \"${searchQuery.text || 'none'}\", vector: ${searchQuery.vector ? 'provided' : 'none'}, collection: ${collection}`);\r\n\r\n      // Handle different search scenarios\r\n      let searchSQL: string;\r\n      let searchParams: any[];\r\n\r\n      if (searchQuery.text && searchQuery.vector) {\r\n        // Hybrid search combining FTS and vector search\r\n        this.logger.info('Performing hybrid text + vector search');\r\n\r\n        searchSQL = `\r\n          WITH fts_results AS (\r\n            SELECT d.rowid, d.id, d.title, d.content, d.metadata,\r\n                   bm25(fts_${collection}) as fts_score,\r\n                   rank() OVER (ORDER BY bm25(fts_${collection})) as fts_rank\r\n            FROM docs_${collection} d\r\n            JOIN fts_${collection} f ON d.rowid = f.rowid\r\n            WHERE fts_${collection} MATCH ?\r\n            LIMIT ?\r\n          ),\r\n          vec_results AS (\r\n            SELECT d.rowid, d.id, d.title, d.content, d.metadata,\r\n                   v.distance as vec_score,\r\n                   rank() OVER (ORDER BY v.distance) as vec_rank\r\n            FROM docs_${collection} d\r\n            JOIN (\r\n              SELECT rowid, distance\r\n              FROM vec_${collection}_dense\r\n              WHERE embedding MATCH ?\r\n              ORDER BY distance\r\n              LIMIT ?\r\n            ) v ON d.rowid = v.rowid\r\n          )\r\n          SELECT DISTINCT\r\n            COALESCE(f.id, v.id) as id,\r\n            COALESCE(f.title, v.title) as title,\r\n            COALESCE(f.content, v.content) as content,\r\n            COALESCE(f.metadata, v.metadata) as metadata,\r\n            COALESCE(f.fts_score, 0) as fts_score,\r\n            COALESCE(v.vec_score, 1) as vec_score,\r\n            CASE\r\n              WHEN ? = 'rrf' THEN\r\n                (COALESCE(1.0/(60 + f.fts_rank), 0) + COALESCE(1.0/(60 + v.vec_rank), 0))\r\n              ELSE\r\n                (? * COALESCE(-f.fts_score, 0) + ? * COALESCE(1.0/(1.0 + v.vec_score), 0))\r\n            END as score\r\n          FROM fts_results f\r\n          FULL OUTER JOIN vec_results v ON f.rowid = v.rowid\r\n          ORDER BY score DESC\r\n          LIMIT ?\r\n        `;\r\n\r\n        const vectorJson = JSON.stringify(Array.from(searchQuery.vector));\r\n        searchParams = [\r\n          searchQuery.text, limit,\r\n          vectorJson, limit,\r\n          fusionMethod,\r\n          fusionWeights.fts, fusionWeights.vec,\r\n          limit\r\n        ];\r\n      } else if (searchQuery.text) {\r\n        // Text-only search\r\n        this.logger.info('Performing text-only FTS search');\r\n\r\n        // For multi-word queries, use OR\r\n        const words = searchQuery.text.trim().split(/\\s+/);\r\n        const ftsQuery = words.length > 1 ? words.join(' OR ') : searchQuery.text;\r\n\r\n        searchSQL = `\r\n          SELECT d.id, d.title, d.content, d.metadata,\r\n                 bm25(fts_${collection}) as fts_score,\r\n                 0 as vec_score,\r\n                 -bm25(fts_${collection}) as score\r\n          FROM docs_${collection} d\r\n          JOIN fts_${collection} f ON d.rowid = f.rowid\r\n          WHERE fts_${collection} MATCH ?\r\n          ORDER BY score DESC\r\n          LIMIT ?\r\n        `;\r\n\r\n        searchParams = [ftsQuery, limit];\r\n      } else if (searchQuery.vector) {\r\n        // Vector-only search\r\n        this.logger.info('Performing vector-only search');\r\n\r\n        const vectorJson = JSON.stringify(Array.from(searchQuery.vector));\r\n        searchSQL = `\r\n          SELECT d.id, d.title, d.content, d.metadata,\r\n                 0 as fts_score,\r\n                 v.distance as vec_score,\r\n                 1.0/(1.0 + v.distance) as score\r\n          FROM docs_${collection} d\r\n          JOIN (\r\n            SELECT rowid, distance\r\n            FROM vec_${collection}_dense\r\n            WHERE embedding MATCH ?\r\n            ORDER BY distance\r\n            LIMIT ?\r\n          ) v ON d.rowid = v.rowid\r\n          ORDER BY v.distance\r\n        `;\r\n\r\n        searchParams = [vectorJson, limit];\r\n      } else {\r\n        throw new DatabaseError('Search requires either text or vector query');\r\n      }\r\n\r\n      this.logger.info(`Executing search SQL with ${searchParams.length} parameters`);\r\n\r\n      const searchResult = await this.sqliteManager.select(searchSQL, searchParams);\r\n\r\n      const results: SearchResult[] = searchResult.rows.map(row => ({\r\n        id: row.id,\r\n        title: row.title,\r\n        content: row.content,\r\n        metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\r\n        score: row.score,\r\n        ftsScore: row.fts_score,\r\n        vecScore: row.vec_score\r\n      }));\r\n\r\n      const searchTime = Date.now() - startTime;\r\n      this.operationCount++;\r\n\r\n      this.logger.debug(`Search completed in ${searchTime}ms, found ${results.length} results`);\r\n\r\n      return {\r\n        results,\r\n        totalResults: results.length,\r\n        searchTime\r\n      };\r\n\r\n    } catch (error) {\r\n      this.logger.error('Search failed', { error });\r\n      return {\r\n        results: [],\r\n        totalResults: 0,\r\n        searchTime: Date.now() - startTime\r\n      };\r\n    }\r\n  }\r\n\r\n  private async handleSearchSemantic(params: SemanticSearchParams): Promise<SearchResponse> {\r\n    // Simplified implementation\r\n    return {\r\n      results: [],\r\n      totalResults: 0,\r\n      searchTime: 5\r\n    };\r\n  }\r\n\r\n  // Enhanced Search API (Task 6.1)\r\n  // Note: These methods are placeholders for future enhanced search implementation\r\n  private async handleSearchText(params: TextSearchParams): Promise<EnhancedSearchResponse> {\r\n    this.ensureInitialized();\r\n    return this.withContext('searchText', async () => {\r\n      // Fallback to regular search for now\r\n      const searchResult = await this.handleSearch({\r\n        query: { text: params.query },\r\n        collection: params.options?.collection || 'default',\r\n        limit: params.options?.limit || 10\r\n      });\r\n\r\n      return {\r\n        results: searchResult.results,\r\n        searchTime: searchResult.searchTime,\r\n        strategy: 'fts'\r\n      };\r\n    });\r\n  }\r\n\r\n  private async handleSearchAdvanced(params: AdvancedSearchParams): Promise<EnhancedSearchResponse> {\r\n    this.ensureInitialized();\r\n    return this.withContext('searchAdvanced', async () => {\r\n      // Fallback to regular search\r\n      const searchResult = await this.handleSearch({\r\n        query: params.query,\r\n        collection: params.options?.collection || 'default',\r\n        limit: params.options?.limit || 10\r\n      });\r\n\r\n      return {\r\n        results: searchResult.results,\r\n        searchTime: searchResult.searchTime,\r\n        strategy: 'hybrid'\r\n      };\r\n    });\r\n  }\r\n\r\n  private async handleSearchGlobal(params: GlobalSearchParams): Promise<GlobalSearchResponse> {\r\n    this.ensureInitialized();\r\n    return this.withContext('searchGlobal', async () => {\r\n      // Simple implementation - search across all collections\r\n      const searchResult = await this.handleSearch({\r\n        query: { text: params.query },\r\n        limit: params.options?.limit || 10\r\n      });\r\n\r\n      return {\r\n        resultsByCollection: {\r\n          default: searchResult.results\r\n        },\r\n        totalResults: searchResult.results.length,\r\n        searchTime: searchResult.searchTime\r\n      };\r\n    });\r\n  }\r\n\r\n  // =============================================================================\r\n  // Import/Export Operations\r\n  // =============================================================================\r\n\r\n  private async handleExport(params?: ExportParams): Promise<Uint8Array> {\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('export', async () => {\r\n      return await this.sqliteManager.serialize();\r\n    });\r\n  }\r\n\r\n  private async handleImport(params: ImportParams): Promise<void> {\r\n    const validParams = this.validateParams(params, isImportParams, 'handleImport');\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('import', async () => {\r\n      const data = params.data instanceof ArrayBuffer ? new Uint8Array(params.data) : params.data;\r\n      await this.sqliteManager.deserialize(data);\r\n\r\n      // Reinitialize schema if needed\r\n      await this.schemaManager.initializeSchema();\r\n    });\r\n  }\r\n\r\n  private async handleClear(): Promise<void> {\r\n    this.ensureInitialized();\r\n\r\n    return this.withContext('clear', async () => {\r\n      // Clear OPFS data\r\n      await this.opfsManager.clearDatabase();\r\n\r\n      // Reinitialize schema\r\n      await this.schemaManager.initializeSchema();\r\n    });\r\n  }\r\n\r\n  // =============================================================================\r\n  // Utility Operations\r\n  // =============================================================================\r\n\r\n  private async handlePing(): Promise<{ status: string; timestamp: number }> {\r\n    return {\r\n      status: this.isInitialized ? 'ready' : 'not_initialized',\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n\r\n  private async handleGetVersion(): Promise<{ sqlite: string; vec: string; sdk: string }> {\r\n    return {\r\n      sqlite: this.sqliteManager.getVersion(),\r\n      vec: 'available',\r\n      sdk: '1.0.0'\r\n    };\r\n  }\r\n\r\n  private async handleGetStats(): Promise<{ memory: number; dbSize: number; operations: number }> {\r\n    const uptime = Date.now() - this.startTime;\r\n\r\n    return {\r\n      memory: 0, // Not easily available in worker context\r\n      dbSize: 0, // Would need to calculate\r\n      operations: this.sqliteManager.getOperationCount()\r\n    };\r\n  }\r\n\r\n  // =============================================================================\r\n  // Helper Methods\r\n  // Task 6.2: Internal Embedding Pipeline Handlers\r\n  // =============================================================================\r\n\r\n  private async handleGenerateQueryEmbedding(params: GenerateQueryEmbeddingParams): Promise<QueryEmbeddingResult> {\r\n    this.ensureInitialized();\r\n    return this.withContext('generateQueryEmbedding', async () => {\r\n      // Use SearchHandler with existing ProviderManager\r\n      const embedding = await this.searchHandler.generateEmbeddingWithProvider(\r\n        this.providerManager,\r\n        params.query,\r\n        params.collection\r\n      );\r\n\r\n      return {\r\n        embedding,\r\n        dimensions: embedding.length,\r\n        model: 'Xenova/all-MiniLM-L6-v2'\r\n      };\r\n    });\r\n  }\r\n\r\n  private async handleBatchGenerateQueryEmbeddings(params: BatchGenerateQueryEmbeddingsParams): Promise<BatchQueryEmbeddingResult[]> {\r\n    this.ensureInitialized();\r\n    return this.withContext('batchGenerateQueryEmbeddings', async () => {\r\n      // Simple batch processing - generate embeddings sequentially\r\n      const results: BatchQueryEmbeddingResult[] = [];\r\n\r\n      for (const request of params.requests) {\r\n        try {\r\n          const embedding = await this.searchHandler.generateEmbeddingWithProvider(\r\n            this.providerManager,\r\n            request.query,\r\n            request.collection\r\n          );\r\n\r\n          results.push({\r\n            query: request.query,\r\n            embedding,\r\n            dimensions: embedding.length,\r\n            model: 'Xenova/all-MiniLM-L6-v2',\r\n            success: true\r\n          });\r\n        } catch (error) {\r\n          results.push({\r\n            query: request.query,\r\n            embedding: new Float32Array(),\r\n            dimensions: 0,\r\n            model: 'Xenova/all-MiniLM-L6-v2',\r\n            success: false,\r\n            error: error instanceof Error ? error.message : String(error)\r\n          });\r\n        }\r\n      }\r\n\r\n      return results;\r\n    });\r\n  }\r\n\r\n  private async handleWarmEmbeddingCache(params: WarmEmbeddingCacheParams): Promise<void> {\r\n    this.ensureInitialized();\r\n    return this.withContext('warmEmbeddingCache', async () => {\r\n      // Use the SearchHandler's warmEmbeddingCache method\r\n      return await this.searchHandler.warmEmbeddingCache(params.collection, params.commonQueries);\r\n    });\r\n  }\r\n\r\n  private async handleClearEmbeddingCache(params?: ClearEmbeddingCacheParams): Promise<void> {\r\n    this.ensureInitialized();\r\n    return this.withContext('clearEmbeddingCache', async () => {\r\n      const embeddingPipeline = (this.searchHandler as any).embeddingPipeline;\r\n\r\n      if (!embeddingPipeline) {\r\n        this.logger.warn('Embedding pipeline not available for cache clearing');\r\n        return;\r\n      }\r\n\r\n      await (this.searchHandler as any).pipelineInitialized;\r\n\r\n      if (params?.pattern) {\r\n        // TODO: Implement pattern-based cache clearing\r\n        this.logger.warn('Pattern-based cache clearing not yet implemented');\r\n      } else {\r\n        await embeddingPipeline.clearCache(params?.collection);\r\n      }\r\n    });\r\n  }\r\n\r\n  private async handleGetPipelineStats(): Promise<PipelinePerformanceStats> {\r\n    this.ensureInitialized();\r\n    return this.withContext('getPipelineStats', async () => {\r\n      const embeddingPipeline = (this.searchHandler as any).embeddingPipeline;\r\n\r\n      if (!embeddingPipeline) {\r\n        // Return empty stats if pipeline not available\r\n        return {\r\n          totalRequests: 0,\r\n          cacheHitRate: 0,\r\n          averageGenerationTime: 0,\r\n          activeModels: 0,\r\n          memoryUsage: 0,\r\n          cacheStats: {\r\n            memory: { hits: 0, misses: 0 },\r\n            indexedDB: { hits: 0, misses: 0 },\r\n            database: { hits: 0, misses: 0 }\r\n          }\r\n        };\r\n      }\r\n\r\n      await (this.searchHandler as any).pipelineInitialized;\r\n      return embeddingPipeline.getPerformanceStats();\r\n    });\r\n  }\r\n\r\n  private async handleGetModelStatus(): Promise<ModelStatusResult> {\r\n    this.ensureInitialized();\r\n    return this.withContext('getModelStatus', async () => {\r\n      const modelManager = (this.searchHandler as any).modelManager;\r\n\r\n      if (!modelManager) {\r\n        // Return empty status if model manager not available\r\n        return {\r\n          loadedModels: [],\r\n          totalMemoryUsage: 0,\r\n          activeCount: 0,\r\n          providerStats: {}\r\n        };\r\n      }\r\n\r\n      await (this.searchHandler as any).pipelineInitialized;\r\n      const modelStatus = modelManager.getModelStatus();\r\n\r\n      // Convert to the expected format\r\n      return {\r\n        loadedModels: modelStatus.loadedModels.map((model: any) => ({\r\n          modelId: model.modelId,\r\n          provider: model.provider,\r\n          modelName: model.modelName,\r\n          dimensions: model.dimensions,\r\n          memoryUsage: model.memoryUsage,\r\n          lastUsed: model.lastUsed,\r\n          usageCount: model.usageCount,\r\n          status: model.status\r\n        })),\r\n        totalMemoryUsage: modelStatus.totalMemoryUsage,\r\n        activeCount: modelStatus.activeCount,\r\n        providerStats: modelStatus.providerStats\r\n      };\r\n    });\r\n  }\r\n\r\n  private async handlePreloadModels(params: PreloadModelsParams): Promise<void> {\r\n    this.ensureInitialized();\r\n    return this.withContext('preloadModels', async () => {\r\n      const modelManager = (this.searchHandler as any).modelManager;\r\n\r\n      if (!modelManager) {\r\n        this.logger.warn('Model manager not available for preloading');\r\n        return;\r\n      }\r\n\r\n      await (this.searchHandler as any).pipelineInitialized;\r\n      await modelManager.preloadModels(params.strategy || 'lazy');\r\n    });\r\n  }\r\n\r\n  private async handleOptimizeModelMemory(params?: OptimizeModelMemoryParams): Promise<void> {\r\n    this.ensureInitialized();\r\n    return this.withContext('optimizeModelMemory', async () => {\r\n      const modelManager = (this.searchHandler as any).modelManager;\r\n\r\n      if (!modelManager) {\r\n        this.logger.warn('Model manager not available for memory optimization');\r\n        return;\r\n      }\r\n\r\n      await (this.searchHandler as any).pipelineInitialized;\r\n      await modelManager.optimizeMemory(params);\r\n    });\r\n  }\r\n\r\n  // =============================================================================\r\n  // LLM Operations (SCRUM-17)\r\n  // =============================================================================\r\n\r\n  private async handleEnhanceQuery(params: EnhanceQueryParams): Promise<EnhancedQueryResult> {\r\n    this.ensureInitialized();\r\n    return this.withContext('enhanceQuery', async () => {\r\n      const config: import('../../../llm/types.js').LLMProviderConfig = {\r\n        provider: (params.options?.provider as any) || 'openai',\r\n        model: params.options?.model || 'gpt-4',\r\n        apiKey: params.options?.apiKey,\r\n        endpoint: params.options?.endpoint,\r\n        temperature: params.options?.temperature,\r\n        timeout: params.options?.timeout\r\n      };\r\n\r\n      return await this.llmManager.enhanceQuery(params.query, config, params.options);\r\n    });\r\n  }\r\n\r\n  private async handleSummarizeResults(params: SummarizeResultsParams): Promise<ResultSummaryResult> {\r\n    this.ensureInitialized();\r\n    return this.withContext('summarizeResults', async () => {\r\n      const config: import('../../../llm/types.js').LLMProviderConfig = {\r\n        provider: (params.options?.provider as any) || 'openai',\r\n        model: params.options?.model || 'gpt-4',\r\n        apiKey: params.options?.apiKey,\r\n        endpoint: params.options?.endpoint,\r\n        temperature: params.options?.temperature,\r\n        timeout: params.options?.timeout\r\n      };\r\n\r\n      return await this.llmManager.summarizeResults(params.results, config, params.options);\r\n    });\r\n  }\r\n\r\n  private async handleSearchWithLLM(params: SearchWithLLMParams): Promise<LLMSearchResponseResult> {\r\n    this.ensureInitialized();\r\n    return this.withContext('searchWithLLM', async () => {\r\n      const startTime = Date.now();\r\n      let enhancedQuery: EnhancedQueryResult | undefined;\r\n      let llmTime = 0;\r\n\r\n      // Step 1: Enhance query if requested\r\n      if (params.options?.enhanceQuery) {\r\n        const enhanceStart = Date.now();\r\n        const config: import('../../../llm/types.js').LLMProviderConfig = {\r\n          provider: (params.options.llmOptions?.provider as any) || 'openai',\r\n          model: params.options.llmOptions?.model || 'gpt-4',\r\n          apiKey: params.options.llmOptions?.apiKey,\r\n          endpoint: params.options.llmOptions?.endpoint,\r\n          temperature: params.options.llmOptions?.temperature\r\n        };\r\n        enhancedQuery = await this.llmManager.enhanceQuery(params.query, config);\r\n        llmTime += Date.now() - enhanceStart;\r\n      }\r\n\r\n      // Step 2: Execute search with enhanced query\r\n      const searchQuery = enhancedQuery?.enhancedQuery || params.query;\r\n      const searchStart = Date.now();\r\n      const searchResponse = await this.handleSearchText({\r\n        query: searchQuery,\r\n        options: params.options?.searchOptions\r\n      });\r\n      const searchTime = Date.now() - searchStart;\r\n\r\n      // Step 3: Summarize results if requested\r\n      let summary: ResultSummaryResult | undefined;\r\n      if (params.options?.summarizeResults && searchResponse.results.length > 0) {\r\n        const summaryStart = Date.now();\r\n        const config: import('../../../llm/types.js').LLMProviderConfig = {\r\n          provider: (params.options.llmOptions?.provider as any) || 'openai',\r\n          model: params.options.llmOptions?.model || 'gpt-4',\r\n          apiKey: params.options.llmOptions?.apiKey,\r\n          endpoint: params.options.llmOptions?.endpoint,\r\n          temperature: params.options.llmOptions?.temperature\r\n        };\r\n        summary = await this.llmManager.summarizeResults(searchResponse.results, config);\r\n        llmTime += Date.now() - summaryStart;\r\n      }\r\n\r\n      return {\r\n        results: searchResponse.results,\r\n        enhancedQuery,\r\n        summary,\r\n        searchTime,\r\n        llmTime,\r\n        totalTime: Date.now() - startTime\r\n      };\r\n    });\r\n  }\r\n\r\n  private async handleCallLLM(params: import('../../../types/worker.js').CallLLMParams): Promise<import('../../../types/worker.js').CallLLMResult> {\r\n    this.ensureInitialized();\r\n    return this.withContext('callLLM', async () => {\r\n      const config: import('../../../llm/types.js').LLMProviderConfig = {\r\n        provider: (params.options?.provider as any) || 'openai',\r\n        model: params.options?.model || 'gpt-4',\r\n        apiKey: params.options?.apiKey,\r\n        endpoint: params.options?.endpoint,\r\n        temperature: params.options?.temperature,\r\n        maxTokens: params.options?.maxTokens,\r\n        timeout: params.options?.timeout\r\n      };\r\n\r\n      const result = await this.llmManager.callLLM(params.prompt, config, params.options);\r\n\r\n      return {\r\n        text: result.text,\r\n        finishReason: result.finishReason as 'stop' | 'length' | 'error' | 'timeout',\r\n        usage: result.usage,\r\n        model: result.model,\r\n        provider: result.provider,\r\n        processingTime: result.processingTime\r\n      };\r\n    });\r\n  }\r\n\r\n  // =============================================================================\r\n  // Helper Methods\r\n  // =============================================================================\r\n\r\n  private validateParams<T>(\r\n    params: any,\r\n    typeGuard: (params: any) => params is T,\r\n    methodName: string\r\n  ): T {\r\n    if (!typeGuard(params)) {\r\n      throw new Error(`Invalid parameters for ${methodName}: ${JSON.stringify(params)}`);\r\n    }\r\n    return params;\r\n  }\r\n\r\n  private validateCollectionName(name: any, methodName: string): string {\r\n    if (typeof name !== 'string' || name.length === 0) {\r\n      throw new Error(`Invalid collection name for ${methodName}: must be a non-empty string`);\r\n    }\r\n    return name;\r\n  }\r\n\r\n  private ensureInitialized(): void {\r\n    if (!this.isInitialized) {\r\n      throw new Error('Database not initialized - call open() first');\r\n    }\r\n  }\r\n\r\n  private async withContext<T>(operation: string, fn: () => Promise<T>): Promise<T> {\r\n    return ErrorHandler.withContext(operation, 'DatabaseWorker', fn);\r\n  }\r\n}","/**\r\n * Worker Entry Point\r\n *\r\n * Main entry point for the refactored database worker with modular architecture.\r\n * This file replaces the old monolithic worker.ts file.\r\n */\r\n\r\nimport { DatabaseWorker } from './core/DatabaseWorker.js';\r\n\r\n// Initialize and start the worker\r\nconst worker = new DatabaseWorker();\r\n\r\n// Handle any unhandled errors\r\nself.addEventListener('error', (event) => {\r\n  console.error('[Worker] Unhandled error:', event.error);\r\n});\r\n\r\nself.addEventListener('unhandledrejection', (event) => {\r\n  console.error('[Worker] Unhandled promise rejection:', event.reason);\r\n});\r\n\r\nexport { DatabaseWorker };"],"names":["SQLITE_OK","SQLITE_ROW","SQLITE_DONE","SQLITE_INTEGER","SQLITE_FLOAT","SQLITE_TEXT","SQLITE_BLOB","SQLITE_NULL","SQLITE_TRANSIENT","SQLiteManager","logger","sqlite3ModulePath","sqlite3Module","DatabaseError","versionPtr","version","error","message","dbPath","filenamePtr","dbPtrPtr","result","errorPtr","errorMsg","VectorError","testResults","sql","params","sqlPtr","stmtPtrPtr","stmtPtr","i","keys","stepResult","rows","dbPtr","param","colCount","row","colName","colType","index","paramPtr","j","byteArray","columnIndex","columnType","blobPtr","blobSize","value","schemaName","sizePtr","mainSchemaPtr","dataPtr","size","data","schemaPtr","level","OPFSManager","sqliteManager","opfsPath","tempDbName","opfsRoot","pathParts","part","currentDir","fileName","file","opfsError","OPFSError","writable","buffer","estimate","quota","usage","requiredBytes","availableMB","requiredMB","operation","CURRENT_SCHEMA_VERSION","SchemaManager","currentSchemaVersion","hasData","versionResult","docCount","currentVersion","allTables","foundTableNames","requiredTables","hasAllRequired","table","tableNames","virtualTables","virtualTable","regularTablesToClean","regularTable","name","collectionResult","collection","countResult","config","dimensions","collectionMetadata","timestamp","EmbeddingQueue","documentId","textContent","priority","queueId","fallbackId","embeddingGenerator","batchSize","maxRetries","queueItems","item","embedding","errorMessage","remainingResult","baseQuery","queryParams","stats","totalProcessingTime","completedWithTime","status","count","collections","deleteQuery","countQuery","deletedCount","limit","query","retryCount","docResult","rowid","embeddingBlob","ProviderManager","cached","initPromise","promise","provider","EmbeddingError","embeddingConfig","providerFactory","globalConfig","entry","now","expiredCollections","disposePromises","ContextualError","context","originalError","parts","ErrorHandler","component","fn","contextualError","options","retryDelay","lastError","attempt","resolve","classification","maxEntries","requestId","sensitiveKeys","allSensitiveKeys","sanitize","obj","sanitized","key","sensitive","isSQLValue","isSQLParams","isOpenDatabaseParams","isExecParams","isSelectParams","isBulkInsertParams","isCreateCollectionParams","isInsertDocumentWithEmbeddingParams","isImportParams","isGenerateEmbeddingRequest","isBatchEmbeddingRequest","doc","isEnqueueEmbeddingParams","isProcessEmbeddingQueueParams","isClearEmbeddingQueueParams","isValidCollectionName","isValidDocumentId","id","isValidLimit","isValidThreshold","threshold","ParameterValidator","typeGuard","methodName","defaultValue","BaseHandler","dependencies","startTime","duration","allSensitive","blob","formattedSQL","safeParams","p","paramStr","executor","SearchHandler","providerManager","LLMError","code","statusCode","details","LLMConfigError","LLMProviderError","LLMTimeoutError","timeout","LLMParseError","buildEnhanceQueryPrompt","buildSummarizeResultsPrompt","results","r","title","content","BaseLLMProvider","prompt","url","headers","body","controller","signal","timeoutId","response","errorBody","llmResponse","delay","OpenAIProvider","choice","messageContent","AnthropicProvider","OpenRouterProvider","CustomProvider","LLMManager","apiKeyPrefix","cacheKey","enhancedQuery","summary","Logger","logEntry","normalizedLevel","levelStr","color","logMessage","mappedLevel","DatabaseWorker","WorkerRPCHandler","validParams","dbFilename","pendingData","columns","values","placeholders","collectionName","validateDocument","generateDocumentId","sanitizeDocumentId","DocumentInsertError","userMetadata","fusionMethod","fusionWeights","searchQuery","embeddingError","searchSQL","searchParams","vectorJson","words","ftsQuery","searchTime","searchResult","request","embeddingPipeline","modelManager","modelStatus","model","llmTime","enhanceStart","searchStart","searchResponse","summaryStart","event"],"mappings":"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"}